Parsed test spec with 9 sessions

starting permutation: LockChunk1 IB I1 C1 UnlockChunk Ic Cc SC1 S1 SChunkStat
step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step IB: BEGIN;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 
 <waiting ...>
step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;
 <waiting ...>
step UnlockChunk: ROLLBACK;
step I1: <... completed>
step Ic: COMMIT;
step C1: <... completed>
compress
--------
t       
(1 row)

step Cc: COMMIT;
step SC1: SELECT (count_chunktable(ch)).* FROM show_chunks('ts_device_table') AS ch LIMIT 1;
count(*)|count(*) only
--------+-------------
      10|            0
(1 row)

step S1: SELECT count(*) from ts_device_table;
count
-----
   10
(1 row)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     1
(1 row)


starting permutation: LockChunk1 IBRR I1 C1 UnlockChunk Ic Cc SC1 S1 SChunkStat
step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step IBRR: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 
 <waiting ...>
step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;
 <waiting ...>
step UnlockChunk: ROLLBACK;
step I1: <... completed>
step Ic: COMMIT;
step C1: <... completed>
compress
--------
t       
(1 row)

step Cc: COMMIT;
step SC1: SELECT (count_chunktable(ch)).* FROM show_chunks('ts_device_table') AS ch LIMIT 1;
count(*)|count(*) only
--------+-------------
      10|            0
(1 row)

step S1: SELECT count(*) from ts_device_table;
count
-----
   10
(1 row)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     1
(1 row)


starting permutation: LockChunk1 IBS I1 C1 UnlockChunk Ic Cc SC1 S1 SChunkStat
step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step IBS: BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 
 <waiting ...>
step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;
 <waiting ...>
step UnlockChunk: ROLLBACK;
step I1: <... completed>
step Ic: COMMIT;
step C1: <... completed>
compress
--------
t       
(1 row)

step Cc: COMMIT;
step SC1: SELECT (count_chunktable(ch)).* FROM show_chunks('ts_device_table') AS ch LIMIT 1;
count(*)|count(*) only
--------+-------------
      10|            0
(1 row)

step S1: SELECT count(*) from ts_device_table;
count
-----
   10
(1 row)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     1
(1 row)


starting permutation: LockChunk1 IB Iu1 C1 UnlockChunk Ic Cc SC1 S1 SU SChunkStat
step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step IB: BEGIN;
step Iu1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 98) ON CONFLICT(time, device) DO UPDATE SET value = 98; 
 <waiting ...>
step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;
 <waiting ...>
step UnlockChunk: ROLLBACK;
step Iu1: <... completed>
step Ic: COMMIT;
step C1: <... completed>
compress
--------
t       
(1 row)

step Cc: COMMIT;
step SC1: SELECT (count_chunktable(ch)).* FROM show_chunks('ts_device_table') AS ch LIMIT 1;
count(*)|count(*) only
--------+-------------
      10|            0
(1 row)

step S1: SELECT count(*) from ts_device_table;
count
-----
   10
(1 row)

step SU: SELECT * FROM ts_device_table WHERE value IN (98,99);
time|device|location|value
----+------+--------+-----
   1|     1|     100|   98
(1 row)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     1
(1 row)


starting permutation: LockChunk1 IBRR Iu1 C1 UnlockChunk Ic Cc SC1 S1 SU SChunkStat
step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step IBRR: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step Iu1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 98) ON CONFLICT(time, device) DO UPDATE SET value = 98; 
 <waiting ...>
step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;
 <waiting ...>
step UnlockChunk: ROLLBACK;
step Iu1: <... completed>
step Ic: COMMIT;
step C1: <... completed>
compress
--------
t       
(1 row)

step Cc: COMMIT;
step SC1: SELECT (count_chunktable(ch)).* FROM show_chunks('ts_device_table') AS ch LIMIT 1;
count(*)|count(*) only
--------+-------------
      10|            0
(1 row)

step S1: SELECT count(*) from ts_device_table;
count
-----
   10
(1 row)

step SU: SELECT * FROM ts_device_table WHERE value IN (98,99);
time|device|location|value
----+------+--------+-----
   1|     1|     100|   98
(1 row)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     1
(1 row)


starting permutation: LockChunk1 IBS Iu1 C1 UnlockChunk Ic Cc SC1 S1 SU SChunkStat
step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step IBS: BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
step Iu1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 98) ON CONFLICT(time, device) DO UPDATE SET value = 98; 
 <waiting ...>
step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;
 <waiting ...>
step UnlockChunk: ROLLBACK;
step Iu1: <... completed>
step Ic: COMMIT;
step C1: <... completed>
compress
--------
t       
(1 row)

step Cc: COMMIT;
step SC1: SELECT (count_chunktable(ch)).* FROM show_chunks('ts_device_table') AS ch LIMIT 1;
count(*)|count(*) only
--------+-------------
      10|            0
(1 row)

step S1: SELECT count(*) from ts_device_table;
count
-----
   10
(1 row)

step SU: SELECT * FROM ts_device_table WHERE value IN (98,99);
time|device|location|value
----+------+--------+-----
   1|     1|     100|   98
(1 row)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     1
(1 row)


starting permutation: LockChunk1 C1 IB I1 UnlockChunk Cc Ic SC1 SA SChunkStat
step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;
 <waiting ...>
step IB: BEGIN;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 
 <waiting ...>
step UnlockChunk: ROLLBACK;
step C1: <... completed>
compress
--------
t       
(1 row)

step Cc: COMMIT;
step I1: <... completed>
step Ic: COMMIT;
step SC1: SELECT (count_chunktable(ch)).* FROM show_chunks('ts_device_table') AS ch LIMIT 1;
count(*)|count(*) only
--------+-------------
      10|           10
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   1|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
(10 rows)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)


starting permutation: LockChunk1 C1 IBRR I1 UnlockChunk Cc Ic SC1 SA SChunkStat
step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;
 <waiting ...>
step IBRR: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 
 <waiting ...>
step UnlockChunk: ROLLBACK;
step C1: <... completed>
compress
--------
t       
(1 row)

step Cc: COMMIT;
step I1: <... completed>
step Ic: COMMIT;
step SC1: SELECT (count_chunktable(ch)).* FROM show_chunks('ts_device_table') AS ch LIMIT 1;
count(*)|count(*) only
--------+-------------
      10|           10
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   1|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
(10 rows)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)


starting permutation: LockChunk1 C1 IBS I1 UnlockChunk Cc Ic SC1 SA SChunkStat
step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;
 <waiting ...>
step IBS: BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 
 <waiting ...>
step UnlockChunk: ROLLBACK;
step C1: <... completed>
compress
--------
t       
(1 row)

step Cc: COMMIT;
step I1: <... completed>
step Ic: COMMIT;
step SC1: SELECT (count_chunktable(ch)).* FROM show_chunks('ts_device_table') AS ch LIMIT 1;
count(*)|count(*) only
--------+-------------
      10|           10
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   1|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
(10 rows)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)


starting permutation: LockChunk1 C1 IB Iu1 UnlockChunk Cc Ic SC1 SA SChunkStat
step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;
 <waiting ...>
step IB: BEGIN;
step Iu1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 98) ON CONFLICT(time, device) DO UPDATE SET value = 98; 
 <waiting ...>
step UnlockChunk: ROLLBACK;
step C1: <... completed>
compress
--------
t       
(1 row)

step Cc: COMMIT;
step Iu1: <... completed>
step Ic: COMMIT;
step SC1: SELECT (count_chunktable(ch)).* FROM show_chunks('ts_device_table') AS ch LIMIT 1;
count(*)|count(*) only
--------+-------------
      10|           10
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
   1|     1|     100|   98
(10 rows)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)


starting permutation: LockChunk1 C1 IBRR Iu1 UnlockChunk Cc Ic SC1 SA SChunkStat
step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;
 <waiting ...>
step IBRR: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step Iu1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 98) ON CONFLICT(time, device) DO UPDATE SET value = 98; 
 <waiting ...>
step UnlockChunk: ROLLBACK;
step C1: <... completed>
compress
--------
t       
(1 row)

step Cc: COMMIT;
step Iu1: <... completed>
step Ic: COMMIT;
step SC1: SELECT (count_chunktable(ch)).* FROM show_chunks('ts_device_table') AS ch LIMIT 1;
count(*)|count(*) only
--------+-------------
      10|           10
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
   1|     1|     100|   98
(10 rows)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)


starting permutation: LockChunk1 C1 IBS Iu1 UnlockChunk Cc Ic SC1 SA SChunkStat
step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;
 <waiting ...>
step IBS: BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
step Iu1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 98) ON CONFLICT(time, device) DO UPDATE SET value = 98; 
 <waiting ...>
step UnlockChunk: ROLLBACK;
step C1: <... completed>
compress
--------
t       
(1 row)

step Cc: COMMIT;
step Iu1: <... completed>
step Ic: COMMIT;
step SC1: SELECT (count_chunktable(ch)).* FROM show_chunks('ts_device_table') AS ch LIMIT 1;
count(*)|count(*) only
--------+-------------
      10|           10
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
   1|     1|     100|   98
(10 rows)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)


starting permutation: C1 Cc LockChunkTuple IB I1 IN1 UnlockChunkTuple Ic INc SChunkStat SA
step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

compress
--------
t       
(1 row)

step Cc: COMMIT;
step LockChunkTuple: 
  BEGIN;
  SELECT status as chunk_status from _timescaledb_catalog.chunk
  WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table') FOR UPDATE;

chunk_status
------------
           1
(1 row)

step IB: BEGIN;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 
 <waiting ...>
step IN1: BEGIN; INSERT INTO ts_device_table VALUES (1, 1, 200, 100) ON CONFLICT DO NOTHING; <waiting ...>
step UnlockChunkTuple: ROLLBACK;
step I1: <... completed>
step Ic: COMMIT;
step IN1: <... completed>
ERROR:  duplicate key value violates unique constraint "_hyper_X_X_chunk_device_time_idx"
step INc: COMMIT;
step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   1|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
(10 rows)


starting permutation: C1 Cc LockChunkTuple IBRR I1 IN1 UnlockChunkTuple Ic INc SChunkStat SA
step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

compress
--------
t       
(1 row)

step Cc: COMMIT;
step LockChunkTuple: 
  BEGIN;
  SELECT status as chunk_status from _timescaledb_catalog.chunk
  WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table') FOR UPDATE;

chunk_status
------------
           1
(1 row)

step IBRR: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 
 <waiting ...>
step IN1: BEGIN; INSERT INTO ts_device_table VALUES (1, 1, 200, 100) ON CONFLICT DO NOTHING; <waiting ...>
step UnlockChunkTuple: ROLLBACK;
step I1: <... completed>
step Ic: COMMIT;
step IN1: <... completed>
ERROR:  duplicate key value violates unique constraint "_hyper_X_X_chunk_device_time_idx"
step INc: COMMIT;
step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   1|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
(10 rows)


starting permutation: C1 Cc LockChunkTuple IBS I1 IN1 UnlockChunkTuple Ic INc SChunkStat SA
step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

compress
--------
t       
(1 row)

step Cc: COMMIT;
step LockChunkTuple: 
  BEGIN;
  SELECT status as chunk_status from _timescaledb_catalog.chunk
  WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table') FOR UPDATE;

chunk_status
------------
           1
(1 row)

step IBS: BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 
 <waiting ...>
step IN1: BEGIN; INSERT INTO ts_device_table VALUES (1, 1, 200, 100) ON CONFLICT DO NOTHING; <waiting ...>
step UnlockChunkTuple: ROLLBACK;
step I1: <... completed>
step Ic: COMMIT;
step IN1: <... completed>
ERROR:  duplicate key value violates unique constraint "_hyper_X_X_chunk_device_time_idx"
step INc: COMMIT;
step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   1|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
(10 rows)


starting permutation: C1 Cc LockChunkTuple IB I1 INu1 UnlockChunkTuple Ic INc SChunkStat SU SA
step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

compress
--------
t       
(1 row)

step Cc: COMMIT;
step LockChunkTuple: 
  BEGIN;
  SELECT status as chunk_status from _timescaledb_catalog.chunk
  WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table') FOR UPDATE;

chunk_status
------------
           1
(1 row)

step IB: BEGIN;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 
 <waiting ...>
step INu1: BEGIN; INSERT INTO ts_device_table VALUES (1, 1, 100, 99) ON CONFLICT(time, device) DO UPDATE SET value = 99; <waiting ...>
step UnlockChunkTuple: ROLLBACK;
step I1: <... completed>
step Ic: COMMIT;
step INu1: <... completed>
ERROR:  duplicate key value violates unique constraint "_hyper_X_X_chunk_device_time_idx"
step INc: COMMIT;
step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step SU: SELECT * FROM ts_device_table WHERE value IN (98,99);
time|device|location|value
----+------+--------+-----
(0 rows)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   1|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
(10 rows)


starting permutation: C1 Cc LockChunkTuple IBRR I1 INu1 UnlockChunkTuple Ic INc SChunkStat SA
step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

compress
--------
t       
(1 row)

step Cc: COMMIT;
step LockChunkTuple: 
  BEGIN;
  SELECT status as chunk_status from _timescaledb_catalog.chunk
  WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table') FOR UPDATE;

chunk_status
------------
           1
(1 row)

step IBRR: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 
 <waiting ...>
step INu1: BEGIN; INSERT INTO ts_device_table VALUES (1, 1, 100, 99) ON CONFLICT(time, device) DO UPDATE SET value = 99; <waiting ...>
step UnlockChunkTuple: ROLLBACK;
step I1: <... completed>
step Ic: COMMIT;
step INu1: <... completed>
ERROR:  duplicate key value violates unique constraint "_hyper_X_X_chunk_device_time_idx"
step INc: COMMIT;
step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   1|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
(10 rows)


starting permutation: C1 Cc LockChunkTuple IBS I1 INu1 UnlockChunkTuple Ic INc SChunkStat SA
step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

compress
--------
t       
(1 row)

step Cc: COMMIT;
step LockChunkTuple: 
  BEGIN;
  SELECT status as chunk_status from _timescaledb_catalog.chunk
  WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table') FOR UPDATE;

chunk_status
------------
           1
(1 row)

step IBS: BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 
 <waiting ...>
step INu1: BEGIN; INSERT INTO ts_device_table VALUES (1, 1, 100, 99) ON CONFLICT(time, device) DO UPDATE SET value = 99; <waiting ...>
step UnlockChunkTuple: ROLLBACK;
step I1: <... completed>
step Ic: COMMIT;
step INu1: <... completed>
ERROR:  duplicate key value violates unique constraint "_hyper_X_X_chunk_device_time_idx"
step INc: COMMIT;
step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   1|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
(10 rows)


starting permutation: C1 Cc LockChunkTuple IB Iu1 IN1 UnlockChunkTuple Ic INc SChunkStat SU SA
step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

compress
--------
t       
(1 row)

step Cc: COMMIT;
step LockChunkTuple: 
  BEGIN;
  SELECT status as chunk_status from _timescaledb_catalog.chunk
  WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table') FOR UPDATE;

chunk_status
------------
           1
(1 row)

step IB: BEGIN;
step Iu1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 98) ON CONFLICT(time, device) DO UPDATE SET value = 98; 
 <waiting ...>
step IN1: BEGIN; INSERT INTO ts_device_table VALUES (1, 1, 200, 100) ON CONFLICT DO NOTHING; <waiting ...>
step UnlockChunkTuple: ROLLBACK;
step Iu1: <... completed>
step Ic: COMMIT;
step IN1: <... completed>
ERROR:  duplicate key value violates unique constraint "_hyper_X_X_chunk_device_time_idx"
step INc: COMMIT;
step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step SU: SELECT * FROM ts_device_table WHERE value IN (98,99);
time|device|location|value
----+------+--------+-----
   1|     1|     100|   98
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
   1|     1|     100|   98
(10 rows)


starting permutation: C1 Cc LockChunkTuple IBRR Iu1 IN1 UnlockChunkTuple Ic INc SChunkStat SA
step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

compress
--------
t       
(1 row)

step Cc: COMMIT;
step LockChunkTuple: 
  BEGIN;
  SELECT status as chunk_status from _timescaledb_catalog.chunk
  WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table') FOR UPDATE;

chunk_status
------------
           1
(1 row)

step IBRR: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step Iu1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 98) ON CONFLICT(time, device) DO UPDATE SET value = 98; 
 <waiting ...>
step IN1: BEGIN; INSERT INTO ts_device_table VALUES (1, 1, 200, 100) ON CONFLICT DO NOTHING; <waiting ...>
step UnlockChunkTuple: ROLLBACK;
step Iu1: <... completed>
step Ic: COMMIT;
step IN1: <... completed>
ERROR:  duplicate key value violates unique constraint "_hyper_X_X_chunk_device_time_idx"
step INc: COMMIT;
step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
   1|     1|     100|   98
(10 rows)


starting permutation: C1 Cc LockChunkTuple IBS Iu1 IN1 UnlockChunkTuple Ic INc SChunkStat SA
step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

compress
--------
t       
(1 row)

step Cc: COMMIT;
step LockChunkTuple: 
  BEGIN;
  SELECT status as chunk_status from _timescaledb_catalog.chunk
  WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table') FOR UPDATE;

chunk_status
------------
           1
(1 row)

step IBS: BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
step Iu1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 98) ON CONFLICT(time, device) DO UPDATE SET value = 98; 
 <waiting ...>
step IN1: BEGIN; INSERT INTO ts_device_table VALUES (1, 1, 200, 100) ON CONFLICT DO NOTHING; <waiting ...>
step UnlockChunkTuple: ROLLBACK;
step Iu1: <... completed>
step Ic: COMMIT;
step IN1: <... completed>
ERROR:  duplicate key value violates unique constraint "_hyper_X_X_chunk_device_time_idx"
step INc: COMMIT;
step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
   1|     1|     100|   98
(10 rows)


starting permutation: C1 Cc LockChunkTuple IB Iu1 INu1 UnlockChunkTuple Ic INc SChunkStat SU SA
step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

compress
--------
t       
(1 row)

step Cc: COMMIT;
step LockChunkTuple: 
  BEGIN;
  SELECT status as chunk_status from _timescaledb_catalog.chunk
  WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table') FOR UPDATE;

chunk_status
------------
           1
(1 row)

step IB: BEGIN;
step Iu1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 98) ON CONFLICT(time, device) DO UPDATE SET value = 98; 
 <waiting ...>
step INu1: BEGIN; INSERT INTO ts_device_table VALUES (1, 1, 100, 99) ON CONFLICT(time, device) DO UPDATE SET value = 99; <waiting ...>
step UnlockChunkTuple: ROLLBACK;
step Iu1: <... completed>
step Ic: COMMIT;
step INu1: <... completed>
ERROR:  duplicate key value violates unique constraint "_hyper_X_X_chunk_device_time_idx"
step INc: COMMIT;
step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step SU: SELECT * FROM ts_device_table WHERE value IN (98,99);
time|device|location|value
----+------+--------+-----
   1|     1|     100|   98
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
   1|     1|     100|   98
(10 rows)


starting permutation: C1 Cc LockChunkTuple IBRR Iu1 INu1 UnlockChunkTuple Ic INc SChunkStat SA
step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

compress
--------
t       
(1 row)

step Cc: COMMIT;
step LockChunkTuple: 
  BEGIN;
  SELECT status as chunk_status from _timescaledb_catalog.chunk
  WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table') FOR UPDATE;

chunk_status
------------
           1
(1 row)

step IBRR: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step Iu1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 98) ON CONFLICT(time, device) DO UPDATE SET value = 98; 
 <waiting ...>
step INu1: BEGIN; INSERT INTO ts_device_table VALUES (1, 1, 100, 99) ON CONFLICT(time, device) DO UPDATE SET value = 99; <waiting ...>
step UnlockChunkTuple: ROLLBACK;
step Iu1: <... completed>
step Ic: COMMIT;
step INu1: <... completed>
ERROR:  duplicate key value violates unique constraint "_hyper_X_X_chunk_device_time_idx"
step INc: COMMIT;
step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
   1|     1|     100|   98
(10 rows)


starting permutation: C1 Cc LockChunkTuple IBS Iu1 INu1 UnlockChunkTuple Ic INc SChunkStat SA
step C1: 
  BEGIN;
  SET LOCAL lock_timeout = '500ms';
  SET LOCAL deadlock_timeout = '10ms';
  SELECT
    CASE WHEN compress_chunk(format('%I.%I',ch.schema_name, ch.table_name)) IS NOT NULL THEN true ELSE false END AS compress
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

compress
--------
t       
(1 row)

step Cc: COMMIT;
step LockChunkTuple: 
  BEGIN;
  SELECT status as chunk_status from _timescaledb_catalog.chunk
  WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table') FOR UPDATE;

chunk_status
------------
           1
(1 row)

step IBS: BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
step Iu1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 98) ON CONFLICT(time, device) DO UPDATE SET value = 98; 
 <waiting ...>
step INu1: BEGIN; INSERT INTO ts_device_table VALUES (1, 1, 100, 99) ON CONFLICT(time, device) DO UPDATE SET value = 99; <waiting ...>
step UnlockChunkTuple: ROLLBACK;
step Iu1: <... completed>
step Ic: COMMIT;
step INu1: <... completed>
ERROR:  duplicate key value violates unique constraint "_hyper_X_X_chunk_device_time_idx"
step INc: COMMIT;
step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
   1|     1|     100|   98
(10 rows)


starting permutation: CA1 CAc I1 SChunkStat LockChunk1 RC IB I1 UnlockChunk Ic SH SA SChunkStat
step CA1: 
  BEGIN;
  SELECT
    CASE WHEN compress_chunk(ch) IS NOT NULL THEN true ELSE false END AS compress
  FROM show_chunks('ts_device_table') AS ch
  ORDER BY ch::text;

compress
--------
t       
(1 row)

step CAc: COMMIT;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step RC: 
  DO $$
  DECLARE
    chunk_name text;
  BEGIN
  FOR chunk_name IN
      SELECT ch FROM show_chunks('ts_device_table') ch
       ORDER BY ch::text LIMIT 1
     LOOP
         CALL recompress_chunk(chunk_name);
     END LOOP;
  END;
  $$;
 <waiting ...>
step IB: BEGIN;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 
 <waiting ...>
step UnlockChunk: ROLLBACK;
step RC: <... completed>
step I1: <... completed>
step Ic: COMMIT;
step SH: SELECT total_chunks, number_compressed_chunks from hypertable_compression_stats('ts_device_table');
total_chunks|number_compressed_chunks
------------+------------------------
           1|                       1
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   1|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
(10 rows)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)


starting permutation: CA1 CAc I1 SChunkStat LockChunk1 RC IBRR I1 UnlockChunk Ic SH SA SChunkStat
step CA1: 
  BEGIN;
  SELECT
    CASE WHEN compress_chunk(ch) IS NOT NULL THEN true ELSE false END AS compress
  FROM show_chunks('ts_device_table') AS ch
  ORDER BY ch::text;

compress
--------
t       
(1 row)

step CAc: COMMIT;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step RC: 
  DO $$
  DECLARE
    chunk_name text;
  BEGIN
  FOR chunk_name IN
      SELECT ch FROM show_chunks('ts_device_table') ch
       ORDER BY ch::text LIMIT 1
     LOOP
         CALL recompress_chunk(chunk_name);
     END LOOP;
  END;
  $$;
 <waiting ...>
step IBRR: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 
 <waiting ...>
step UnlockChunk: ROLLBACK;
step RC: <... completed>
step I1: <... completed>
step Ic: COMMIT;
step SH: SELECT total_chunks, number_compressed_chunks from hypertable_compression_stats('ts_device_table');
total_chunks|number_compressed_chunks
------------+------------------------
           1|                       1
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   1|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
(10 rows)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)


starting permutation: CA1 CAc I1 SChunkStat LockChunk1 RC IBS I1 UnlockChunk Ic SH SA SChunkStat
step CA1: 
  BEGIN;
  SELECT
    CASE WHEN compress_chunk(ch) IS NOT NULL THEN true ELSE false END AS compress
  FROM show_chunks('ts_device_table') AS ch
  ORDER BY ch::text;

compress
--------
t       
(1 row)

step CAc: COMMIT;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step RC: 
  DO $$
  DECLARE
    chunk_name text;
  BEGIN
  FOR chunk_name IN
      SELECT ch FROM show_chunks('ts_device_table') ch
       ORDER BY ch::text LIMIT 1
     LOOP
         CALL recompress_chunk(chunk_name);
     END LOOP;
  END;
  $$;
 <waiting ...>
step IBS: BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 
 <waiting ...>
step UnlockChunk: ROLLBACK;
step RC: <... completed>
step I1: <... completed>
step Ic: COMMIT;
step SH: SELECT total_chunks, number_compressed_chunks from hypertable_compression_stats('ts_device_table');
total_chunks|number_compressed_chunks
------------+------------------------
           1|                       1
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   1|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
(10 rows)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)


starting permutation: CA1 CAc I1 SChunkStat LockChunk1 RC IB Iu1 UnlockChunk Ic SH SA SChunkStat
step CA1: 
  BEGIN;
  SELECT
    CASE WHEN compress_chunk(ch) IS NOT NULL THEN true ELSE false END AS compress
  FROM show_chunks('ts_device_table') AS ch
  ORDER BY ch::text;

compress
--------
t       
(1 row)

step CAc: COMMIT;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step RC: 
  DO $$
  DECLARE
    chunk_name text;
  BEGIN
  FOR chunk_name IN
      SELECT ch FROM show_chunks('ts_device_table') ch
       ORDER BY ch::text LIMIT 1
     LOOP
         CALL recompress_chunk(chunk_name);
     END LOOP;
  END;
  $$;
 <waiting ...>
step IB: BEGIN;
step Iu1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 98) ON CONFLICT(time, device) DO UPDATE SET value = 98; 
 <waiting ...>
step UnlockChunk: ROLLBACK;
step RC: <... completed>
step Iu1: <... completed>
step Ic: COMMIT;
step SH: SELECT total_chunks, number_compressed_chunks from hypertable_compression_stats('ts_device_table');
total_chunks|number_compressed_chunks
------------+------------------------
           1|                       1
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
   1|     1|     100|   98
(10 rows)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)


starting permutation: CA1 CAc I1 SChunkStat LockChunk1 RC IBRR Iu1 UnlockChunk Ic SH SA SChunkStat SU
step CA1: 
  BEGIN;
  SELECT
    CASE WHEN compress_chunk(ch) IS NOT NULL THEN true ELSE false END AS compress
  FROM show_chunks('ts_device_table') AS ch
  ORDER BY ch::text;

compress
--------
t       
(1 row)

step CAc: COMMIT;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step RC: 
  DO $$
  DECLARE
    chunk_name text;
  BEGIN
  FOR chunk_name IN
      SELECT ch FROM show_chunks('ts_device_table') ch
       ORDER BY ch::text LIMIT 1
     LOOP
         CALL recompress_chunk(chunk_name);
     END LOOP;
  END;
  $$;
 <waiting ...>
step IBRR: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step Iu1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 98) ON CONFLICT(time, device) DO UPDATE SET value = 98; 
 <waiting ...>
step UnlockChunk: ROLLBACK;
step RC: <... completed>
step Iu1: <... completed>
step Ic: COMMIT;
step SH: SELECT total_chunks, number_compressed_chunks from hypertable_compression_stats('ts_device_table');
total_chunks|number_compressed_chunks
------------+------------------------
           1|                       1
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
   1|     1|     100|   98
(10 rows)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step SU: SELECT * FROM ts_device_table WHERE value IN (98,99);
time|device|location|value
----+------+--------+-----
   1|     1|     100|   98
(1 row)


starting permutation: CA1 CAc I1 SChunkStat LockChunk1 RC IBS Iu1 UnlockChunk Ic SH SA SChunkStat SU
step CA1: 
  BEGIN;
  SELECT
    CASE WHEN compress_chunk(ch) IS NOT NULL THEN true ELSE false END AS compress
  FROM show_chunks('ts_device_table') AS ch
  ORDER BY ch::text;

compress
--------
t       
(1 row)

step CAc: COMMIT;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step RC: 
  DO $$
  DECLARE
    chunk_name text;
  BEGIN
  FOR chunk_name IN
      SELECT ch FROM show_chunks('ts_device_table') ch
       ORDER BY ch::text LIMIT 1
     LOOP
         CALL recompress_chunk(chunk_name);
     END LOOP;
  END;
  $$;
 <waiting ...>
step IBS: BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
step Iu1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 98) ON CONFLICT(time, device) DO UPDATE SET value = 98; 
 <waiting ...>
step UnlockChunk: ROLLBACK;
step RC: <... completed>
step Iu1: <... completed>
step Ic: COMMIT;
step SH: SELECT total_chunks, number_compressed_chunks from hypertable_compression_stats('ts_device_table');
total_chunks|number_compressed_chunks
------------+------------------------
           1|                       1
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
   1|     1|     100|   98
(10 rows)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step SU: SELECT * FROM ts_device_table WHERE value IN (98,99);
time|device|location|value
----+------+--------+-----
   1|     1|     100|   98
(1 row)


starting permutation: CA1 CAc I1 SChunkStat LockChunk1 RC IN1 UnlockChunk INc SH SA SChunkStat
step CA1: 
  BEGIN;
  SELECT
    CASE WHEN compress_chunk(ch) IS NOT NULL THEN true ELSE false END AS compress
  FROM show_chunks('ts_device_table') AS ch
  ORDER BY ch::text;

compress
--------
t       
(1 row)

step CAc: COMMIT;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step RC: 
  DO $$
  DECLARE
    chunk_name text;
  BEGIN
  FOR chunk_name IN
      SELECT ch FROM show_chunks('ts_device_table') ch
       ORDER BY ch::text LIMIT 1
     LOOP
         CALL recompress_chunk(chunk_name);
     END LOOP;
  END;
  $$;
 <waiting ...>
step IN1: BEGIN; INSERT INTO ts_device_table VALUES (1, 1, 200, 100) ON CONFLICT DO NOTHING; <waiting ...>
step UnlockChunk: ROLLBACK;
step RC: <... completed>
step IN1: <... completed>
step INc: COMMIT;
step SH: SELECT total_chunks, number_compressed_chunks from hypertable_compression_stats('ts_device_table');
total_chunks|number_compressed_chunks
------------+------------------------
           1|                       1
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   1|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
(10 rows)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)


starting permutation: CA1 CAc I1 SChunkStat LockChunk1 RC INu1 UnlockChunk INc SH SA SChunkStat SU
step CA1: 
  BEGIN;
  SELECT
    CASE WHEN compress_chunk(ch) IS NOT NULL THEN true ELSE false END AS compress
  FROM show_chunks('ts_device_table') AS ch
  ORDER BY ch::text;

compress
--------
t       
(1 row)

step CAc: COMMIT;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step RC: 
  DO $$
  DECLARE
    chunk_name text;
  BEGIN
  FOR chunk_name IN
      SELECT ch FROM show_chunks('ts_device_table') ch
       ORDER BY ch::text LIMIT 1
     LOOP
         CALL recompress_chunk(chunk_name);
     END LOOP;
  END;
  $$;
 <waiting ...>
step INu1: BEGIN; INSERT INTO ts_device_table VALUES (1, 1, 100, 99) ON CONFLICT(time, device) DO UPDATE SET value = 99; <waiting ...>
step UnlockChunk: ROLLBACK;
step RC: <... completed>
step INu1: <... completed>
step INc: COMMIT;
step SH: SELECT total_chunks, number_compressed_chunks from hypertable_compression_stats('ts_device_table');
total_chunks|number_compressed_chunks
------------+------------------------
           1|                       1
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
   1|     1|     100|   99
(10 rows)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step SU: SELECT * FROM ts_device_table WHERE value IN (98,99);
time|device|location|value
----+------+--------+-----
   1|     1|     100|   99
(1 row)


starting permutation: CA1 CAc I1 SChunkStat LockChunk1 IB I1 RC UnlockChunk Ic SH SA SChunkStat
step CA1: 
  BEGIN;
  SELECT
    CASE WHEN compress_chunk(ch) IS NOT NULL THEN true ELSE false END AS compress
  FROM show_chunks('ts_device_table') AS ch
  ORDER BY ch::text;

compress
--------
t       
(1 row)

step CAc: COMMIT;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step IB: BEGIN;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 
 <waiting ...>
step RC: 
  DO $$
  DECLARE
    chunk_name text;
  BEGIN
  FOR chunk_name IN
      SELECT ch FROM show_chunks('ts_device_table') ch
       ORDER BY ch::text LIMIT 1
     LOOP
         CALL recompress_chunk(chunk_name);
     END LOOP;
  END;
  $$;
 <waiting ...>
step UnlockChunk: ROLLBACK;
step I1: <... completed>
step Ic: COMMIT;
step RC: <... completed>
step SH: SELECT total_chunks, number_compressed_chunks from hypertable_compression_stats('ts_device_table');
total_chunks|number_compressed_chunks
------------+------------------------
           1|                       1
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   1|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
(10 rows)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     1
(1 row)


starting permutation: CA1 CAc I1 SChunkStat LockChunk1 IBRR I1 RC UnlockChunk Ic SH SA SChunkStat
step CA1: 
  BEGIN;
  SELECT
    CASE WHEN compress_chunk(ch) IS NOT NULL THEN true ELSE false END AS compress
  FROM show_chunks('ts_device_table') AS ch
  ORDER BY ch::text;

compress
--------
t       
(1 row)

step CAc: COMMIT;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step IBRR: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 
 <waiting ...>
step RC: 
  DO $$
  DECLARE
    chunk_name text;
  BEGIN
  FOR chunk_name IN
      SELECT ch FROM show_chunks('ts_device_table') ch
       ORDER BY ch::text LIMIT 1
     LOOP
         CALL recompress_chunk(chunk_name);
     END LOOP;
  END;
  $$;
 <waiting ...>
step UnlockChunk: ROLLBACK;
step I1: <... completed>
step Ic: COMMIT;
step RC: <... completed>
step SH: SELECT total_chunks, number_compressed_chunks from hypertable_compression_stats('ts_device_table');
total_chunks|number_compressed_chunks
------------+------------------------
           1|                       1
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   1|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
(10 rows)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     1
(1 row)


starting permutation: CA1 CAc I1 SChunkStat LockChunk1 IBS I1 RC UnlockChunk Ic SH SA SChunkStat
step CA1: 
  BEGIN;
  SELECT
    CASE WHEN compress_chunk(ch) IS NOT NULL THEN true ELSE false END AS compress
  FROM show_chunks('ts_device_table') AS ch
  ORDER BY ch::text;

compress
--------
t       
(1 row)

step CAc: COMMIT;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step IBS: BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 
 <waiting ...>
step RC: 
  DO $$
  DECLARE
    chunk_name text;
  BEGIN
  FOR chunk_name IN
      SELECT ch FROM show_chunks('ts_device_table') ch
       ORDER BY ch::text LIMIT 1
     LOOP
         CALL recompress_chunk(chunk_name);
     END LOOP;
  END;
  $$;
 <waiting ...>
step UnlockChunk: ROLLBACK;
step I1: <... completed>
step Ic: COMMIT;
step RC: <... completed>
step SH: SELECT total_chunks, number_compressed_chunks from hypertable_compression_stats('ts_device_table');
total_chunks|number_compressed_chunks
------------+------------------------
           1|                       1
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   1|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
(10 rows)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     1
(1 row)


starting permutation: CA1 CAc I1 SChunkStat LockChunk1 IB Iu1 RC UnlockChunk Ic SH SA SChunkStat SU
step CA1: 
  BEGIN;
  SELECT
    CASE WHEN compress_chunk(ch) IS NOT NULL THEN true ELSE false END AS compress
  FROM show_chunks('ts_device_table') AS ch
  ORDER BY ch::text;

compress
--------
t       
(1 row)

step CAc: COMMIT;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step IB: BEGIN;
step Iu1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 98) ON CONFLICT(time, device) DO UPDATE SET value = 98; 
 <waiting ...>
step RC: 
  DO $$
  DECLARE
    chunk_name text;
  BEGIN
  FOR chunk_name IN
      SELECT ch FROM show_chunks('ts_device_table') ch
       ORDER BY ch::text LIMIT 1
     LOOP
         CALL recompress_chunk(chunk_name);
     END LOOP;
  END;
  $$;
 <waiting ...>
step UnlockChunk: ROLLBACK;
step Iu1: <... completed>
step Ic: COMMIT;
step RC: <... completed>
step SH: SELECT total_chunks, number_compressed_chunks from hypertable_compression_stats('ts_device_table');
total_chunks|number_compressed_chunks
------------+------------------------
           1|                       1
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   1|     1|     100|   98
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
(10 rows)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     1
(1 row)

step SU: SELECT * FROM ts_device_table WHERE value IN (98,99);
time|device|location|value
----+------+--------+-----
   1|     1|     100|   98
(1 row)


starting permutation: CA1 CAc I1 SChunkStat LockChunk1 IBRR Iu1 RC UnlockChunk Ic SH SA SChunkStat SU
step CA1: 
  BEGIN;
  SELECT
    CASE WHEN compress_chunk(ch) IS NOT NULL THEN true ELSE false END AS compress
  FROM show_chunks('ts_device_table') AS ch
  ORDER BY ch::text;

compress
--------
t       
(1 row)

step CAc: COMMIT;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step IBRR: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step Iu1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 98) ON CONFLICT(time, device) DO UPDATE SET value = 98; 
 <waiting ...>
step RC: 
  DO $$
  DECLARE
    chunk_name text;
  BEGIN
  FOR chunk_name IN
      SELECT ch FROM show_chunks('ts_device_table') ch
       ORDER BY ch::text LIMIT 1
     LOOP
         CALL recompress_chunk(chunk_name);
     END LOOP;
  END;
  $$;
 <waiting ...>
step UnlockChunk: ROLLBACK;
step Iu1: <... completed>
step Ic: COMMIT;
step RC: <... completed>
step SH: SELECT total_chunks, number_compressed_chunks from hypertable_compression_stats('ts_device_table');
total_chunks|number_compressed_chunks
------------+------------------------
           1|                       1
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   1|     1|     100|   98
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
(10 rows)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     1
(1 row)

step SU: SELECT * FROM ts_device_table WHERE value IN (98,99);
time|device|location|value
----+------+--------+-----
   1|     1|     100|   98
(1 row)


starting permutation: CA1 CAc I1 SChunkStat LockChunk1 IBS Iu1 RC UnlockChunk Ic SH SA SChunkStat SU
step CA1: 
  BEGIN;
  SELECT
    CASE WHEN compress_chunk(ch) IS NOT NULL THEN true ELSE false END AS compress
  FROM show_chunks('ts_device_table') AS ch
  ORDER BY ch::text;

compress
--------
t       
(1 row)

step CAc: COMMIT;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step IBS: BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
step Iu1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 98) ON CONFLICT(time, device) DO UPDATE SET value = 98; 
 <waiting ...>
step RC: 
  DO $$
  DECLARE
    chunk_name text;
  BEGIN
  FOR chunk_name IN
      SELECT ch FROM show_chunks('ts_device_table') ch
       ORDER BY ch::text LIMIT 1
     LOOP
         CALL recompress_chunk(chunk_name);
     END LOOP;
  END;
  $$;
 <waiting ...>
step UnlockChunk: ROLLBACK;
step Iu1: <... completed>
step Ic: COMMIT;
step RC: <... completed>
step SH: SELECT total_chunks, number_compressed_chunks from hypertable_compression_stats('ts_device_table');
total_chunks|number_compressed_chunks
------------+------------------------
           1|                       1
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   1|     1|     100|   98
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
(10 rows)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     1
(1 row)

step SU: SELECT * FROM ts_device_table WHERE value IN (98,99);
time|device|location|value
----+------+--------+-----
   1|     1|     100|   98
(1 row)


starting permutation: CA1 CAc I1 SChunkStat LockChunk1 IN1 RC UnlockChunk INc SH SA SChunkStat
step CA1: 
  BEGIN;
  SELECT
    CASE WHEN compress_chunk(ch) IS NOT NULL THEN true ELSE false END AS compress
  FROM show_chunks('ts_device_table') AS ch
  ORDER BY ch::text;

compress
--------
t       
(1 row)

step CAc: COMMIT;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step IN1: BEGIN; INSERT INTO ts_device_table VALUES (1, 1, 200, 100) ON CONFLICT DO NOTHING; <waiting ...>
step RC: 
  DO $$
  DECLARE
    chunk_name text;
  BEGIN
  FOR chunk_name IN
      SELECT ch FROM show_chunks('ts_device_table') ch
       ORDER BY ch::text LIMIT 1
     LOOP
         CALL recompress_chunk(chunk_name);
     END LOOP;
  END;
  $$;
 <waiting ...>
step UnlockChunk: ROLLBACK;
step IN1: <... completed>
step INc: COMMIT;
step RC: <... completed>
step SH: SELECT total_chunks, number_compressed_chunks from hypertable_compression_stats('ts_device_table');
total_chunks|number_compressed_chunks
------------+------------------------
           1|                       1
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   1|     1|     100|   20
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
(10 rows)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     1
(1 row)


starting permutation: CA1 CAc I1 SChunkStat LockChunk1 INu1 RC UnlockChunk INc SH SA SChunkStat SU
step CA1: 
  BEGIN;
  SELECT
    CASE WHEN compress_chunk(ch) IS NOT NULL THEN true ELSE false END AS compress
  FROM show_chunks('ts_device_table') AS ch
  ORDER BY ch::text;

compress
--------
t       
(1 row)

step CAc: COMMIT;
step I1: 
    INSERT INTO ts_device_table VALUES (1, 1, 100, 100) ON CONFLICT DO NOTHING; 

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     9
(1 row)

step LockChunk1: 
  BEGIN;
  SELECT
    lock_chunktable(format('%I.%I',ch.schema_name, ch.table_name))
  FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch
  WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table'
  ORDER BY ch.id LIMIT 1;

lock_chunktable
---------------
               
(1 row)

step INu1: BEGIN; INSERT INTO ts_device_table VALUES (1, 1, 100, 99) ON CONFLICT(time, device) DO UPDATE SET value = 99; <waiting ...>
step RC: 
  DO $$
  DECLARE
    chunk_name text;
  BEGIN
  FOR chunk_name IN
      SELECT ch FROM show_chunks('ts_device_table') ch
       ORDER BY ch::text LIMIT 1
     LOOP
         CALL recompress_chunk(chunk_name);
     END LOOP;
  END;
  $$;
 <waiting ...>
step UnlockChunk: ROLLBACK;
step INu1: <... completed>
step INc: COMMIT;
step RC: <... completed>
step SH: SELECT total_chunks, number_compressed_chunks from hypertable_compression_stats('ts_device_table');
total_chunks|number_compressed_chunks
------------+------------------------
           1|                       1
(1 row)

step SA: SELECT * FROM ts_device_table;
time|device|location|value
----+------+--------+-----
   0|     1|     100|   20
   1|     1|     100|   99
   2|     1|     100|   20
   3|     1|     100|   20
   4|     1|     100|   20
   5|     1|     100|   20
   6|     1|     100|   20
   7|     1|     100|   20
   8|     1|     100|   20
   9|     1|     100|   20
(10 rows)

step SChunkStat: SELECT status from _timescaledb_catalog.chunk
       WHERE id = ( select min(ch.id) FROM _timescaledb_catalog.hypertable ht, _timescaledb_catalog.chunk ch WHERE ch.hypertable_id = ht.id AND ht.table_name like 'ts_device_table');
status
------
     1
(1 row)

step SU: SELECT * FROM ts_device_table WHERE value IN (98,99);
time|device|location|value
----+------+--------+-----
   1|     1|     100|   99
(1 row)

