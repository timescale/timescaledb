-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
\set PREFIX 'EXPLAIN (analyze, costs off, timing off, summary off)'
\set TEST_BASE_NAME cagg_planning
SELECT format('include/%s_load.sql', :'TEST_BASE_NAME') AS "TEST_LOAD_NAME",
    format('include/%s_query.sql', :'TEST_BASE_NAME') AS "TEST_QUERY_NAME",
    format('%s/results/%s_results_baseline.out', :'TEST_OUTPUT_DIR', :'TEST_BASE_NAME') AS "TEST_RESULTS_BASELINE",
    format('%s/results/%s_results_optimized.out', :'TEST_OUTPUT_DIR', :'TEST_BASE_NAME') AS "TEST_RESULTS_OPTIMIZED" \gset
SELECT format('\! diff -u --label Baseline --label Optimized %s %s', :'TEST_RESULTS_BASELINE', :'TEST_RESULTS_OPTIMIZED') AS "DIFF_CMD" \gset
SET timezone TO PST8PDT;
CREATE TABLE metrics(time timestamptz, device text, metric text, value float);
SELECT create_hypertable('metrics', 'time');
NOTICE:  adding not-null constraint to column "time"
  create_hypertable   
----------------------
 (1,public,metrics,t)
(1 row)

-- insert initial data to be in materialized part of cagg
INSERT INTO metrics SELECT '2020-01-01'::timestamptz + format('%s day', i::text)::interval, 'device 1', 'metric 1', i  FROM generate_series(0, 9, 1) g(i);
-- cagg with grouping only by time column
CREATE MATERIALIZED VIEW cagg1 WITH (timescaledb.continuous,timescaledb.materialized_only=false)
AS SELECT time_bucket('3 day', time), avg(value) FROM metrics GROUP BY 1;
NOTICE:  refreshing continuous aggregate "cagg1"
CREATE MATERIALIZED VIEW cagg1_ordered_asc WITH (timescaledb.continuous,timescaledb.materialized_only=false)
AS SELECT time_bucket('3 day', time), avg(value) FROM metrics GROUP BY 1 ORDER BY 1;
NOTICE:  refreshing continuous aggregate "cagg1_ordered_asc"
CREATE MATERIALIZED VIEW cagg1_ordered_desc WITH (timescaledb.continuous,timescaledb.materialized_only=false)
AS SELECT time_bucket('3 day', time), avg(value) FROM metrics GROUP BY 1 ORDER BY 1 DESC;
NOTICE:  refreshing continuous aggregate "cagg1_ordered_desc"
-- cagg with grouping by device and time column
CREATE MATERIALIZED VIEW cagg2 WITH (timescaledb.continuous,timescaledb.materialized_only=false)
AS SELECT device, time_bucket('3 day', time), avg(value) FROM metrics GROUP BY device, 2;
NOTICE:  refreshing continuous aggregate "cagg2"
-- cagg with first/last
CREATE MATERIALIZED VIEW cagg3 WITH (timescaledb.continuous,timescaledb.materialized_only=false)
AS SELECT time_bucket('3 day', time), first(value, time), last(value, time), array_agg(value ORDER BY value) AS array_asc, array_agg(value ORDER BY value DESC) AS array_desc FROM metrics GROUP BY device, 1;
NOTICE:  refreshing continuous aggregate "cagg3"
-- insert more data to be in real-time part of cagg
INSERT INTO metrics SELECT '2020-01-01'::timestamptz + format('%s day', i::text)::interval, 'device 1', 'metric 1', i  FROM generate_series(10, 16, 1) g(i);
\ir :TEST_QUERY_NAME
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
SHOW timescaledb.enable_cagg_sort_pushdown;
 timescaledb.enable_cagg_sort_pushdown 
---------------------------------------
 on
(1 row)

:PREFIX SELECT 'query 01' AS label, * FROM cagg1 ORDER BY time_bucket;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6 loops=1)
   ->  Append (actual rows=6 loops=1)
         ->  Custom Scan (ChunkAppend) on _materialized_hypertable_2 (actual rows=4 loops=1)
               Order: _materialized_hypertable_2.time_bucket
               ->  Index Scan Backward using _hyper_2_4_chunk__materialized_hypertable_2_time_bucket_idx on _hyper_2_4_chunk (actual rows=3 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Index Scan Backward using _hyper_2_5_chunk__materialized_hypertable_2_time_bucket_idx on _hyper_2_5_chunk (actual rows=1 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Finalize GroupAggregate (actual rows=2 loops=1)
               Group Key: (time_bucket('@ 3 days'::interval, metrics."time"))
               ->  Custom Scan (ChunkAppend) on metrics (actual rows=3 loops=1)
                     Order: time_bucket('@ 3 days'::interval, metrics."time")
                     ->  Partial GroupAggregate (actual rows=2 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                           ->  Index Scan Backward using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Partial GroupAggregate (actual rows=1 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                           ->  Index Scan Backward using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(20 rows)

:PREFIX SELECT 'query 02' AS label, * FROM cagg1 ORDER BY time_bucket DESC;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6 loops=1)
   ->  Append (actual rows=6 loops=1)
         ->  Finalize GroupAggregate (actual rows=2 loops=1)
               Group Key: (time_bucket('@ 3 days'::interval, metrics."time"))
               ->  Custom Scan (ChunkAppend) on metrics (actual rows=3 loops=1)
                     Order: time_bucket('@ 3 days'::interval, metrics."time") DESC
                     ->  Partial GroupAggregate (actual rows=1 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                           ->  Index Scan using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Partial GroupAggregate (actual rows=2 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                           ->  Index Scan using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Custom Scan (ChunkAppend) on _materialized_hypertable_2 (actual rows=4 loops=1)
               Order: _materialized_hypertable_2.time_bucket DESC
               ->  Index Scan using _hyper_2_5_chunk__materialized_hypertable_2_time_bucket_idx on _hyper_2_5_chunk (actual rows=1 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Index Scan using _hyper_2_4_chunk__materialized_hypertable_2_time_bucket_idx on _hyper_2_4_chunk (actual rows=3 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(20 rows)

:PREFIX SELECT 'query 03' AS label, * FROM cagg1_ordered_asc ORDER BY time_bucket;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6 loops=1)
   ->  Append (actual rows=6 loops=1)
         ->  Custom Scan (ChunkAppend) on _materialized_hypertable_3 (actual rows=4 loops=1)
               Order: _materialized_hypertable_3.time_bucket
               ->  Index Scan Backward using _hyper_3_6_chunk__materialized_hypertable_3_time_bucket_idx on _hyper_3_6_chunk (actual rows=3 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Index Scan Backward using _hyper_3_7_chunk__materialized_hypertable_3_time_bucket_idx on _hyper_3_7_chunk (actual rows=1 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Finalize GroupAggregate (actual rows=2 loops=1)
               Group Key: (time_bucket('@ 3 days'::interval, metrics."time"))
               ->  Custom Scan (ChunkAppend) on metrics (actual rows=3 loops=1)
                     Order: time_bucket('@ 3 days'::interval, metrics."time")
                     ->  Partial GroupAggregate (actual rows=2 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                           ->  Index Scan Backward using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Partial GroupAggregate (actual rows=1 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                           ->  Index Scan Backward using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(20 rows)

:PREFIX SELECT 'query 04' AS label, * FROM cagg1_ordered_asc ORDER BY time_bucket DESC;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6 loops=1)
   ->  Append (actual rows=6 loops=1)
         ->  Finalize GroupAggregate (actual rows=2 loops=1)
               Group Key: (time_bucket('@ 3 days'::interval, metrics."time"))
               ->  Custom Scan (ChunkAppend) on metrics (actual rows=3 loops=1)
                     Order: time_bucket('@ 3 days'::interval, metrics."time") DESC
                     ->  Partial GroupAggregate (actual rows=1 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                           ->  Index Scan using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Partial GroupAggregate (actual rows=2 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                           ->  Index Scan using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Custom Scan (ChunkAppend) on _materialized_hypertable_3 (actual rows=4 loops=1)
               Order: _materialized_hypertable_3.time_bucket DESC
               ->  Index Scan using _hyper_3_7_chunk__materialized_hypertable_3_time_bucket_idx on _hyper_3_7_chunk (actual rows=1 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Index Scan using _hyper_3_6_chunk__materialized_hypertable_3_time_bucket_idx on _hyper_3_6_chunk (actual rows=3 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(20 rows)

:PREFIX SELECT 'query 05' AS label, * FROM cagg1_ordered_desc ORDER BY time_bucket;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6 loops=1)
   ->  Append (actual rows=6 loops=1)
         ->  Custom Scan (ChunkAppend) on _materialized_hypertable_4 (actual rows=4 loops=1)
               Order: _materialized_hypertable_4.time_bucket
               ->  Index Scan Backward using _hyper_4_9_chunk__materialized_hypertable_4_time_bucket_idx on _hyper_4_9_chunk (actual rows=3 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Index Scan Backward using _hyper_4_8_chunk__materialized_hypertable_4_time_bucket_idx on _hyper_4_8_chunk (actual rows=1 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Finalize GroupAggregate (actual rows=2 loops=1)
               Group Key: (time_bucket('@ 3 days'::interval, metrics."time"))
               ->  Custom Scan (ChunkAppend) on metrics (actual rows=3 loops=1)
                     Order: time_bucket('@ 3 days'::interval, metrics."time")
                     ->  Partial GroupAggregate (actual rows=2 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                           ->  Index Scan Backward using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Partial GroupAggregate (actual rows=1 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                           ->  Index Scan Backward using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(20 rows)

:PREFIX SELECT 'query 06' AS label, * FROM cagg1_ordered_desc ORDER BY time_bucket DESC;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6 loops=1)
   ->  Append (actual rows=6 loops=1)
         ->  Finalize GroupAggregate (actual rows=2 loops=1)
               Group Key: (time_bucket('@ 3 days'::interval, metrics."time"))
               ->  Custom Scan (ChunkAppend) on metrics (actual rows=3 loops=1)
                     Order: time_bucket('@ 3 days'::interval, metrics."time") DESC
                     ->  Partial GroupAggregate (actual rows=1 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                           ->  Index Scan using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Partial GroupAggregate (actual rows=2 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                           ->  Index Scan using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Custom Scan (ChunkAppend) on _materialized_hypertable_4 (actual rows=4 loops=1)
               Order: _materialized_hypertable_4.time_bucket DESC
               ->  Index Scan using _hyper_4_8_chunk__materialized_hypertable_4_time_bucket_idx on _hyper_4_8_chunk (actual rows=1 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Index Scan using _hyper_4_9_chunk__materialized_hypertable_4_time_bucket_idx on _hyper_4_9_chunk (actual rows=3 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(20 rows)

:PREFIX SELECT 'query 07' AS label, * FROM cagg2 ORDER BY time_bucket;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6 loops=1)
   ->  Append (actual rows=6 loops=1)
         ->  Custom Scan (ChunkAppend) on _materialized_hypertable_5 (actual rows=4 loops=1)
               Order: _materialized_hypertable_5.time_bucket
               ->  Index Scan Backward using _hyper_5_10_chunk__materialized_hypertable_5_time_bucket_idx on _hyper_5_10_chunk (actual rows=3 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Index Scan Backward using _hyper_5_11_chunk__materialized_hypertable_5_time_bucket_idx on _hyper_5_11_chunk (actual rows=1 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Sort (actual rows=2 loops=1)
               Sort Key: (time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time"))
               Sort Method: quicksort 
               ->  Finalize HashAggregate (actual rows=2 loops=1)
                     Group Key: (time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")), _hyper_1_3_chunk.device
                     Batches: 1 
                     ->  Append (actual rows=3 loops=1)
                           ->  Partial HashAggregate (actual rows=2 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time"), _hyper_1_3_chunk.device
                                 Batches: 1 
                                 ->  Index Scan using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4 loops=1)
                                       Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                           ->  Partial HashAggregate (actual rows=1 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time"), _hyper_1_14_chunk.device
                                 Batches: 1 
                                 ->  Index Scan using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2 loops=1)
                                       Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(25 rows)

:PREFIX SELECT 'query 08' AS label, * FROM cagg2 ORDER BY time_bucket DESC;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6 loops=1)
   ->  Append (actual rows=6 loops=1)
         ->  Sort (actual rows=2 loops=1)
               Sort Key: (time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")) DESC
               Sort Method: quicksort 
               ->  Finalize HashAggregate (actual rows=2 loops=1)
                     Group Key: (time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")), _hyper_1_14_chunk.device
                     Batches: 1 
                     ->  Append (actual rows=3 loops=1)
                           ->  Partial HashAggregate (actual rows=1 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time"), _hyper_1_14_chunk.device
                                 Batches: 1 
                                 ->  Index Scan using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2 loops=1)
                                       Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                           ->  Partial HashAggregate (actual rows=2 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time"), _hyper_1_3_chunk.device
                                 Batches: 1 
                                 ->  Index Scan using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4 loops=1)
                                       Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Custom Scan (ChunkAppend) on _materialized_hypertable_5 (actual rows=4 loops=1)
               Order: _materialized_hypertable_5.time_bucket DESC
               ->  Index Scan using _hyper_5_11_chunk__materialized_hypertable_5_time_bucket_idx on _hyper_5_11_chunk (actual rows=1 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Index Scan using _hyper_5_10_chunk__materialized_hypertable_5_time_bucket_idx on _hyper_5_10_chunk (actual rows=3 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(25 rows)

:PREFIX SELECT 'query 07' AS label, * FROM cagg3 ORDER BY time_bucket;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6 loops=1)
   ->  Append (actual rows=6 loops=1)
         ->  Custom Scan (ChunkAppend) on _materialized_hypertable_6 (actual rows=4 loops=1)
               Order: _materialized_hypertable_6.time_bucket
               ->  Index Scan Backward using _hyper_6_12_chunk__materialized_hypertable_6_time_bucket_idx on _hyper_6_12_chunk (actual rows=3 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Index Scan Backward using _hyper_6_13_chunk__materialized_hypertable_6_time_bucket_idx on _hyper_6_13_chunk (actual rows=1 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Subquery Scan on "*SELECT* 2" (actual rows=2 loops=1)
               ->  GroupAggregate (actual rows=2 loops=1)
                     Group Key: (time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")), _hyper_1_3_chunk.device
                     ->  Sort (actual rows=6 loops=1)
                           Sort Key: (time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")), _hyper_1_3_chunk.device, _hyper_1_3_chunk.value
                           Sort Method: quicksort 
                           ->  Result (actual rows=6 loops=1)
                                 ->  Append (actual rows=6 loops=1)
                                       ->  Index Scan using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4 loops=1)
                                             Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                                       ->  Index Scan using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2 loops=1)
                                             Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(20 rows)

:PREFIX SELECT 'query 08' AS label, * FROM cagg3 ORDER BY time_bucket DESC;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6 loops=1)
   ->  Append (actual rows=6 loops=1)
         ->  Subquery Scan on "*SELECT* 2" (actual rows=2 loops=1)
               ->  GroupAggregate (actual rows=2 loops=1)
                     Group Key: (time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")), _hyper_1_14_chunk.device
                     ->  Sort (actual rows=6 loops=1)
                           Sort Key: (time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")) DESC, _hyper_1_14_chunk.device, _hyper_1_14_chunk.value
                           Sort Method: quicksort 
                           ->  Result (actual rows=6 loops=1)
                                 ->  Append (actual rows=6 loops=1)
                                       ->  Index Scan using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2 loops=1)
                                             Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                                       ->  Index Scan using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4 loops=1)
                                             Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Custom Scan (ChunkAppend) on _materialized_hypertable_6 (actual rows=4 loops=1)
               Order: _materialized_hypertable_6.time_bucket DESC
               ->  Index Scan using _hyper_6_13_chunk__materialized_hypertable_6_time_bucket_idx on _hyper_6_13_chunk (actual rows=1 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Index Scan using _hyper_6_12_chunk__materialized_hypertable_6_time_bucket_idx on _hyper_6_12_chunk (actual rows=3 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(20 rows)

-- not optimized atm
:PREFIX SELECT 'query 101' AS label, * FROM cagg2 ORDER BY time_bucket::date;
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Sort (actual rows=6 loops=1)
   Sort Key: ((_hyper_5_10_chunk.time_bucket)::date)
   Sort Method: quicksort 
   ->  Result (actual rows=6 loops=1)
         ->  Append (actual rows=6 loops=1)
               ->  Append (actual rows=4 loops=1)
                     ->  Index Scan using _hyper_5_10_chunk__materialized_hypertable_5_time_bucket_idx on _hyper_5_10_chunk (actual rows=3 loops=1)
                           Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Index Scan using _hyper_5_11_chunk__materialized_hypertable_5_time_bucket_idx on _hyper_5_11_chunk (actual rows=1 loops=1)
                           Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Finalize HashAggregate (actual rows=2 loops=1)
                     Group Key: _hyper_1_3_chunk.device, (time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time"))
                     Batches: 1 
                     ->  Append (actual rows=3 loops=1)
                           ->  Partial HashAggregate (actual rows=2 loops=1)
                                 Group Key: _hyper_1_3_chunk.device, time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                                 Batches: 1 
                                 ->  Index Scan using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4 loops=1)
                                       Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                           ->  Partial HashAggregate (actual rows=1 loops=1)
                                 Group Key: _hyper_1_14_chunk.device, time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                                 Batches: 1 
                                 ->  Index Scan using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2 loops=1)
                                       Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(24 rows)

:PREFIX SELECT 'query 102' AS label, * FROM cagg2 ORDER BY time_bucket::date DESC;
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Sort (actual rows=6 loops=1)
   Sort Key: ((_hyper_5_10_chunk.time_bucket)::date) DESC
   Sort Method: quicksort 
   ->  Result (actual rows=6 loops=1)
         ->  Append (actual rows=6 loops=1)
               ->  Append (actual rows=4 loops=1)
                     ->  Index Scan using _hyper_5_10_chunk__materialized_hypertable_5_time_bucket_idx on _hyper_5_10_chunk (actual rows=3 loops=1)
                           Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Index Scan using _hyper_5_11_chunk__materialized_hypertable_5_time_bucket_idx on _hyper_5_11_chunk (actual rows=1 loops=1)
                           Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Finalize HashAggregate (actual rows=2 loops=1)
                     Group Key: _hyper_1_3_chunk.device, (time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time"))
                     Batches: 1 
                     ->  Append (actual rows=3 loops=1)
                           ->  Partial HashAggregate (actual rows=2 loops=1)
                                 Group Key: _hyper_1_3_chunk.device, time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                                 Batches: 1 
                                 ->  Index Scan using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4 loops=1)
                                       Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                           ->  Partial HashAggregate (actual rows=1 loops=1)
                                 Group Key: _hyper_1_14_chunk.device, time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                                 Batches: 1 
                                 ->  Index Scan using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2 loops=1)
                                       Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(24 rows)

\set ECHO none
-- diff baseline and optimized results
:DIFF_CMD
--- Baseline
+++ Optimized
@@ -1,6 +1,6 @@
  timescaledb.enable_cagg_sort_pushdown 
 ---------------------------------------
- off
+ on
 (1 row)
 
   label   |         time_bucket          | avg 
