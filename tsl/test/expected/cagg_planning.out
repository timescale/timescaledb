-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
\set PREFIX 'EXPLAIN (analyze, buffers off, costs off, timing off, summary off)'
\set TEST_BASE_NAME cagg_planning
SELECT
    format('include/%s_query.sql', :'TEST_BASE_NAME') AS "TEST_QUERY_NAME",
    format('%s/results/%s_results_baseline.out', :'TEST_OUTPUT_DIR', :'TEST_BASE_NAME') AS "TEST_RESULTS_BASELINE",
    format('%s/results/%s_results_optimized.out', :'TEST_OUTPUT_DIR', :'TEST_BASE_NAME') AS "TEST_RESULTS_OPTIMIZED" \gset
SELECT format('\! diff -u --label Baseline --label Optimized %s %s', :'TEST_RESULTS_BASELINE', :'TEST_RESULTS_OPTIMIZED') AS "DIFF_CMD" \gset
SET timezone TO PST8PDT;
CREATE TABLE metrics(time timestamptz, device text, metric text, value float);
SELECT create_hypertable('metrics', 'time');
  create_hypertable   
----------------------
 (1,public,metrics,t)
(1 row)

-- insert initial data to be in materialized part of cagg
INSERT INTO metrics SELECT '2020-01-01'::timestamptz + format('%s day', i::text)::interval, 'device 1', 'metric 1', i  FROM generate_series(0, 9, 1) g(i);
-- cagg with grouping only by time column
CREATE MATERIALIZED VIEW cagg1 WITH (timescaledb.continuous,timescaledb.materialized_only=false)
AS SELECT time_bucket('3 day', time), avg(value) FROM metrics GROUP BY 1;
NOTICE:  refreshing continuous aggregate "cagg1"
CREATE MATERIALIZED VIEW cagg1_ordered_asc WITH (timescaledb.continuous,timescaledb.materialized_only=false)
AS SELECT time_bucket('3 day', time), avg(value) FROM metrics GROUP BY 1 ORDER BY 1;
NOTICE:  refreshing continuous aggregate "cagg1_ordered_asc"
CREATE MATERIALIZED VIEW cagg1_ordered_desc WITH (timescaledb.continuous,timescaledb.materialized_only=false)
AS SELECT time_bucket('3 day', time), avg(value) FROM metrics GROUP BY 1 ORDER BY 1 DESC;
NOTICE:  refreshing continuous aggregate "cagg1_ordered_desc"
-- cagg with grouping by device and time column
CREATE MATERIALIZED VIEW cagg2 WITH (timescaledb.continuous,timescaledb.materialized_only=false)
AS SELECT device, time_bucket('3 day', time), avg(value) FROM metrics GROUP BY device, 2;
NOTICE:  refreshing continuous aggregate "cagg2"
-- cagg with first/last
CREATE MATERIALIZED VIEW cagg3 WITH (timescaledb.continuous,timescaledb.materialized_only=false)
AS SELECT time_bucket('3 day', time), first(value, time), last(value, time), array_agg(value ORDER BY value) AS array_asc, array_agg(value ORDER BY value DESC) AS array_desc FROM metrics GROUP BY device, 1;
NOTICE:  refreshing continuous aggregate "cagg3"
-- insert more data to be in real-time part of cagg
INSERT INTO metrics SELECT '2020-01-01'::timestamptz + format('%s day', i::text)::interval, 'device 1', 'metric 1', i  FROM generate_series(10, 16, 1) g(i);
\ir :TEST_QUERY_NAME
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
SHOW timescaledb.enable_cagg_sort_pushdown;
 timescaledb.enable_cagg_sort_pushdown 
---------------------------------------
 on
(1 row)

:PREFIX SELECT 'query 01' AS label, * FROM cagg1 ORDER BY time_bucket;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6.00 loops=1)
   ->  Append (actual rows=6.00 loops=1)
         ->  Custom Scan (ChunkAppend) on _materialized_hypertable_2 (actual rows=4.00 loops=1)
               Order: _materialized_hypertable_2.time_bucket
               ->  Index Scan Backward using _hyper_2_4_chunk__materialized_hypertable_2_time_bucket_idx on _hyper_2_4_chunk (actual rows=3.00 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Index Scan Backward using _hyper_2_5_chunk__materialized_hypertable_2_time_bucket_idx on _hyper_2_5_chunk (actual rows=1.00 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Finalize GroupAggregate (actual rows=2.00 loops=1)
               Group Key: (time_bucket('@ 3 days'::interval, metrics."time"))
               ->  Custom Scan (ChunkAppend) on metrics (actual rows=3.00 loops=1)
                     Order: time_bucket('@ 3 days'::interval, metrics."time")
                     ->  Partial GroupAggregate (actual rows=2.00 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                           ->  Index Scan Backward using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Partial GroupAggregate (actual rows=1.00 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                           ->  Index Scan Backward using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(20 rows)

:PREFIX SELECT 'query 02' AS label, * FROM cagg1 ORDER BY time_bucket DESC;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6.00 loops=1)
   ->  Append (actual rows=6.00 loops=1)
         ->  Finalize GroupAggregate (actual rows=2.00 loops=1)
               Group Key: (time_bucket('@ 3 days'::interval, metrics."time"))
               ->  Custom Scan (ChunkAppend) on metrics (actual rows=3.00 loops=1)
                     Order: time_bucket('@ 3 days'::interval, metrics."time") DESC
                     ->  Partial GroupAggregate (actual rows=1.00 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                           ->  Index Scan using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Partial GroupAggregate (actual rows=2.00 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                           ->  Index Scan using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Custom Scan (ChunkAppend) on _materialized_hypertable_2 (actual rows=4.00 loops=1)
               Order: _materialized_hypertable_2.time_bucket DESC
               ->  Index Scan using _hyper_2_5_chunk__materialized_hypertable_2_time_bucket_idx on _hyper_2_5_chunk (actual rows=1.00 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Index Scan using _hyper_2_4_chunk__materialized_hypertable_2_time_bucket_idx on _hyper_2_4_chunk (actual rows=3.00 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(20 rows)

:PREFIX SELECT 'query 03' AS label, * FROM cagg1_ordered_asc ORDER BY time_bucket;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6.00 loops=1)
   ->  Append (actual rows=6.00 loops=1)
         ->  Custom Scan (ChunkAppend) on _materialized_hypertable_3 (actual rows=4.00 loops=1)
               Order: _materialized_hypertable_3.time_bucket
               ->  Index Scan Backward using _hyper_3_6_chunk__materialized_hypertable_3_time_bucket_idx on _hyper_3_6_chunk (actual rows=3.00 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Index Scan Backward using _hyper_3_7_chunk__materialized_hypertable_3_time_bucket_idx on _hyper_3_7_chunk (actual rows=1.00 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Finalize GroupAggregate (actual rows=2.00 loops=1)
               Group Key: (time_bucket('@ 3 days'::interval, metrics."time"))
               ->  Custom Scan (ChunkAppend) on metrics (actual rows=3.00 loops=1)
                     Order: time_bucket('@ 3 days'::interval, metrics."time")
                     ->  Partial GroupAggregate (actual rows=2.00 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                           ->  Index Scan Backward using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Partial GroupAggregate (actual rows=1.00 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                           ->  Index Scan Backward using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(20 rows)

:PREFIX SELECT 'query 04' AS label, * FROM cagg1_ordered_asc ORDER BY time_bucket DESC;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6.00 loops=1)
   ->  Append (actual rows=6.00 loops=1)
         ->  Finalize GroupAggregate (actual rows=2.00 loops=1)
               Group Key: (time_bucket('@ 3 days'::interval, metrics."time"))
               ->  Custom Scan (ChunkAppend) on metrics (actual rows=3.00 loops=1)
                     Order: time_bucket('@ 3 days'::interval, metrics."time") DESC
                     ->  Partial GroupAggregate (actual rows=1.00 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                           ->  Index Scan using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Partial GroupAggregate (actual rows=2.00 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                           ->  Index Scan using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Custom Scan (ChunkAppend) on _materialized_hypertable_3 (actual rows=4.00 loops=1)
               Order: _materialized_hypertable_3.time_bucket DESC
               ->  Index Scan using _hyper_3_7_chunk__materialized_hypertable_3_time_bucket_idx on _hyper_3_7_chunk (actual rows=1.00 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Index Scan using _hyper_3_6_chunk__materialized_hypertable_3_time_bucket_idx on _hyper_3_6_chunk (actual rows=3.00 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(20 rows)

:PREFIX SELECT 'query 05' AS label, * FROM cagg1_ordered_desc ORDER BY time_bucket;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6.00 loops=1)
   ->  Append (actual rows=6.00 loops=1)
         ->  Custom Scan (ChunkAppend) on _materialized_hypertable_4 (actual rows=4.00 loops=1)
               Order: _materialized_hypertable_4.time_bucket
               ->  Index Scan Backward using _hyper_4_9_chunk__materialized_hypertable_4_time_bucket_idx on _hyper_4_9_chunk (actual rows=3.00 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Index Scan Backward using _hyper_4_8_chunk__materialized_hypertable_4_time_bucket_idx on _hyper_4_8_chunk (actual rows=1.00 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Finalize GroupAggregate (actual rows=2.00 loops=1)
               Group Key: (time_bucket('@ 3 days'::interval, metrics."time"))
               ->  Custom Scan (ChunkAppend) on metrics (actual rows=3.00 loops=1)
                     Order: time_bucket('@ 3 days'::interval, metrics."time")
                     ->  Partial GroupAggregate (actual rows=2.00 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                           ->  Index Scan Backward using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Partial GroupAggregate (actual rows=1.00 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                           ->  Index Scan Backward using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(20 rows)

:PREFIX SELECT 'query 06' AS label, * FROM cagg1_ordered_desc ORDER BY time_bucket DESC;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6.00 loops=1)
   ->  Append (actual rows=6.00 loops=1)
         ->  Finalize GroupAggregate (actual rows=2.00 loops=1)
               Group Key: (time_bucket('@ 3 days'::interval, metrics."time"))
               ->  Custom Scan (ChunkAppend) on metrics (actual rows=3.00 loops=1)
                     Order: time_bucket('@ 3 days'::interval, metrics."time") DESC
                     ->  Partial GroupAggregate (actual rows=1.00 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                           ->  Index Scan using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Partial GroupAggregate (actual rows=2.00 loops=1)
                           Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                           ->  Index Scan using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                 Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Custom Scan (ChunkAppend) on _materialized_hypertable_4 (actual rows=4.00 loops=1)
               Order: _materialized_hypertable_4.time_bucket DESC
               ->  Index Scan using _hyper_4_8_chunk__materialized_hypertable_4_time_bucket_idx on _hyper_4_8_chunk (actual rows=1.00 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Index Scan using _hyper_4_9_chunk__materialized_hypertable_4_time_bucket_idx on _hyper_4_9_chunk (actual rows=3.00 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(20 rows)

:PREFIX SELECT 'query 07' AS label, * FROM cagg2 ORDER BY time_bucket;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6.00 loops=1)
   ->  Append (actual rows=6.00 loops=1)
         ->  Custom Scan (ChunkAppend) on _materialized_hypertable_5 (actual rows=4.00 loops=1)
               Order: _materialized_hypertable_5.time_bucket
               ->  Index Scan Backward using _hyper_5_10_chunk__materialized_hypertable_5_time_bucket_idx on _hyper_5_10_chunk (actual rows=3.00 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Index Scan Backward using _hyper_5_11_chunk__materialized_hypertable_5_time_bucket_idx on _hyper_5_11_chunk (actual rows=1.00 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Sort (actual rows=2.00 loops=1)
               Sort Key: (time_bucket('@ 3 days'::interval, metrics."time"))
               Sort Method: quicksort 
               ->  Finalize HashAggregate (actual rows=2.00 loops=1)
                     Group Key: (time_bucket('@ 3 days'::interval, metrics."time")), metrics.device
                     ->  Append (actual rows=3.00 loops=1)
                           ->  Partial HashAggregate (actual rows=2.00 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time"), _hyper_1_3_chunk.device
                                 ->  Index Scan using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                       Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                           ->  Partial HashAggregate (actual rows=1.00 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time"), _hyper_1_14_chunk.device
                                 ->  Index Scan using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                       Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(25 rows)

:PREFIX SELECT 'query 08' AS label, * FROM cagg2 ORDER BY time_bucket DESC;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6.00 loops=1)
   ->  Append (actual rows=6.00 loops=1)
         ->  Sort (actual rows=2.00 loops=1)
               Sort Key: (time_bucket('@ 3 days'::interval, metrics."time")) DESC
               Sort Method: quicksort 
               ->  Finalize HashAggregate (actual rows=2.00 loops=1)
                     Group Key: (time_bucket('@ 3 days'::interval, metrics."time")), metrics.device
                     ->  Append (actual rows=3.00 loops=1)
                           ->  Partial HashAggregate (actual rows=1.00 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time"), _hyper_1_14_chunk.device
                                 ->  Index Scan using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                       Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                           ->  Partial HashAggregate (actual rows=2.00 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time"), _hyper_1_3_chunk.device
                                 ->  Index Scan using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                       Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Custom Scan (ChunkAppend) on _materialized_hypertable_5 (actual rows=4.00 loops=1)
               Order: _materialized_hypertable_5.time_bucket DESC
               ->  Index Scan using _hyper_5_11_chunk__materialized_hypertable_5_time_bucket_idx on _hyper_5_11_chunk (actual rows=1.00 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Index Scan using _hyper_5_10_chunk__materialized_hypertable_5_time_bucket_idx on _hyper_5_10_chunk (actual rows=3.00 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(25 rows)

:PREFIX SELECT 'query 07' AS label, * FROM cagg3 ORDER BY time_bucket;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6.00 loops=1)
   ->  Append (actual rows=6.00 loops=1)
         ->  Custom Scan (ChunkAppend) on _materialized_hypertable_6 (actual rows=4.00 loops=1)
               Order: _materialized_hypertable_6.time_bucket
               ->  Index Scan Backward using _hyper_6_12_chunk__materialized_hypertable_6_time_bucket_idx on _hyper_6_12_chunk (actual rows=3.00 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Index Scan Backward using _hyper_6_13_chunk__materialized_hypertable_6_time_bucket_idx on _hyper_6_13_chunk (actual rows=1.00 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Subquery Scan on "*SELECT* 2" (actual rows=2.00 loops=1)
               ->  GroupAggregate (actual rows=2.00 loops=1)
                     Group Key: (time_bucket('@ 3 days'::interval, metrics."time")), metrics.device
                     ->  Sort (actual rows=6.00 loops=1)
                           Sort Key: (time_bucket('@ 3 days'::interval, metrics."time")), metrics.device, metrics.value
                           Sort Method: quicksort 
                           ->  Result (actual rows=6.00 loops=1)
                                 ->  Append (actual rows=6.00 loops=1)
                                       ->  Index Scan using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                             Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                                       ->  Index Scan using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                             Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(20 rows)

:PREFIX SELECT 'query 08' AS label, * FROM cagg3 ORDER BY time_bucket DESC;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6.00 loops=1)
   ->  Append (actual rows=6.00 loops=1)
         ->  Subquery Scan on "*SELECT* 2" (actual rows=2.00 loops=1)
               ->  GroupAggregate (actual rows=2.00 loops=1)
                     Group Key: (time_bucket('@ 3 days'::interval, metrics."time")), metrics.device
                     ->  Sort (actual rows=6.00 loops=1)
                           Sort Key: (time_bucket('@ 3 days'::interval, metrics."time")) DESC, metrics.device, metrics.value
                           Sort Method: quicksort 
                           ->  Result (actual rows=6.00 loops=1)
                                 ->  Append (actual rows=6.00 loops=1)
                                       ->  Index Scan using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                             Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                                       ->  Index Scan using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                             Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Custom Scan (ChunkAppend) on _materialized_hypertable_6 (actual rows=4.00 loops=1)
               Order: _materialized_hypertable_6.time_bucket DESC
               ->  Index Scan using _hyper_6_13_chunk__materialized_hypertable_6_time_bucket_idx on _hyper_6_13_chunk (actual rows=1.00 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Index Scan using _hyper_6_12_chunk__materialized_hypertable_6_time_bucket_idx on _hyper_6_12_chunk (actual rows=3.00 loops=1)
                     Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(20 rows)

-- not optimized atm
:PREFIX SELECT 'query 101' AS label, * FROM cagg2 ORDER BY time_bucket::date;
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Sort (actual rows=6.00 loops=1)
   Sort Key: ((_materialized_hypertable_5.time_bucket)::date)
   Sort Method: quicksort 
   ->  Result (actual rows=6.00 loops=1)
         ->  Append (actual rows=6.00 loops=1)
               ->  Append (actual rows=4.00 loops=1)
                     ->  Index Scan using _hyper_5_10_chunk__materialized_hypertable_5_time_bucket_idx on _hyper_5_10_chunk (actual rows=3.00 loops=1)
                           Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Index Scan using _hyper_5_11_chunk__materialized_hypertable_5_time_bucket_idx on _hyper_5_11_chunk (actual rows=1.00 loops=1)
                           Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Finalize HashAggregate (actual rows=2.00 loops=1)
                     Group Key: metrics.device, (time_bucket('@ 3 days'::interval, metrics."time"))
                     ->  Append (actual rows=3.00 loops=1)
                           ->  Partial HashAggregate (actual rows=2.00 loops=1)
                                 Group Key: _hyper_1_3_chunk.device, time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                                 ->  Index Scan using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                       Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                           ->  Partial HashAggregate (actual rows=1.00 loops=1)
                                 Group Key: _hyper_1_14_chunk.device, time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                                 ->  Index Scan using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                       Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(24 rows)

:PREFIX SELECT 'query 102' AS label, * FROM cagg2 ORDER BY time_bucket::date DESC;
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Sort (actual rows=6.00 loops=1)
   Sort Key: ((_materialized_hypertable_5.time_bucket)::date) DESC
   Sort Method: quicksort 
   ->  Result (actual rows=6.00 loops=1)
         ->  Append (actual rows=6.00 loops=1)
               ->  Append (actual rows=4.00 loops=1)
                     ->  Index Scan using _hyper_5_10_chunk__materialized_hypertable_5_time_bucket_idx on _hyper_5_10_chunk (actual rows=3.00 loops=1)
                           Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Index Scan using _hyper_5_11_chunk__materialized_hypertable_5_time_bucket_idx on _hyper_5_11_chunk (actual rows=1.00 loops=1)
                           Index Cond: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Finalize HashAggregate (actual rows=2.00 loops=1)
                     Group Key: metrics.device, (time_bucket('@ 3 days'::interval, metrics."time"))
                     ->  Append (actual rows=3.00 loops=1)
                           ->  Partial HashAggregate (actual rows=2.00 loops=1)
                                 Group Key: _hyper_1_3_chunk.device, time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                                 ->  Index Scan using _hyper_1_3_chunk_metrics_time_idx on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                       Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                           ->  Partial HashAggregate (actual rows=1.00 loops=1)
                                 Group Key: _hyper_1_14_chunk.device, time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                                 ->  Index Scan using _hyper_1_14_chunk_metrics_time_idx on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                       Index Cond: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(24 rows)

\set ECHO none
-- diff baseline and optimized results
:DIFF_CMD
--- Baseline
+++ Optimized
@@ -1,6 +1,6 @@
  timescaledb.enable_cagg_sort_pushdown 
 ---------------------------------------
- off
+ on
 (1 row)
 
   label   |         time_bucket          | avg 
--dump & restore
\c postgres :ROLE_SUPERUSER
\! utils/pg_dump_aux_dump.sh dump/pg_dump.sql
\c :TEST_DBNAME
SET client_min_messages = ERROR;
CREATE EXTENSION timescaledb CASCADE;
RESET client_min_messages;
SELECT timescaledb_pre_restore();
 timescaledb_pre_restore 
-------------------------
 t
(1 row)

\! utils/pg_dump_aux_restore.sh dump/pg_dump.sql
SELECT timescaledb_post_restore();
 timescaledb_post_restore 
--------------------------
 t
(1 row)

SELECT _timescaledb_functions.stop_background_workers();
 stop_background_workers 
-------------------------
 t
(1 row)

-- Repeat tests after restore
\c :TEST_DBNAME :ROLE_DEFAULT_PERM_USER
\set PREFIX 'EXPLAIN (analyze, buffers off, costs off, timing off, summary off)'
\set TEST_BASE_NAME cagg_planning
SELECT
    format('include/%s_query.sql', :'TEST_BASE_NAME') AS "TEST_QUERY_NAME",
    format('%s/results/%s_results_baseline_after_restore.out', :'TEST_OUTPUT_DIR', :'TEST_BASE_NAME') AS "TEST_RESULTS_BASELINE_AFTER_RESTORE",
    format('%s/results/%s_results_optimized_after_restore.out', :'TEST_OUTPUT_DIR', :'TEST_BASE_NAME') AS "TEST_RESULTS_OPTIMIZED_AFTER_RESTORE" \gset
SELECT format('\! diff -u --label Baseline --label Optimized %s %s', :'TEST_RESULTS_BASELINE_AFTER_RESTORE', :'TEST_RESULTS_OPTIMIZED_AFTER_RESTORE') AS "DIFF_CMD" \gset
SET timezone TO PST8PDT;
\ir :TEST_QUERY_NAME
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
SHOW timescaledb.enable_cagg_sort_pushdown;
 timescaledb.enable_cagg_sort_pushdown 
---------------------------------------
 on
(1 row)

:PREFIX SELECT 'query 01' AS label, * FROM cagg1 ORDER BY time_bucket;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6.00 loops=1)
   ->  Append (actual rows=6.00 loops=1)
         ->  Sort (actual rows=4.00 loops=1)
               Sort Key: _materialized_hypertable_2.time_bucket
               Sort Method: quicksort 
               ->  Append (actual rows=4.00 loops=1)
                     ->  Seq Scan on _hyper_2_4_chunk (actual rows=3.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Seq Scan on _hyper_2_5_chunk (actual rows=1.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Sort (actual rows=2.00 loops=1)
               Sort Key: (time_bucket('@ 3 days'::interval, metrics."time"))
               Sort Method: quicksort 
               ->  Finalize HashAggregate (actual rows=2.00 loops=1)
                     Group Key: (time_bucket('@ 3 days'::interval, metrics."time"))
                     ->  Append (actual rows=3.00 loops=1)
                           ->  Partial HashAggregate (actual rows=2.00 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                                 ->  Seq Scan on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                       Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                                       Rows Removed by Filter: 3
                           ->  Partial HashAggregate (actual rows=1.00 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                                 ->  Seq Scan on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                       Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(28 rows)

:PREFIX SELECT 'query 02' AS label, * FROM cagg1 ORDER BY time_bucket DESC;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6.00 loops=1)
   ->  Append (actual rows=6.00 loops=1)
         ->  Sort (actual rows=2.00 loops=1)
               Sort Key: (time_bucket('@ 3 days'::interval, metrics."time")) DESC
               Sort Method: quicksort 
               ->  Finalize HashAggregate (actual rows=2.00 loops=1)
                     Group Key: (time_bucket('@ 3 days'::interval, metrics."time"))
                     ->  Append (actual rows=3.00 loops=1)
                           ->  Partial HashAggregate (actual rows=1.00 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                                 ->  Seq Scan on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                       Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                           ->  Partial HashAggregate (actual rows=2.00 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                                 ->  Seq Scan on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                       Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                                       Rows Removed by Filter: 3
         ->  Sort (actual rows=4.00 loops=1)
               Sort Key: _materialized_hypertable_2.time_bucket DESC
               Sort Method: quicksort 
               ->  Append (actual rows=4.00 loops=1)
                     ->  Seq Scan on _hyper_2_5_chunk (actual rows=1.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Seq Scan on _hyper_2_4_chunk (actual rows=3.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(28 rows)

:PREFIX SELECT 'query 03' AS label, * FROM cagg1_ordered_asc ORDER BY time_bucket;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6.00 loops=1)
   ->  Append (actual rows=6.00 loops=1)
         ->  Sort (actual rows=4.00 loops=1)
               Sort Key: _materialized_hypertable_3.time_bucket
               Sort Method: quicksort 
               ->  Append (actual rows=4.00 loops=1)
                     ->  Seq Scan on _hyper_3_6_chunk (actual rows=3.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Seq Scan on _hyper_3_7_chunk (actual rows=1.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Sort (actual rows=2.00 loops=1)
               Sort Key: (time_bucket('@ 3 days'::interval, metrics."time"))
               Sort Method: quicksort 
               ->  Finalize HashAggregate (actual rows=2.00 loops=1)
                     Group Key: (time_bucket('@ 3 days'::interval, metrics."time"))
                     ->  Append (actual rows=3.00 loops=1)
                           ->  Partial HashAggregate (actual rows=2.00 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                                 ->  Seq Scan on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                       Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                                       Rows Removed by Filter: 3
                           ->  Partial HashAggregate (actual rows=1.00 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                                 ->  Seq Scan on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                       Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(28 rows)

:PREFIX SELECT 'query 04' AS label, * FROM cagg1_ordered_asc ORDER BY time_bucket DESC;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6.00 loops=1)
   ->  Append (actual rows=6.00 loops=1)
         ->  Sort (actual rows=2.00 loops=1)
               Sort Key: (time_bucket('@ 3 days'::interval, metrics."time")) DESC
               Sort Method: quicksort 
               ->  Finalize HashAggregate (actual rows=2.00 loops=1)
                     Group Key: (time_bucket('@ 3 days'::interval, metrics."time"))
                     ->  Append (actual rows=3.00 loops=1)
                           ->  Partial HashAggregate (actual rows=1.00 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                                 ->  Seq Scan on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                       Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                           ->  Partial HashAggregate (actual rows=2.00 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                                 ->  Seq Scan on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                       Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                                       Rows Removed by Filter: 3
         ->  Sort (actual rows=4.00 loops=1)
               Sort Key: _materialized_hypertable_3.time_bucket DESC
               Sort Method: quicksort 
               ->  Append (actual rows=4.00 loops=1)
                     ->  Seq Scan on _hyper_3_7_chunk (actual rows=1.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Seq Scan on _hyper_3_6_chunk (actual rows=3.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(28 rows)

:PREFIX SELECT 'query 05' AS label, * FROM cagg1_ordered_desc ORDER BY time_bucket;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6.00 loops=1)
   ->  Append (actual rows=6.00 loops=1)
         ->  Sort (actual rows=4.00 loops=1)
               Sort Key: _materialized_hypertable_4.time_bucket
               Sort Method: quicksort 
               ->  Append (actual rows=4.00 loops=1)
                     ->  Seq Scan on _hyper_4_9_chunk (actual rows=3.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Seq Scan on _hyper_4_8_chunk (actual rows=1.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Sort (actual rows=2.00 loops=1)
               Sort Key: (time_bucket('@ 3 days'::interval, metrics."time"))
               Sort Method: quicksort 
               ->  Finalize HashAggregate (actual rows=2.00 loops=1)
                     Group Key: (time_bucket('@ 3 days'::interval, metrics."time"))
                     ->  Append (actual rows=3.00 loops=1)
                           ->  Partial HashAggregate (actual rows=2.00 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                                 ->  Seq Scan on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                       Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                                       Rows Removed by Filter: 3
                           ->  Partial HashAggregate (actual rows=1.00 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                                 ->  Seq Scan on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                       Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(28 rows)

:PREFIX SELECT 'query 06' AS label, * FROM cagg1_ordered_desc ORDER BY time_bucket DESC;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6.00 loops=1)
   ->  Append (actual rows=6.00 loops=1)
         ->  Sort (actual rows=2.00 loops=1)
               Sort Key: (time_bucket('@ 3 days'::interval, metrics."time")) DESC
               Sort Method: quicksort 
               ->  Finalize HashAggregate (actual rows=2.00 loops=1)
                     Group Key: (time_bucket('@ 3 days'::interval, metrics."time"))
                     ->  Append (actual rows=3.00 loops=1)
                           ->  Partial HashAggregate (actual rows=1.00 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                                 ->  Seq Scan on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                       Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                           ->  Partial HashAggregate (actual rows=2.00 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                                 ->  Seq Scan on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                       Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                                       Rows Removed by Filter: 3
         ->  Sort (actual rows=4.00 loops=1)
               Sort Key: _materialized_hypertable_4.time_bucket DESC
               Sort Method: quicksort 
               ->  Append (actual rows=4.00 loops=1)
                     ->  Seq Scan on _hyper_4_8_chunk (actual rows=1.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Seq Scan on _hyper_4_9_chunk (actual rows=3.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(28 rows)

:PREFIX SELECT 'query 07' AS label, * FROM cagg2 ORDER BY time_bucket;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6.00 loops=1)
   ->  Append (actual rows=6.00 loops=1)
         ->  Sort (actual rows=4.00 loops=1)
               Sort Key: _materialized_hypertable_5.time_bucket
               Sort Method: quicksort 
               ->  Append (actual rows=4.00 loops=1)
                     ->  Seq Scan on _hyper_5_10_chunk (actual rows=3.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Seq Scan on _hyper_5_11_chunk (actual rows=1.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Sort (actual rows=2.00 loops=1)
               Sort Key: (time_bucket('@ 3 days'::interval, metrics."time"))
               Sort Method: quicksort 
               ->  Finalize HashAggregate (actual rows=2.00 loops=1)
                     Group Key: (time_bucket('@ 3 days'::interval, metrics."time")), metrics.device
                     ->  Append (actual rows=3.00 loops=1)
                           ->  Partial HashAggregate (actual rows=2.00 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time"), _hyper_1_3_chunk.device
                                 ->  Seq Scan on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                       Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                                       Rows Removed by Filter: 3
                           ->  Partial HashAggregate (actual rows=1.00 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time"), _hyper_1_14_chunk.device
                                 ->  Seq Scan on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                       Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(28 rows)

:PREFIX SELECT 'query 08' AS label, * FROM cagg2 ORDER BY time_bucket DESC;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6.00 loops=1)
   ->  Append (actual rows=6.00 loops=1)
         ->  Sort (actual rows=2.00 loops=1)
               Sort Key: (time_bucket('@ 3 days'::interval, metrics."time")) DESC
               Sort Method: quicksort 
               ->  Finalize HashAggregate (actual rows=2.00 loops=1)
                     Group Key: (time_bucket('@ 3 days'::interval, metrics."time")), metrics.device
                     ->  Append (actual rows=3.00 loops=1)
                           ->  Partial HashAggregate (actual rows=1.00 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time"), _hyper_1_14_chunk.device
                                 ->  Seq Scan on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                       Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                           ->  Partial HashAggregate (actual rows=2.00 loops=1)
                                 Group Key: time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time"), _hyper_1_3_chunk.device
                                 ->  Seq Scan on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                       Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                                       Rows Removed by Filter: 3
         ->  Sort (actual rows=4.00 loops=1)
               Sort Key: _materialized_hypertable_5.time_bucket DESC
               Sort Method: quicksort 
               ->  Append (actual rows=4.00 loops=1)
                     ->  Seq Scan on _hyper_5_11_chunk (actual rows=1.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Seq Scan on _hyper_5_10_chunk (actual rows=3.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(28 rows)

:PREFIX SELECT 'query 07' AS label, * FROM cagg3 ORDER BY time_bucket;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6.00 loops=1)
   ->  Append (actual rows=6.00 loops=1)
         ->  Sort (actual rows=4.00 loops=1)
               Sort Key: _materialized_hypertable_6.time_bucket
               Sort Method: quicksort 
               ->  Append (actual rows=4.00 loops=1)
                     ->  Seq Scan on _hyper_6_12_chunk (actual rows=3.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Seq Scan on _hyper_6_13_chunk (actual rows=1.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
         ->  Subquery Scan on "*SELECT* 2" (actual rows=2.00 loops=1)
               ->  GroupAggregate (actual rows=2.00 loops=1)
                     Group Key: (time_bucket('@ 3 days'::interval, metrics."time")), metrics.device
                     ->  Sort (actual rows=6.00 loops=1)
                           Sort Key: (time_bucket('@ 3 days'::interval, metrics."time")), metrics.device, metrics.value
                           Sort Method: quicksort 
                           ->  Result (actual rows=6.00 loops=1)
                                 ->  Append (actual rows=6.00 loops=1)
                                       ->  Seq Scan on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                             Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                                             Rows Removed by Filter: 3
                                       ->  Seq Scan on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                             Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(23 rows)

:PREFIX SELECT 'query 08' AS label, * FROM cagg3 ORDER BY time_bucket DESC;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=6.00 loops=1)
   ->  Append (actual rows=6.00 loops=1)
         ->  Subquery Scan on "*SELECT* 2" (actual rows=2.00 loops=1)
               ->  GroupAggregate (actual rows=2.00 loops=1)
                     Group Key: (time_bucket('@ 3 days'::interval, metrics."time")), metrics.device
                     ->  Sort (actual rows=6.00 loops=1)
                           Sort Key: (time_bucket('@ 3 days'::interval, metrics."time")) DESC, metrics.device, metrics.value
                           Sort Method: quicksort 
                           ->  Result (actual rows=6.00 loops=1)
                                 ->  Append (actual rows=6.00 loops=1)
                                       ->  Seq Scan on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                             Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                                       ->  Seq Scan on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                             Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                                             Rows Removed by Filter: 3
         ->  Sort (actual rows=4.00 loops=1)
               Sort Key: _materialized_hypertable_6.time_bucket DESC
               Sort Method: quicksort 
               ->  Append (actual rows=4.00 loops=1)
                     ->  Seq Scan on _hyper_6_13_chunk (actual rows=1.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Seq Scan on _hyper_6_12_chunk (actual rows=3.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
(23 rows)

-- not optimized atm
:PREFIX SELECT 'query 101' AS label, * FROM cagg2 ORDER BY time_bucket::date;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Sort (actual rows=6.00 loops=1)
   Sort Key: ((_materialized_hypertable_5.time_bucket)::date)
   Sort Method: quicksort 
   ->  Result (actual rows=6.00 loops=1)
         ->  Append (actual rows=6.00 loops=1)
               ->  Append (actual rows=4.00 loops=1)
                     ->  Seq Scan on _hyper_5_10_chunk (actual rows=3.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Seq Scan on _hyper_5_11_chunk (actual rows=1.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Finalize HashAggregate (actual rows=2.00 loops=1)
                     Group Key: metrics.device, (time_bucket('@ 3 days'::interval, metrics."time"))
                     ->  Append (actual rows=3.00 loops=1)
                           ->  Partial HashAggregate (actual rows=1.00 loops=1)
                                 Group Key: _hyper_1_14_chunk.device, time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                                 ->  Seq Scan on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                       Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                           ->  Partial HashAggregate (actual rows=2.00 loops=1)
                                 Group Key: _hyper_1_3_chunk.device, time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                                 ->  Seq Scan on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                       Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                                       Rows Removed by Filter: 3
(25 rows)

:PREFIX SELECT 'query 102' AS label, * FROM cagg2 ORDER BY time_bucket::date DESC;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Sort (actual rows=6.00 loops=1)
   Sort Key: ((_materialized_hypertable_5.time_bucket)::date) DESC
   Sort Method: quicksort 
   ->  Result (actual rows=6.00 loops=1)
         ->  Append (actual rows=6.00 loops=1)
               ->  Append (actual rows=4.00 loops=1)
                     ->  Seq Scan on _hyper_5_10_chunk (actual rows=3.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                     ->  Seq Scan on _hyper_5_11_chunk (actual rows=1.00 loops=1)
                           Filter: (time_bucket < 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
               ->  Finalize HashAggregate (actual rows=2.00 loops=1)
                     Group Key: metrics.device, (time_bucket('@ 3 days'::interval, metrics."time"))
                     ->  Append (actual rows=3.00 loops=1)
                           ->  Partial HashAggregate (actual rows=1.00 loops=1)
                                 Group Key: _hyper_1_14_chunk.device, time_bucket('@ 3 days'::interval, _hyper_1_14_chunk."time")
                                 ->  Seq Scan on _hyper_1_14_chunk (actual rows=2.00 loops=1)
                                       Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                           ->  Partial HashAggregate (actual rows=2.00 loops=1)
                                 Group Key: _hyper_1_3_chunk.device, time_bucket('@ 3 days'::interval, _hyper_1_3_chunk."time")
                                 ->  Seq Scan on _hyper_1_3_chunk (actual rows=4.00 loops=1)
                                       Filter: ("time" >= 'Sat Jan 11 16:00:00 2020 PST'::timestamp with time zone)
                                       Rows Removed by Filter: 3
(25 rows)

\set ECHO none
-- diff baseline and optimized results
:DIFF_CMD
--- Baseline
+++ Optimized
@@ -1,6 +1,6 @@
  timescaledb.enable_cagg_sort_pushdown 
 ---------------------------------------
- off
+ on
 (1 row)
 
   label   |         time_bucket          | avg 
-- diff baseline before and after restore
SELECT format('\! diff -u --label Baseline --label Baseline_After_Restore %s %s', :'TEST_RESULTS_BASELINE', :'TEST_RESULTS_BASELINE_AFTER_RESTORE') AS "DIFF_CMD" \gset
:DIFF_CMD
-- diff optimized before and after restore
SELECT format('\! diff -u --label Optimized --label Optimized_After_Restore %s %s', :'TEST_RESULTS_OPTIMIZED', :'TEST_RESULTS_OPTIMIZED_AFTER_RESTORE') AS "DIFF_CMD" \gset
:DIFF_CMD
