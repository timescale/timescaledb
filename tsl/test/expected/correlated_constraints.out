-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
\set PREFIX 'EXPLAIN (costs off, timing off, summary off)'
CREATE OR REPLACE VIEW compressed_chunk_info_view AS
SELECT
   h.schema_name AS hypertable_schema,
   h.table_name AS hypertable_name,
   c.schema_name || '.' || c.table_name as chunk_name,
   c.status as chunk_status
FROM
   _timescaledb_catalog.hypertable h JOIN
  _timescaledb_catalog.chunk c ON h.id = c.hypertable_id
   LEFT JOIN _timescaledb_catalog.chunk comp
ON comp.id = c.compressed_chunk_id
;
CREATE TABLE sample_table (
       time TIMESTAMP WITH TIME ZONE NOT NULL,
       sensor_id INTEGER NOT NULL,
       cpu double precision null,
       temperature double precision null,
       name varchar(100) default 'this is a default string value'
);
SELECT * FROM create_hypertable('sample_table', 'time',
       chunk_time_interval => INTERVAL '2 months');
WARNING:  column type "character varying" used for "name" does not follow best practices
 hypertable_id | schema_name |  table_name  | created 
---------------+-------------+--------------+---------
             1 | public      | sample_table | t
(1 row)

\set start_date '2022-01-28 01:09:53.583252+05:30'
INSERT INTO sample_table
    SELECT
       	time + (INTERVAL '1 minute' * random()) AS time,
       		sensor_id,
       		random() AS cpu,
       		random()* 100 AS temperature
       	FROM
       		generate_series(:'start_date'::timestamptz - INTERVAL '1 months',
                            :'start_date'::timestamptz - INTERVAL '1 week',
                            INTERVAL '1 hour') AS g1(time),
       		generate_series(1, 8, 1 ) AS g2(sensor_id)
       	ORDER BY
       		time;
\set start_date '2023-03-17 17:51:11.322998+05:30'
-- insert into new chunks
INSERT INTO sample_table VALUES (:'start_date'::timestamptz, 12, 21.98, 33.123, 'new row1');
INSERT INTO sample_table VALUES (:'start_date'::timestamptz, 12, 17.66, 13.875, 'new row1');
INSERT INTO sample_table VALUES (:'start_date'::timestamptz, 13, 21.98, 33.123, 'new row2');
INSERT INTO sample_table VALUES (:'start_date'::timestamptz, 9, 21.98, 33.123, 'new row2');
INSERT INTO sample_table VALUES (:'start_date'::timestamptz, 14, 21.98, 33.123, 'new row2');
INSERT INTO sample_table VALUES (:'start_date'::timestamptz, 15, 0.988, 33.123, 'new row3');
INSERT INTO sample_table VALUES (:'start_date'::timestamptz, 16, 4.6554, 47, 'new row3');
-- Non-int, date, timestamp cannot be specified as a correlated constraint for now
-- We could expand to FLOATs, NUMERICs later
\set ON_ERROR_STOP 0
SELECT * FROM add_dimension('sample_table', by_correlation('name'));
ERROR:  invalid type for dimension "name"
\set ON_ERROR_STOP 1
-- Specify a correlated constraint
SELECT * FROM add_dimension('sample_table', by_correlation('sensor_id'));
 dimension_id | created 
--------------+---------
            2 | t
(1 row)

-- The above should add a dimension_slice entry with MIN/MAX int64 entries and all
-- existing chunks will point to this to indicate that there is no chunk exclusion
-- yet if this correlated constraint column is used in WHERE clauses
SELECT id AS dimension_id FROM _timescaledb_catalog.dimension WHERE type = 'r' \gset
-- should show MIN_INT/MAX_INT entries
SELECT * FROM _timescaledb_catalog.dimension WHERE type = 'r' AND id = :dimension_id;
 id | hypertable_id | column_name | column_type | aligned | num_slices | partitioning_func_schema | partitioning_func | interval_length | compress_interval_length | integer_now_func_schema | integer_now_func | type 
----+---------------+-------------+-------------+---------+------------+--------------------------+-------------------+-----------------+--------------------------+-------------------------+------------------+------
  2 |             1 | sensor_id   | integer     | t       |            |                          |                   |               1 |                          |                         |                  | r
(1 row)

SELECT id AS slice_id FROM _timescaledb_catalog.dimension_slice WHERE dimension_id = :dimension_id \gset
SELECT * FROM _timescaledb_catalog.chunk_constraint WHERE dimension_slice_id = :slice_id ORDER BY chunk_id;
 chunk_id | dimension_slice_id |  constraint_name  | hypertable_constraint_name 
----------+--------------------+-------------------+----------------------------
        1 |                  3 | _$CC_constraint_3 | 
        2 |                  3 | _$CC_constraint_3 | 
(2 rows)

-- A query using a WHERE clause on "sensor_id" column will scan all the chunks
:PREFIX SELECT * FROM sample_table WHERE sensor_id > 9;
             QUERY PLAN             
------------------------------------
 Append
   ->  Seq Scan on _hyper_1_1_chunk
         Filter: (sensor_id > 9)
   ->  Seq Scan on _hyper_1_2_chunk
         Filter: (sensor_id > 9)
(5 rows)

-- For the purposes of correlated constraints, a compressed chunk is considered as a
-- completed chunk.
-- enable compression
ALTER TABLE sample_table SET (
	timescaledb.compress,
    timescaledb.compress_orderby = 'time'
);
WARNING:  there was some uncertainty picking the default segment by for the hypertable: You do not have any indexes on columns that can be used for segment_by and thus we are not using segment_by for compression. Please make sure you are not missing any indexes
NOTICE:  default segment by for hypertable "sample_table" is set to ""
--
-- compress one chunk
SELECT show_chunks('sample_table') AS "CH_NAME" order by 1 limit 1 \gset
SELECT compress_chunk(:'CH_NAME');
             compress_chunk             
----------------------------------------
 _timescaledb_internal._hyper_1_1_chunk
(1 row)

-- There should be an entry with min/max range computed for this chunk for this
-- "sensor_id" column
SELECT * FROM _timescaledb_catalog.dimension_slice WHERE dimension_id = :dimension_id;
 id | dimension_id |     range_start      |      range_end      
----+--------------+----------------------+---------------------
  3 |            2 | -9223372036854775808 | 9223372036854775807
  4 |            2 |                    1 |                   9
(2 rows)

SELECT * FROM _timescaledb_catalog.chunk_constraint WHERE constraint_name LIKE '_$CC_con%' ORDER BY chunk_id;
 chunk_id | dimension_slice_id |  constraint_name  | hypertable_constraint_name 
----------+--------------------+-------------------+----------------------------
        1 |                  4 | _$CC_constraint_4 | 
        2 |                  3 | _$CC_constraint_3 | 
(2 rows)

-- check chunk compression status
SELECT chunk_status
FROM compressed_chunk_info_view
WHERE hypertable_name = 'sample_table' AND chunk_name = :'CH_NAME';
 chunk_status 
--------------
            1
(1 row)

-- A query using a WHERE clause on "sensor_id" column will scan the proper chunk
-- due to chunk exclusion using correlated constraints ranges calculated above
:PREFIX SELECT * FROM sample_table WHERE sensor_id > 9;
          QUERY PLAN          
------------------------------
 Seq Scan on _hyper_1_2_chunk
   Filter: (sensor_id > 9)
(2 rows)

-- do update, this will change the status of the chunk
UPDATE sample_table SET name = 'updated row' WHERE cpu = 21.98 AND temperature = 33.123;
-- check chunk compression status
SELECT chunk_status
FROM compressed_chunk_info_view
WHERE hypertable_name = 'sample_table' AND chunk_name = :'CH_NAME';
 chunk_status 
--------------
            9
(1 row)

-- The chunk_constraint should point to the MIN_INT/MAX_INT entry now
SELECT * FROM _timescaledb_catalog.chunk_constraint WHERE constraint_name LIKE '_$CC_con%' ORDER BY chunk_id;
 chunk_id | dimension_slice_id |  constraint_name  | hypertable_constraint_name 
----------+--------------------+-------------------+----------------------------
        1 |                  3 | _$CC_constraint_3 | 
        2 |                  3 | _$CC_constraint_3 | 
(2 rows)

-- A query using a WHERE clause on "sensor_id" column will go back to scanning all the chunks
-- along with an expensive DECOMPRESS on the first chunk
:PREFIX SELECT * FROM sample_table WHERE sensor_id > 9;
                       QUERY PLAN                        
---------------------------------------------------------
 Append
   ->  Custom Scan (DecompressChunk) on _hyper_1_1_chunk
         Vectorized Filter: (sensor_id > 9)
         ->  Seq Scan on compress_hyper_2_3_chunk
   ->  Seq Scan on _hyper_1_1_chunk
         Filter: (sensor_id > 9)
   ->  Seq Scan on _hyper_1_2_chunk
         Filter: (sensor_id > 9)
(8 rows)

-- recompress the partial chunk
SELECT compress_chunk(:'CH_NAME');
             compress_chunk             
----------------------------------------
 _timescaledb_internal._hyper_1_1_chunk
(1 row)

-- check chunk compression status
SELECT chunk_status
FROM compressed_chunk_info_view
WHERE hypertable_name = 'sample_table' AND chunk_name = :'CH_NAME';
 chunk_status 
--------------
            1
(1 row)

-- There should be an entry with min/max range computed for this chunk
SELECT * FROM _timescaledb_catalog.dimension_slice WHERE dimension_id = :dimension_id;
 id | dimension_id |     range_start      |      range_end      
----+--------------+----------------------+---------------------
  3 |            2 | -9223372036854775808 | 9223372036854775807
  4 |            2 |                    1 |                   9
(2 rows)

SELECT * FROM _timescaledb_catalog.chunk_constraint WHERE constraint_name LIKE '_$CC_con%' ORDER BY chunk_id;
 chunk_id | dimension_slice_id |  constraint_name  | hypertable_constraint_name 
----------+--------------------+-------------------+----------------------------
        1 |                  4 | _$CC_constraint_4 | 
        2 |                  3 | _$CC_constraint_3 | 
(2 rows)

-- A query using a WHERE clause on "sensor_id" column will scan the proper chunk
-- due to chunk exclusion using correlated constraints ranges calculated above
:PREFIX SELECT * FROM sample_table WHERE sensor_id > 9;
          QUERY PLAN          
------------------------------
 Seq Scan on _hyper_1_2_chunk
   Filter: (sensor_id > 9)
(2 rows)

-- Newly added chunks should also point to this MIN/MAX entry
\set start_date '2024-01-28 01:09:51.583252+05:30'
INSERT INTO sample_table VALUES (:'start_date'::timestamptz, 1, 9.6054, 78.999, 'new row4');
SELECT * FROM _timescaledb_catalog.chunk_constraint WHERE dimension_slice_id = :slice_id ORDER BY chunk_id;
 chunk_id | dimension_slice_id |  constraint_name  | hypertable_constraint_name 
----------+--------------------+-------------------+----------------------------
        2 |                  3 | _$CC_constraint_3 | 
        5 |                  3 | _$CC_constraint_3 | 
(2 rows)

-- use the remove_dimension API to remove the correlated dimension entries
SELECT dimension_id AS dim_id from remove_dimension('sample_table', 'sensor_id') \gset
SELECT * FROM _timescaledb_catalog.dimension_slice WHERE dimension_id = :dim_id;
 id | dimension_id | range_start | range_end 
----+--------------+-------------+-----------
(0 rows)

SELECT * FROM _timescaledb_catalog.dimension WHERE id = :dim_id;
 id | hypertable_id | column_name | column_type | aligned | num_slices | partitioning_func_schema | partitioning_func | interval_length | compress_interval_length | integer_now_func_schema | integer_now_func | type 
----+---------------+-------------+-------------+---------+------------+--------------------------+-------------------+-----------------+--------------------------+-------------------------+------------------+------
(0 rows)

SELECT * FROM _timescaledb_catalog.dimension WHERE type = 'r';
 id | hypertable_id | column_name | column_type | aligned | num_slices | partitioning_func_schema | partitioning_func | interval_length | compress_interval_length | integer_now_func_schema | integer_now_func | type 
----+---------------+-------------+-------------+---------+------------+--------------------------+-------------------+-----------------+--------------------------+-------------------------+------------------+------
(0 rows)

SELECT * from remove_dimension('sample_table', 'sensor_id', true);
NOTICE:  no correlated dimension on column "sensor_id", skipping
 dimension_id | dropped 
--------------+---------
            0 | f
(1 row)

\set ON_ERROR_STOP 0
SELECT * from remove_dimension('sample_table', 'sensor_id');
ERROR:  no correlated dimension on column "sensor_id"
-- should only work on correlated dimensions
SELECT * from remove_dimension('sample_table', 'time');
ERROR:  no correlated dimension on column "time"
SELECT * from remove_dimension('sample_table', 'cpu');
ERROR:  no correlated dimension on column "cpu"
\set ON_ERROR_STOP 1
-- Check that a DROP COLUMN removes entries from catalogs as well
SELECT * FROM add_dimension('sample_table', by_correlation('sensor_id'));
 dimension_id | created 
--------------+---------
            3 | t
(1 row)

SELECT id AS dimension_id FROM _timescaledb_catalog.dimension WHERE type = 'r' \gset
ALTER TABLE sample_table DROP COLUMN sensor_id;
SELECT * FROM _timescaledb_catalog.dimension WHERE type = 'r';
 id | hypertable_id | column_name | column_type | aligned | num_slices | partitioning_func_schema | partitioning_func | interval_length | compress_interval_length | integer_now_func_schema | integer_now_func | type 
----+---------------+-------------+-------------+---------+------------+--------------------------+-------------------+-----------------+--------------------------+-------------------------+------------------+------
(0 rows)

SELECT * FROM _timescaledb_catalog.dimension_slice WHERE dimension_id = :dimension_id;
 id | dimension_id | range_start | range_end 
----+--------------+-------------+-----------
(0 rows)

DROP TABLE sample_table;
