-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- Need to be super user to create extension and add servers
\c :TEST_DBNAME :ROLE_SUPERUSER;
-- Need explicit password for non-super users to connect
ALTER ROLE :ROLE_DEFAULT_CLUSTER_USER CREATEDB PASSWORD 'pass';
GRANT USAGE ON FOREIGN DATA WRAPPER timescaledb_fdw TO :ROLE_DEFAULT_CLUSTER_USER;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- Cleanup from other potential tests that created these databases
SET client_min_messages TO ERROR;
DROP DATABASE IF EXISTS server_1;
DROP DATABASE IF EXISTS server_2;
DROP DATABASE IF EXISTS server_3;
SET client_min_messages TO NOTICE;
CREATE DATABASE server_1;
CREATE DATABASE server_2;
CREATE DATABASE server_3;
-- Add servers using the TimescaleDB server management API
SELECT * FROM add_server('server_1', database => 'server_1', password => 'pass');
 server_name |   host    | port  | database |       username       |   server_username    | created 
-------------+-----------+-------+----------+----------------------+----------------------+---------
 server_1    | localhost | 15432 | server_1 | default_cluster_user | default_cluster_user | t
(1 row)

SELECT * FROM add_server('server_2', database => 'server_2', password => 'pass');
 server_name |   host    | port  | database |       username       |   server_username    | created 
-------------+-----------+-------+----------+----------------------+----------------------+---------
 server_2    | localhost | 15432 | server_2 | default_cluster_user | default_cluster_user | t
(1 row)

SELECT * FROM add_server('server_3', database => 'server_3', port => inet_server_port(), password => 'pass');
 server_name |   host    | port  | database |       username       |   server_username    | created 
-------------+-----------+-------+----------+----------------------+----------------------+---------
 server_3    | localhost | 15432 | server_3 | default_cluster_user | default_cluster_user | t
(1 row)

-- Create distributed hypertables. Add a trigger and primary key
-- constraint to test how those work
CREATE TABLE disttable(time timestamptz PRIMARY KEY, device int CHECK (device > 0), color int, temp float);
SELECT * FROM create_hypertable('disttable', 'time', replication_factor => 1);
 hypertable_id | schema_name | table_name | created 
---------------+-------------+------------+---------
             1 | public      | disttable  | t
(1 row)

-- An underreplicated table that will has a replication_factor > num_servers
CREATE TABLE underreplicated(time timestamptz, device int, temp float);
SELECT * FROM create_hypertable('underreplicated', 'time', replication_factor => 4);
NOTICE:  adding not-null constraint to column "time"
 hypertable_id | schema_name |   table_name    | created 
---------------+-------------+-----------------+---------
             2 | public      | underreplicated | t
(1 row)

-- Create tables on remote servers
\c server_1
SET client_min_messages TO ERROR;
CREATE EXTENSION timescaledb;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
CREATE TABLE disttable(time timestamptz PRIMARY KEY, device int CHECK (device > 0), color int, temp float);
SELECT * FROM create_hypertable('disttable', 'time');
 hypertable_id | schema_name | table_name | created 
---------------+-------------+------------+---------
             1 | public      | disttable  | t
(1 row)

CREATE TABLE underreplicated(time timestamptz, device int, temp float);
SELECT * FROM create_hypertable('underreplicated', 'time');
 hypertable_id | schema_name |   table_name    | created 
---------------+-------------+-----------------+---------
             2 | public      | underreplicated | t
(1 row)

\c server_2
SET client_min_messages TO ERROR;
CREATE EXTENSION timescaledb;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
CREATE TABLE disttable(time timestamptz PRIMARY KEY, device int CHECK (device > 0), color int, temp float);
SELECT * FROM create_hypertable('disttable', 'time');
 hypertable_id | schema_name | table_name | created 
---------------+-------------+------------+---------
             1 | public      | disttable  | t
(1 row)

CREATE TABLE underreplicated(time timestamptz, device int, temp float);
SELECT * FROM create_hypertable('underreplicated', 'time');
 hypertable_id | schema_name |   table_name    | created 
---------------+-------------+-----------------+---------
             2 | public      | underreplicated | t
(1 row)

\c server_3
SET client_min_messages TO ERROR;
CREATE EXTENSION timescaledb;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
CREATE TABLE disttable(time timestamptz PRIMARY KEY, device int CHECK (device > 0), color int, temp float);
SELECT * FROM create_hypertable('disttable', 'time');
 hypertable_id | schema_name | table_name | created 
---------------+-------------+------------+---------
             1 | public      | disttable  | t
(1 row)

CREATE TABLE underreplicated(time timestamptz, device int, temp float);
SELECT * FROM create_hypertable('underreplicated', 'time');
 hypertable_id | schema_name |   table_name    | created 
---------------+-------------+-----------------+---------
             2 | public      | underreplicated | t
(1 row)

\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
CREATE OR REPLACE FUNCTION test_trigger()
    RETURNS TRIGGER LANGUAGE PLPGSQL AS
$BODY$
DECLARE
    cnt INTEGER;
BEGIN
    SELECT count(*) INTO cnt FROM hyper;
    RAISE WARNING 'FIRING trigger when: % level: % op: % cnt: % trigger_name %',
        tg_when, tg_level, tg_op, cnt, tg_name;

    IF TG_OP = 'DELETE' THEN
        RETURN OLD;
    END IF;
    RETURN NEW;
END
$BODY$;
CREATE TRIGGER _0_test_trigger_insert
    BEFORE INSERT ON disttable
    FOR EACH ROW EXECUTE PROCEDURE test_trigger();
SELECT * FROM _timescaledb_catalog.hypertable_server;
 hypertable_id | server_hypertable_id | server_name 
---------------+----------------------+-------------
             1 |                      | server_1
             1 |                      | server_2
             1 |                      | server_3
             2 |                      | server_1
             2 |                      | server_2
             2 |                      | server_3
(6 rows)

SELECT * FROM _timescaledb_catalog.chunk_server;
 chunk_id | server_chunk_id | server_name 
----------+-----------------+-------------
(0 rows)

-- The constraints, indexes, and triggers on the hypertable
SELECT * FROM test.show_constraints('disttable');
       Constraint       | Type | Columns  |     Index      |     Expr     | Deferrable | Deferred | Validated 
------------------------+------+----------+----------------+--------------+------------+----------+-----------
 disttable_device_check | c    | {device} | -              | (device > 0) | f          | f        | t
 disttable_pkey         | p    | {time}   | disttable_pkey |              | f          | f        | t
(2 rows)

SELECT * FROM test.show_indexes('disttable');
     Index      | Columns | Expr | Unique | Primary | Exclusion | Tablespace 
----------------+---------+------+--------+---------+-----------+------------
 disttable_pkey | {time}  |      | t      | t       | f         | 
(1 row)

SELECT * FROM test.show_triggers('disttable');
        Trigger         | Type |               Function               |                                                     Definition                                                      
------------------------+------+--------------------------------------+---------------------------------------------------------------------------------------------------------------------
 _0_test_trigger_insert |    7 | test_trigger                         |  _0_test_trigger_insert BEFORE INSERT ON disttable FOR EACH ROW EXECUTE PROCEDURE test_trigger()
 ts_insert_blocker      |    7 | _timescaledb_internal.insert_blocker |  ts_insert_blocker BEFORE INSERT ON disttable FOR EACH ROW EXECUTE PROCEDURE _timescaledb_internal.insert_blocker()
(2 rows)

-- Drop a column. This will make the attribute numbers of the
-- hypertable's root relation differ from newly created chunks. It is
-- a way to test that we properly handle attributed conversion between
-- the root table and chunks
ALTER TABLE disttable DROP COLUMN color;
-- Currently no distributed DDL support, so need to manually drop
-- column on datanodes
\c server_1
ALTER TABLE disttable DROP COLUMN color;
\c server_2
ALTER TABLE disttable DROP COLUMN color;
\c server_3
ALTER TABLE disttable DROP COLUMN color;
\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- EXPLAIN some inserts to see what plans and explain output for
-- remote inserts look like
EXPLAIN
INSERT INTO disttable VALUES
       ('2017-01-01 06:01', 1, 1.1);
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Custom Scan (HypertableInsert)  (cost=0.00..0.01 rows=1 width=24)
 Insert on distributed hypertable disttable
   ->  Insert on disttable  (cost=0.00..0.01 rows=1 width=24)
         ->  Custom Scan (ChunkDispatch)  (cost=0.00..0.01 rows=1 width=24)
               ->  Result  (cost=0.00..0.01 rows=1 width=24)
(5 rows)

EXPLAIN VERBOSE
INSERT INTO disttable VALUES
       ('2017-01-01 06:01', 1, 1.1);
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (HypertableInsert)  (cost=0.00..0.01 rows=1 width=24)
 Insert on distributed hypertable public.disttable
   Servers: server_1, server_2, server_3
   Remote SQL: INSERT INTO public.disttable("time", device, temp) VALUES ($1, $2, $3)
   ->  Insert on public.disttable  (cost=0.00..0.01 rows=1 width=24)
         ->  Custom Scan (ChunkDispatch)  (cost=0.00..0.01 rows=1 width=24)
               Output: 'Sun Jan 01 06:01:00 2017 PST'::timestamp with time zone, 1, NULL::integer, '1.1'::double precision
               ->  Result  (cost=0.00..0.01 rows=1 width=24)
                     Output: 'Sun Jan 01 06:01:00 2017 PST'::timestamp with time zone, 1, NULL::integer, '1.1'::double precision
(9 rows)

-- Create some chunks through insertion
INSERT INTO disttable VALUES
       ('2017-01-01 06:01', 1, 1.1),
       ('2017-01-01 08:01', 1, 1.2),
       ('2018-01-02 08:01', 2, 1.3),
       ('2019-01-01 09:11', 3, 2.1),
       ('2017-01-01 06:05', 1, 1.4);
-- Show chunks created
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('disttable');
 chunk_id | hypertable_id |      schema_name      |      table_name       | relkind |                     slices                     
----------+---------------+-----------------------+-----------------------+---------+------------------------------------------------
        1 |             1 | _timescaledb_internal | _hyper_1_1_dist_chunk | f       | {"time": [1482969600000000, 1483574400000000]}
        2 |             1 | _timescaledb_internal | _hyper_1_2_dist_chunk | f       | {"time": [1514419200000000, 1515024000000000]}
        3 |             1 | _timescaledb_internal | _hyper_1_3_dist_chunk | f       | {"time": [1545868800000000, 1546473600000000]}
(3 rows)

-- Show that there are assigned server_chunk_id:s in chunk server mappings
SELECT * FROM _timescaledb_catalog.chunk_server;
 chunk_id | server_chunk_id | server_name 
----------+-----------------+-------------
        1 |               1 | server_1
        2 |               1 | server_2
        3 |               1 | server_3
(3 rows)

-- Show that chunks are created on remote servers
\c server_1
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('disttable');
 chunk_id | hypertable_id |      schema_name      |      table_name       | relkind |                     slices                     
----------+---------------+-----------------------+-----------------------+---------+------------------------------------------------
        1 |             1 | _timescaledb_internal | _hyper_1_1_dist_chunk | r       | {"time": [1482969600000000, 1483574400000000]}
(1 row)

SELECT * FROM disttable;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Sun Jan 01 08:01:00 2017 PST |      1 |  1.2
 Sun Jan 01 06:05:00 2017 PST |      1 |  1.4
(3 rows)

\c server_2
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('disttable');
 chunk_id | hypertable_id |      schema_name      |      table_name       | relkind |                     slices                     
----------+---------------+-----------------------+-----------------------+---------+------------------------------------------------
        1 |             1 | _timescaledb_internal | _hyper_1_2_dist_chunk | r       | {"time": [1514419200000000, 1515024000000000]}
(1 row)

SELECT * FROM disttable;
             time             | device | temp 
------------------------------+--------+------
 Tue Jan 02 08:01:00 2018 PST |      2 |  1.3
(1 row)

\c server_3
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('disttable');
 chunk_id | hypertable_id |      schema_name      |      table_name       | relkind |                     slices                     
----------+---------------+-----------------------+-----------------------+---------+------------------------------------------------
        1 |             1 | _timescaledb_internal | _hyper_1_3_dist_chunk | r       | {"time": [1545868800000000, 1546473600000000]}
(1 row)

SELECT * FROM disttable;
             time             | device | temp 
------------------------------+--------+------
 Tue Jan 01 09:11:00 2019 PST |      3 |  2.1
(1 row)

\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- The constraints, indexes, and triggers on foreign chunks. Only
-- check constraints should recurse to foreign chunks (although they
-- aren't enforced on a foreign table)
SELECT st."Child" as chunk_relid, test.show_constraints((st)."Child")
FROM test.show_subtables('disttable') st;
                 chunk_relid                 |                                                                                   show_constraints                                                                                   
---------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 _timescaledb_internal._hyper_1_1_dist_chunk | (constraint_1,c,{time},-,"((""time"" >= 'Wed Dec 28 16:00:00 2016 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 04 16:00:00 2017 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_1_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (constraint_2,c,{time},-,"((""time"" >= 'Wed Dec 27 16:00:00 2017 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 03 16:00:00 2018 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (constraint_3,c,{time},-,"((""time"" >= 'Wed Dec 26 16:00:00 2018 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 02 16:00:00 2019 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
(6 rows)

SELECT st."Child" as chunk_relid, test.show_indexes((st)."Child")
FROM test.show_subtables('disttable') st;
 chunk_relid | show_indexes 
-------------+--------------
(0 rows)

SELECT st."Child" as chunk_relid, test.show_triggers((st)."Child")
FROM test.show_subtables('disttable') st;
 chunk_relid | show_triggers 
-------------+---------------
(0 rows)

-- Check that the chunks are assigned servers
SELECT * FROM _timescaledb_catalog.chunk_server;
 chunk_id | server_chunk_id | server_name 
----------+-----------------+-------------
        1 |               1 | server_1
        2 |               1 | server_2
        3 |               1 | server_3
(3 rows)

-- Adding a new trigger should not recurse to foreign chunks
CREATE TRIGGER _1_test_trigger_insert
    AFTER INSERT ON disttable
    FOR EACH ROW EXECUTE PROCEDURE test_trigger();
SELECT st."Child" as chunk_relid, test.show_triggers((st)."Child")
FROM test.show_subtables('disttable') st;
 chunk_relid | show_triggers 
-------------+---------------
(0 rows)

-- Check that we can create indexes on distributed hypertables and
-- that they don't recurse to foreign chunks
CREATE INDEX ON disttable (time, device);
SELECT * FROM test.show_indexes('disttable');
           Index           |    Columns    | Expr | Unique | Primary | Exclusion | Tablespace 
---------------------------+---------------+------+--------+---------+-----------+------------
 disttable_pkey            | {time}        |      | t      | t       | f         | 
 disttable_time_device_idx | {time,device} |      | f      | f       | f         | 
(2 rows)

SELECT st."Child" as chunk_relid, test.show_indexes((st)."Child")
FROM test.show_subtables('disttable') st;
 chunk_relid | show_indexes 
-------------+--------------
(0 rows)

-- No index mappings should exist either
SELECT * FROM _timescaledb_catalog.chunk_index;
 chunk_id | index_name | hypertable_id | hypertable_index_name 
----------+------------+---------------+-----------------------
(0 rows)

-- Check that creating columns work
ALTER TABLE disttable ADD COLUMN "Color" int;
-- Currently no distributed DDL support, so need to manually add
-- column on datanodes
\c server_1
ALTER TABLE disttable ADD COLUMN "Color" int;
\c server_2
ALTER TABLE disttable ADD COLUMN "Color" int;
\c server_3
ALTER TABLE disttable ADD COLUMN "Color" int;
\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
SELECT * FROM test.show_columns('disttable');
 Column |           Type           | NotNull 
--------+--------------------------+---------
 time   | timestamp with time zone | t
 device | integer                  | f
 temp   | double precision         | f
 Color  | integer                  | f
(4 rows)

SELECT st."Child" as chunk_relid, test.show_columns((st)."Child")
FROM test.show_subtables('disttable') st;
                 chunk_relid                 |            show_columns             
---------------------------------------------+-------------------------------------
 _timescaledb_internal._hyper_1_1_dist_chunk | (time,"timestamp with time zone",t)
 _timescaledb_internal._hyper_1_1_dist_chunk | (device,integer,f)
 _timescaledb_internal._hyper_1_1_dist_chunk | (temp,"double precision",f)
 _timescaledb_internal._hyper_1_1_dist_chunk | (Color,integer,f)
 _timescaledb_internal._hyper_1_2_dist_chunk | (time,"timestamp with time zone",t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (device,integer,f)
 _timescaledb_internal._hyper_1_2_dist_chunk | (temp,"double precision",f)
 _timescaledb_internal._hyper_1_2_dist_chunk | (Color,integer,f)
 _timescaledb_internal._hyper_1_3_dist_chunk | (time,"timestamp with time zone",t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (device,integer,f)
 _timescaledb_internal._hyper_1_3_dist_chunk | (temp,"double precision",f)
 _timescaledb_internal._hyper_1_3_dist_chunk | (Color,integer,f)
(12 rows)

-- Adding a new unique constraint should not recurse to foreign
-- chunks, but a check constraint should
ALTER TABLE disttable ADD CONSTRAINT disttable_color_unique UNIQUE (time, "Color");
ALTER TABLE disttable ADD CONSTRAINT disttable_temp_non_negative CHECK (temp > 0.0);
SELECT st."Child" as chunk_relid, test.show_constraints((st)."Child")
FROM test.show_subtables('disttable') st;
                 chunk_relid                 |                                                                                   show_constraints                                                                                   
---------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 _timescaledb_internal._hyper_1_1_dist_chunk | (constraint_1,c,{time},-,"((""time"" >= 'Wed Dec 28 16:00:00 2016 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 04 16:00:00 2017 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_1_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_1_dist_chunk | (disttable_temp_non_negative,c,{temp},-,"(temp > (0.0)::double precision)",f,f,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (constraint_2,c,{time},-,"((""time"" >= 'Wed Dec 27 16:00:00 2017 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 03 16:00:00 2018 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (disttable_temp_non_negative,c,{temp},-,"(temp > (0.0)::double precision)",f,f,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (constraint_3,c,{time},-,"((""time"" >= 'Wed Dec 26 16:00:00 2018 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 02 16:00:00 2019 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (disttable_temp_non_negative,c,{temp},-,"(temp > (0.0)::double precision)",f,f,t)
(9 rows)

SELECT cc.*
FROM (SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
      FROM show_chunks('disttable')) c,
      _timescaledb_catalog.chunk_constraint cc
WHERE c.chunk_id = cc.chunk_id;
 chunk_id | dimension_slice_id | constraint_name | hypertable_constraint_name 
----------+--------------------+-----------------+----------------------------
        1 |                  1 | constraint_1    | 
        2 |                  2 | constraint_2    | 
        3 |                  3 | constraint_3    | 
(3 rows)

-- Test INSERTS with RETURNING. Since we previously dropped a column
-- on the hypertable, this also tests that we handle conversion of the
-- attribute numbers in the RETURNING clause, since they now differ
-- between the hypertable root relation and the chunk currently
-- RETURNING from.
INSERT INTO disttable (time, device, "Color", temp)
VALUES ('2017-09-02 06:09', 4, 1, 9.8)
RETURNING time, "Color", temp;
             time             | Color | temp 
------------------------------+-------+------
 Sat Sep 02 06:09:00 2017 PDT |     1 |  9.8
(1 row)

-- On conflict
INSERT INTO disttable (time, device, "Color", temp)
VALUES ('2017-09-02 06:09', 6, 2, 10.5)
ON CONFLICT DO NOTHING;
-- Show new row and that conflicting row is not inserted
\c server_1
SELECT * FROM disttable;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1 |      
 Sun Jan 01 08:01:00 2017 PST |      1 |  1.2 |      
 Sun Jan 01 06:05:00 2017 PST |      1 |  1.4 |      
(3 rows)

\c server_2
SELECT * FROM disttable;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Tue Jan 02 08:01:00 2018 PST |      2 |  1.3 |      
 Sat Sep 02 06:09:00 2017 PDT |      4 |  9.8 |     1
(2 rows)

\c server_3
SELECT * FROM disttable;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Tue Jan 01 09:11:00 2019 PST |      3 |  2.1 |      
(1 row)

\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
\set ON_ERROR_STOP 0
-- ON CONFLICT only works with DO NOTHING
INSERT INTO disttable (time, device, "Color", temp)
VALUES ('2017-09-09 08:13', 7, 3, 27.5)
ON CONFLICT (time) DO UPDATE SET temp = 3.2;
ERROR:  unexpected ON CONFLICT specification: 2
\set ON_ERROR_STOP 1
-- Test updates
UPDATE disttable SET device = 4 WHERE device = 3;
WITH devices AS (
     SELECT DISTINCT device FROM disttable ORDER BY device
)
UPDATE disttable SET device = 2 WHERE device = (SELECT device FROM devices LIMIT 1);
\set ON_ERROR_STOP 0
-- Updates referencing non-existing column
UPDATE disttable SET device = 4 WHERE no_such_column = 2;
ERROR:  column "no_such_column" does not exist at character 39
UPDATE disttable SET no_such_column = 4 WHERE device = 2;
ERROR:  column "no_such_column" of relation "disttable" does not exist at character 22
-- Update to system column
UPDATE disttable SET tableoid = 4 WHERE device = 2;
ERROR:  cannot assign to system column "tableoid" at character 22
\set ON_ERROR_STOP 1
-- Test deletes
DELETE FROM disttable WHERE device = 3;
-- Test underreplicated chunk warning
INSERT INTO underreplicated VALUES ('2017-01-01 06:01', 1, 1.1);
WARNING:  under-replicated chunk 5, lacks 1 server(s)
SELECT * FROM _timescaledb_catalog.chunk_server;
 chunk_id | server_chunk_id | server_name 
----------+-----------------+-------------
        1 |               1 | server_1
        2 |               1 | server_2
        3 |               1 | server_3
        4 |               2 | server_2
        5 |               2 | server_1
        5 |               3 | server_2
        5 |               2 | server_3
(7 rows)

SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('underreplicated');
 chunk_id | hypertable_id |      schema_name      |      table_name       | relkind |                     slices                     
----------+---------------+-----------------------+-----------------------+---------+------------------------------------------------
        5 |             2 | _timescaledb_internal | _hyper_2_5_dist_chunk | f       | {"time": [1482969600000000, 1483574400000000]}
(1 row)

-- Show chunk server mappings
SELECT * FROM _timescaledb_catalog.chunk_server;
 chunk_id | server_chunk_id | server_name 
----------+-----------------+-------------
        1 |               1 | server_1
        2 |               1 | server_2
        3 |               1 | server_3
        4 |               2 | server_2
        5 |               2 | server_1
        5 |               3 | server_2
        5 |               2 | server_3
(7 rows)

