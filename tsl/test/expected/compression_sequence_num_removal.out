-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- test query planning with hypertable which contains
-- compressed chunks that depend on sequence number optimization
-- which is removed in latest schema revision
\c :TEST_DBNAME :ROLE_CLUSTER_SUPERUSER
SET ROLE :ROLE_DEFAULT_PERM_USER;
\set EXPLAIN 'EXPLAIN (VERBOSE, COSTS OFF)'
CREATE TABLE hyper(
    time INT NOT NULL,
    device_id INT,
    val INT);
SELECT * FROM create_hypertable('hyper', 'time', chunk_time_interval => 10);
 hypertable_id | schema_name | table_name | created 
---------------+-------------+------------+---------
             1 | public      | hyper      | t
(1 row)

-- test case with segmentby
ALTER TABLE hyper SET (
    timescaledb.compress,
    timescaledb.compress_orderby = 'time',
    timescaledb.compress_segmentby = 'device_id');
INSERT INTO hyper VALUES (1, 1, 1), (2, 2, 1), (3, 3, 1), (10, 3, 2), (11, 4, 2), (11, 5, 2), (21, 2, 3), (22, 3, 3), (23, 4, 3), (30, 1, 4), (31, 3, 4), (31, 5, 4);
SELECT compress_chunk(show_chunks('hyper'));
             compress_chunk             
----------------------------------------
 _timescaledb_internal._hyper_1_1_chunk
 _timescaledb_internal._hyper_1_2_chunk
 _timescaledb_internal._hyper_1_3_chunk
 _timescaledb_internal._hyper_1_4_chunk
(4 rows)

-- output without sequence number chunks, should match output with sequence numbers below
:EXPLAIN SELECT * FROM hyper
ORDER BY device_id, time;
                                                                                                                     QUERY PLAN                                                                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Append
   Sort Key: _hyper_1_1_chunk.device_id, _hyper_1_1_chunk."time"
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_1_chunk
         Output: _hyper_1_1_chunk."time", _hyper_1_1_chunk.device_id, _hyper_1_1_chunk.val
         ->  Index Scan using compress_hyper_2_5_chunk_device_id__ts_meta_min_1__ts_meta__idx on _timescaledb_internal.compress_hyper_2_5_chunk
               Output: compress_hyper_2_5_chunk._ts_meta_count, compress_hyper_2_5_chunk.device_id, compress_hyper_2_5_chunk._ts_meta_min_1, compress_hyper_2_5_chunk._ts_meta_max_1, compress_hyper_2_5_chunk."time", compress_hyper_2_5_chunk.val
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_2_chunk
         Output: _hyper_1_2_chunk."time", _hyper_1_2_chunk.device_id, _hyper_1_2_chunk.val
         ->  Index Scan using compress_hyper_2_6_chunk_device_id__ts_meta_min_1__ts_meta__idx on _timescaledb_internal.compress_hyper_2_6_chunk
               Output: compress_hyper_2_6_chunk._ts_meta_count, compress_hyper_2_6_chunk.device_id, compress_hyper_2_6_chunk._ts_meta_min_1, compress_hyper_2_6_chunk._ts_meta_max_1, compress_hyper_2_6_chunk."time", compress_hyper_2_6_chunk.val
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_3_chunk
         Output: _hyper_1_3_chunk."time", _hyper_1_3_chunk.device_id, _hyper_1_3_chunk.val
         ->  Index Scan using compress_hyper_2_7_chunk_device_id__ts_meta_min_1__ts_meta__idx on _timescaledb_internal.compress_hyper_2_7_chunk
               Output: compress_hyper_2_7_chunk._ts_meta_count, compress_hyper_2_7_chunk.device_id, compress_hyper_2_7_chunk._ts_meta_min_1, compress_hyper_2_7_chunk._ts_meta_max_1, compress_hyper_2_7_chunk."time", compress_hyper_2_7_chunk.val
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_4_chunk
         Output: _hyper_1_4_chunk."time", _hyper_1_4_chunk.device_id, _hyper_1_4_chunk.val
         ->  Index Scan using compress_hyper_2_8_chunk_device_id__ts_meta_min_1__ts_meta__idx on _timescaledb_internal.compress_hyper_2_8_chunk
               Output: compress_hyper_2_8_chunk._ts_meta_count, compress_hyper_2_8_chunk.device_id, compress_hyper_2_8_chunk._ts_meta_min_1, compress_hyper_2_8_chunk._ts_meta_max_1, compress_hyper_2_8_chunk."time", compress_hyper_2_8_chunk.val
(18 rows)

SELECT * FROM hyper
ORDER BY device_id, time;
 time | device_id | val 
------+-----------+-----
    1 |         1 |   1
   30 |         1 |   4
    2 |         2 |   1
   21 |         2 |   3
    3 |         3 |   1
   10 |         3 |   2
   22 |         3 |   3
   31 |         3 |   4
   11 |         4 |   2
   23 |         4 |   3
   11 |         5 |   2
   31 |         5 |   4
(12 rows)

-- backwards index scan
:EXPLAIN SELECT * FROM hyper
ORDER BY device_id DESC, time DESC;
                                                                                                                     QUERY PLAN                                                                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Append
   Sort Key: _hyper_1_1_chunk.device_id DESC, _hyper_1_1_chunk."time" DESC
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_1_chunk
         Output: _hyper_1_1_chunk."time", _hyper_1_1_chunk.device_id, _hyper_1_1_chunk.val
         ->  Index Scan Backward using compress_hyper_2_5_chunk_device_id__ts_meta_min_1__ts_meta__idx on _timescaledb_internal.compress_hyper_2_5_chunk
               Output: compress_hyper_2_5_chunk._ts_meta_count, compress_hyper_2_5_chunk.device_id, compress_hyper_2_5_chunk._ts_meta_min_1, compress_hyper_2_5_chunk._ts_meta_max_1, compress_hyper_2_5_chunk."time", compress_hyper_2_5_chunk.val
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_2_chunk
         Output: _hyper_1_2_chunk."time", _hyper_1_2_chunk.device_id, _hyper_1_2_chunk.val
         ->  Index Scan Backward using compress_hyper_2_6_chunk_device_id__ts_meta_min_1__ts_meta__idx on _timescaledb_internal.compress_hyper_2_6_chunk
               Output: compress_hyper_2_6_chunk._ts_meta_count, compress_hyper_2_6_chunk.device_id, compress_hyper_2_6_chunk._ts_meta_min_1, compress_hyper_2_6_chunk._ts_meta_max_1, compress_hyper_2_6_chunk."time", compress_hyper_2_6_chunk.val
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_3_chunk
         Output: _hyper_1_3_chunk."time", _hyper_1_3_chunk.device_id, _hyper_1_3_chunk.val
         ->  Index Scan Backward using compress_hyper_2_7_chunk_device_id__ts_meta_min_1__ts_meta__idx on _timescaledb_internal.compress_hyper_2_7_chunk
               Output: compress_hyper_2_7_chunk._ts_meta_count, compress_hyper_2_7_chunk.device_id, compress_hyper_2_7_chunk._ts_meta_min_1, compress_hyper_2_7_chunk._ts_meta_max_1, compress_hyper_2_7_chunk."time", compress_hyper_2_7_chunk.val
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_4_chunk
         Output: _hyper_1_4_chunk."time", _hyper_1_4_chunk.device_id, _hyper_1_4_chunk.val
         ->  Index Scan Backward using compress_hyper_2_8_chunk_device_id__ts_meta_min_1__ts_meta__idx on _timescaledb_internal.compress_hyper_2_8_chunk
               Output: compress_hyper_2_8_chunk._ts_meta_count, compress_hyper_2_8_chunk.device_id, compress_hyper_2_8_chunk._ts_meta_min_1, compress_hyper_2_8_chunk._ts_meta_max_1, compress_hyper_2_8_chunk."time", compress_hyper_2_8_chunk.val
(18 rows)

SELECT * FROM hyper
ORDER BY device_id DESC, time DESC;
 time | device_id | val 
------+-----------+-----
   31 |         5 |   4
   11 |         5 |   2
   23 |         4 |   3
   11 |         4 |   2
   31 |         3 |   4
   22 |         3 |   3
   10 |         3 |   2
    3 |         3 |   1
   21 |         2 |   3
    2 |         2 |   1
   30 |         1 |   4
    1 |         1 |   1
(12 rows)

-- modify two chunks by adding sequence number to the segments
-- and rebuild the index based on that column
SELECT comp_ch.table_name AS "CHUNK_NAME", comp_ch.schema_name|| '.' || comp_ch.table_name AS "CHUNK_FULL_NAME"
FROM _timescaledb_catalog.chunk ch1, _timescaledb_catalog.chunk comp_ch, _timescaledb_catalog.hypertable ht
WHERE ch1.hypertable_id = ht.id AND ht.table_name LIKE 'hyper'
AND ch1.compressed_chunk_id = comp_ch.id
ORDER BY ch1.id LIMIT 1 \gset
SELECT schemaname || '.' || indexname AS "CHUNK_INDEX" FROM pg_indexes where tablename = :'CHUNK_NAME'
LIMIT 1 \gset
SET ROLE :ROLE_CLUSTER_SUPERUSER;
SET timescaledb.restoring TO ON;
-- add sequence number column and fill in the correct sequences
ALTER TABLE :CHUNK_FULL_NAME ADD COLUMN _ts_meta_sequence_num int;
INSERT INTO :CHUNK_FULL_NAME (device_id, time, val, _ts_meta_count, _ts_meta_min_1, _ts_meta_max_1, _ts_meta_sequence_num)
SELECT device_id, time, val, _ts_meta_count, _ts_meta_min_1, _ts_meta_max_1 , 10*row_number() over (partition by device_id) as _ts_meta_sequence_num
FROM :CHUNK_FULL_NAME
ORDER BY device_id, _ts_meta_min_1, _ts_meta_max_1;
DELETE FROM :CHUNK_FULL_NAME WHERE _ts_meta_sequence_num IS NULL;
-- drop exising index
DROP INDEX :CHUNK_INDEX;
-- create index based on sequence numbers
CREATE INDEX ON :CHUNK_FULL_NAME (device_id, _ts_meta_sequence_num);
SET timescaledb.restoring TO OFF;
SET ROLE :ROLE_DEFAULT_PERM_USER;
SELECT comp_ch.table_name AS "CHUNK_NAME", comp_ch.schema_name|| '.' || comp_ch.table_name AS "CHUNK_FULL_NAME"
FROM _timescaledb_catalog.chunk ch1, _timescaledb_catalog.chunk comp_ch, _timescaledb_catalog.hypertable ht
WHERE ch1.hypertable_id = ht.id AND ht.table_name LIKE 'hyper'
AND ch1.compressed_chunk_id = comp_ch.id
ORDER BY ch1.id OFFSET 2 LIMIT 1 \gset
SELECT schemaname || '.' || indexname AS "CHUNK_INDEX" FROM pg_indexes where tablename = :'CHUNK_NAME'
LIMIT 1 \gset
SET ROLE :ROLE_CLUSTER_SUPERUSER;
SET timescaledb.restoring TO ON;
-- add sequence number column and fill in the correct sequences
ALTER TABLE :CHUNK_FULL_NAME ADD COLUMN _ts_meta_sequence_num int;
INSERT INTO :CHUNK_FULL_NAME (device_id, time, val, _ts_meta_count, _ts_meta_min_1, _ts_meta_max_1, _ts_meta_sequence_num)
SELECT device_id, time, val, _ts_meta_count, _ts_meta_min_1, _ts_meta_max_1 , 10*row_number() over (partition by device_id) as _ts_meta_sequence_num
FROM :CHUNK_FULL_NAME
ORDER BY device_id, _ts_meta_min_1, _ts_meta_max_1;
DELETE FROM :CHUNK_FULL_NAME WHERE _ts_meta_sequence_num IS NULL;
-- drop exising index
DROP INDEX :CHUNK_INDEX;
-- create index based on sequence numbers
CREATE INDEX ON :CHUNK_FULL_NAME (device_id, _ts_meta_sequence_num);
SET timescaledb.restoring TO OFF;
SET ROLE :ROLE_DEFAULT_PERM_USER;
-- from this point, two chunks should use sequence numbers and the rest will work without them
-- output with sequence number chunks, should match output without sequence numbers above
:EXPLAIN SELECT * FROM hyper
ORDER BY device_id, time;
                                                                                                                                             QUERY PLAN                                                                                                                                             
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Append
   Sort Key: _hyper_1_1_chunk.device_id, _hyper_1_1_chunk."time"
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_1_chunk
         Output: _hyper_1_1_chunk."time", _hyper_1_1_chunk.device_id, _hyper_1_1_chunk.val
         ->  Index Scan using compress_hyper_2_5_chunk_device_id__ts_meta_sequence_num_idx on _timescaledb_internal.compress_hyper_2_5_chunk
               Output: compress_hyper_2_5_chunk._ts_meta_count, compress_hyper_2_5_chunk.device_id, compress_hyper_2_5_chunk._ts_meta_min_1, compress_hyper_2_5_chunk._ts_meta_max_1, compress_hyper_2_5_chunk."time", compress_hyper_2_5_chunk.val, compress_hyper_2_5_chunk._ts_meta_sequence_num
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_2_chunk
         Output: _hyper_1_2_chunk."time", _hyper_1_2_chunk.device_id, _hyper_1_2_chunk.val
         ->  Index Scan using compress_hyper_2_6_chunk_device_id__ts_meta_min_1__ts_meta__idx on _timescaledb_internal.compress_hyper_2_6_chunk
               Output: compress_hyper_2_6_chunk._ts_meta_count, compress_hyper_2_6_chunk.device_id, compress_hyper_2_6_chunk._ts_meta_min_1, compress_hyper_2_6_chunk._ts_meta_max_1, compress_hyper_2_6_chunk."time", compress_hyper_2_6_chunk.val
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_3_chunk
         Output: _hyper_1_3_chunk."time", _hyper_1_3_chunk.device_id, _hyper_1_3_chunk.val
         ->  Index Scan using compress_hyper_2_7_chunk_device_id__ts_meta_sequence_num_idx on _timescaledb_internal.compress_hyper_2_7_chunk
               Output: compress_hyper_2_7_chunk._ts_meta_count, compress_hyper_2_7_chunk.device_id, compress_hyper_2_7_chunk._ts_meta_min_1, compress_hyper_2_7_chunk._ts_meta_max_1, compress_hyper_2_7_chunk."time", compress_hyper_2_7_chunk.val, compress_hyper_2_7_chunk._ts_meta_sequence_num
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_4_chunk
         Output: _hyper_1_4_chunk."time", _hyper_1_4_chunk.device_id, _hyper_1_4_chunk.val
         ->  Index Scan using compress_hyper_2_8_chunk_device_id__ts_meta_min_1__ts_meta__idx on _timescaledb_internal.compress_hyper_2_8_chunk
               Output: compress_hyper_2_8_chunk._ts_meta_count, compress_hyper_2_8_chunk.device_id, compress_hyper_2_8_chunk._ts_meta_min_1, compress_hyper_2_8_chunk._ts_meta_max_1, compress_hyper_2_8_chunk."time", compress_hyper_2_8_chunk.val
(18 rows)

SELECT * FROM hyper
ORDER BY device_id, time;
 time | device_id | val 
------+-----------+-----
    1 |         1 |   1
   30 |         1 |   4
    2 |         2 |   1
   21 |         2 |   3
    3 |         3 |   1
   10 |         3 |   2
   22 |         3 |   3
   31 |         3 |   4
   11 |         4 |   2
   23 |         4 |   3
   11 |         5 |   2
   31 |         5 |   4
(12 rows)

-- backwards index scan
:EXPLAIN SELECT * FROM hyper
ORDER BY device_id DESC, time DESC;
                                                                                                                                             QUERY PLAN                                                                                                                                             
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Append
   Sort Key: _hyper_1_1_chunk.device_id DESC, _hyper_1_1_chunk."time" DESC
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_1_chunk
         Output: _hyper_1_1_chunk."time", _hyper_1_1_chunk.device_id, _hyper_1_1_chunk.val
         ->  Index Scan Backward using compress_hyper_2_5_chunk_device_id__ts_meta_sequence_num_idx on _timescaledb_internal.compress_hyper_2_5_chunk
               Output: compress_hyper_2_5_chunk._ts_meta_count, compress_hyper_2_5_chunk.device_id, compress_hyper_2_5_chunk._ts_meta_min_1, compress_hyper_2_5_chunk._ts_meta_max_1, compress_hyper_2_5_chunk."time", compress_hyper_2_5_chunk.val, compress_hyper_2_5_chunk._ts_meta_sequence_num
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_2_chunk
         Output: _hyper_1_2_chunk."time", _hyper_1_2_chunk.device_id, _hyper_1_2_chunk.val
         ->  Index Scan Backward using compress_hyper_2_6_chunk_device_id__ts_meta_min_1__ts_meta__idx on _timescaledb_internal.compress_hyper_2_6_chunk
               Output: compress_hyper_2_6_chunk._ts_meta_count, compress_hyper_2_6_chunk.device_id, compress_hyper_2_6_chunk._ts_meta_min_1, compress_hyper_2_6_chunk._ts_meta_max_1, compress_hyper_2_6_chunk."time", compress_hyper_2_6_chunk.val
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_3_chunk
         Output: _hyper_1_3_chunk."time", _hyper_1_3_chunk.device_id, _hyper_1_3_chunk.val
         ->  Index Scan Backward using compress_hyper_2_7_chunk_device_id__ts_meta_sequence_num_idx on _timescaledb_internal.compress_hyper_2_7_chunk
               Output: compress_hyper_2_7_chunk._ts_meta_count, compress_hyper_2_7_chunk.device_id, compress_hyper_2_7_chunk._ts_meta_min_1, compress_hyper_2_7_chunk._ts_meta_max_1, compress_hyper_2_7_chunk."time", compress_hyper_2_7_chunk.val, compress_hyper_2_7_chunk._ts_meta_sequence_num
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_4_chunk
         Output: _hyper_1_4_chunk."time", _hyper_1_4_chunk.device_id, _hyper_1_4_chunk.val
         ->  Index Scan Backward using compress_hyper_2_8_chunk_device_id__ts_meta_min_1__ts_meta__idx on _timescaledb_internal.compress_hyper_2_8_chunk
               Output: compress_hyper_2_8_chunk._ts_meta_count, compress_hyper_2_8_chunk.device_id, compress_hyper_2_8_chunk._ts_meta_min_1, compress_hyper_2_8_chunk._ts_meta_max_1, compress_hyper_2_8_chunk."time", compress_hyper_2_8_chunk.val
(18 rows)

SELECT * FROM hyper
ORDER BY device_id DESC, time DESC;
 time | device_id | val 
------+-----------+-----
   31 |         5 |   4
   11 |         5 |   2
   23 |         4 |   3
   11 |         4 |   2
   31 |         3 |   4
   22 |         3 |   3
   10 |         3 |   2
    3 |         3 |   1
   21 |         2 |   3
    2 |         2 |   1
   30 |         1 |   4
    1 |         1 |   1
(12 rows)

-- test recompression which should do a full recompress of the chunk
-- while dropping sequence numbers
INSERT INTO hyper VALUES (20, 1, 1);
SELECT compress_chunk(show_chunks('hyper'));
NOTICE:  chunk "_hyper_1_1_chunk" is already compressed
NOTICE:  chunk "_hyper_1_2_chunk" is already compressed
NOTICE:  chunk "_hyper_1_4_chunk" is already compressed
             compress_chunk             
----------------------------------------
 _timescaledb_internal._hyper_1_1_chunk
 _timescaledb_internal._hyper_1_2_chunk
 _timescaledb_internal._hyper_1_3_chunk
 _timescaledb_internal._hyper_1_4_chunk
(4 rows)

-- removal of sequence numbers from the chunk should be
-- reflected in this plan
:EXPLAIN SELECT * FROM hyper
ORDER BY device_id, time;
                                                                                                                                             QUERY PLAN                                                                                                                                             
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Append
   Sort Key: _hyper_1_1_chunk.device_id, _hyper_1_1_chunk."time"
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_1_chunk
         Output: _hyper_1_1_chunk."time", _hyper_1_1_chunk.device_id, _hyper_1_1_chunk.val
         ->  Index Scan using compress_hyper_2_5_chunk_device_id__ts_meta_sequence_num_idx on _timescaledb_internal.compress_hyper_2_5_chunk
               Output: compress_hyper_2_5_chunk._ts_meta_count, compress_hyper_2_5_chunk.device_id, compress_hyper_2_5_chunk._ts_meta_min_1, compress_hyper_2_5_chunk._ts_meta_max_1, compress_hyper_2_5_chunk."time", compress_hyper_2_5_chunk.val, compress_hyper_2_5_chunk._ts_meta_sequence_num
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_2_chunk
         Output: _hyper_1_2_chunk."time", _hyper_1_2_chunk.device_id, _hyper_1_2_chunk.val
         ->  Index Scan using compress_hyper_2_6_chunk_device_id__ts_meta_min_1__ts_meta__idx on _timescaledb_internal.compress_hyper_2_6_chunk
               Output: compress_hyper_2_6_chunk._ts_meta_count, compress_hyper_2_6_chunk.device_id, compress_hyper_2_6_chunk._ts_meta_min_1, compress_hyper_2_6_chunk._ts_meta_max_1, compress_hyper_2_6_chunk."time", compress_hyper_2_6_chunk.val
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_3_chunk
         Output: _hyper_1_3_chunk."time", _hyper_1_3_chunk.device_id, _hyper_1_3_chunk.val
         ->  Index Scan using compress_hyper_2_9_chunk_device_id__ts_meta_min_1__ts_meta__idx on _timescaledb_internal.compress_hyper_2_9_chunk
               Output: compress_hyper_2_9_chunk._ts_meta_count, compress_hyper_2_9_chunk.device_id, compress_hyper_2_9_chunk._ts_meta_min_1, compress_hyper_2_9_chunk._ts_meta_max_1, compress_hyper_2_9_chunk."time", compress_hyper_2_9_chunk.val
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_4_chunk
         Output: _hyper_1_4_chunk."time", _hyper_1_4_chunk.device_id, _hyper_1_4_chunk.val
         ->  Index Scan using compress_hyper_2_8_chunk_device_id__ts_meta_min_1__ts_meta__idx on _timescaledb_internal.compress_hyper_2_8_chunk
               Output: compress_hyper_2_8_chunk._ts_meta_count, compress_hyper_2_8_chunk.device_id, compress_hyper_2_8_chunk._ts_meta_min_1, compress_hyper_2_8_chunk._ts_meta_max_1, compress_hyper_2_8_chunk."time", compress_hyper_2_8_chunk.val
(18 rows)

-- test case without segmentby
TRUNCATE hyper;
ALTER TABLE hyper SET (
    timescaledb.compress,
    timescaledb.compress_orderby = 'time',
    timescaledb.compress_segmentby = '');
INSERT INTO hyper VALUES (1, 1, 1), (2, 2, 1), (3, 3, 1), (10, 3, 2), (11, 4, 2), (11, 5, 2), (21, 2, 3), (22, 3, 3), (23, 4, 3), (30, 1, 4), (31, 3, 4), (31, 5, 4);
SELECT compress_chunk(show_chunks('hyper'));
             compress_chunk              
-----------------------------------------
 _timescaledb_internal._hyper_1_10_chunk
 _timescaledb_internal._hyper_1_11_chunk
 _timescaledb_internal._hyper_1_12_chunk
 _timescaledb_internal._hyper_1_13_chunk
(4 rows)

:EXPLAIN SELECT * FROM hyper
ORDER BY time;
                                                                                                                           QUERY PLAN                                                                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ChunkAppend) on public.hyper
   Output: hyper."time", hyper.device_id, hyper.val
   Order: hyper."time"
   Startup Exclusion: false
   Runtime Exclusion: false
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_10_chunk
         Output: _hyper_1_10_chunk."time", _hyper_1_10_chunk.device_id, _hyper_1_10_chunk.val
         ->  Sort
               Output: compress_hyper_2_14_chunk._ts_meta_count, compress_hyper_2_14_chunk._ts_meta_min_1, compress_hyper_2_14_chunk._ts_meta_max_1, compress_hyper_2_14_chunk."time", compress_hyper_2_14_chunk.device_id, compress_hyper_2_14_chunk.val
               Sort Key: compress_hyper_2_14_chunk._ts_meta_min_1, compress_hyper_2_14_chunk._ts_meta_max_1
               ->  Seq Scan on _timescaledb_internal.compress_hyper_2_14_chunk
                     Output: compress_hyper_2_14_chunk._ts_meta_count, compress_hyper_2_14_chunk._ts_meta_min_1, compress_hyper_2_14_chunk._ts_meta_max_1, compress_hyper_2_14_chunk."time", compress_hyper_2_14_chunk.device_id, compress_hyper_2_14_chunk.val
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_11_chunk
         Output: _hyper_1_11_chunk."time", _hyper_1_11_chunk.device_id, _hyper_1_11_chunk.val
         ->  Sort
               Output: compress_hyper_2_15_chunk._ts_meta_count, compress_hyper_2_15_chunk._ts_meta_min_1, compress_hyper_2_15_chunk._ts_meta_max_1, compress_hyper_2_15_chunk."time", compress_hyper_2_15_chunk.device_id, compress_hyper_2_15_chunk.val
               Sort Key: compress_hyper_2_15_chunk._ts_meta_min_1, compress_hyper_2_15_chunk._ts_meta_max_1
               ->  Seq Scan on _timescaledb_internal.compress_hyper_2_15_chunk
                     Output: compress_hyper_2_15_chunk._ts_meta_count, compress_hyper_2_15_chunk._ts_meta_min_1, compress_hyper_2_15_chunk._ts_meta_max_1, compress_hyper_2_15_chunk."time", compress_hyper_2_15_chunk.device_id, compress_hyper_2_15_chunk.val
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_12_chunk
         Output: _hyper_1_12_chunk."time", _hyper_1_12_chunk.device_id, _hyper_1_12_chunk.val
         ->  Sort
               Output: compress_hyper_2_16_chunk._ts_meta_count, compress_hyper_2_16_chunk._ts_meta_min_1, compress_hyper_2_16_chunk._ts_meta_max_1, compress_hyper_2_16_chunk."time", compress_hyper_2_16_chunk.device_id, compress_hyper_2_16_chunk.val
               Sort Key: compress_hyper_2_16_chunk._ts_meta_min_1, compress_hyper_2_16_chunk._ts_meta_max_1
               ->  Seq Scan on _timescaledb_internal.compress_hyper_2_16_chunk
                     Output: compress_hyper_2_16_chunk._ts_meta_count, compress_hyper_2_16_chunk._ts_meta_min_1, compress_hyper_2_16_chunk._ts_meta_max_1, compress_hyper_2_16_chunk."time", compress_hyper_2_16_chunk.device_id, compress_hyper_2_16_chunk.val
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_13_chunk
         Output: _hyper_1_13_chunk."time", _hyper_1_13_chunk.device_id, _hyper_1_13_chunk.val
         ->  Sort
               Output: compress_hyper_2_17_chunk._ts_meta_count, compress_hyper_2_17_chunk._ts_meta_min_1, compress_hyper_2_17_chunk._ts_meta_max_1, compress_hyper_2_17_chunk."time", compress_hyper_2_17_chunk.device_id, compress_hyper_2_17_chunk.val
               Sort Key: compress_hyper_2_17_chunk._ts_meta_min_1, compress_hyper_2_17_chunk._ts_meta_max_1
               ->  Seq Scan on _timescaledb_internal.compress_hyper_2_17_chunk
                     Output: compress_hyper_2_17_chunk._ts_meta_count, compress_hyper_2_17_chunk._ts_meta_min_1, compress_hyper_2_17_chunk._ts_meta_max_1, compress_hyper_2_17_chunk."time", compress_hyper_2_17_chunk.device_id, compress_hyper_2_17_chunk.val
(33 rows)

-- modify two chunks by adding sequence number to the segments
SELECT comp_ch.table_name AS "CHUNK_NAME", comp_ch.schema_name|| '.' || comp_ch.table_name AS "CHUNK_FULL_NAME"
FROM _timescaledb_catalog.chunk ch1, _timescaledb_catalog.chunk comp_ch, _timescaledb_catalog.hypertable ht
WHERE ch1.hypertable_id = ht.id AND ht.table_name LIKE 'hyper'
AND ch1.compressed_chunk_id = comp_ch.id
ORDER BY ch1.id LIMIT 1 \gset
\c :TEST_DBNAME :ROLE_CLUSTER_SUPERUSER
SET timescaledb.restoring TO ON;
-- add sequence number column and fill in the correct sequences
ALTER TABLE :CHUNK_FULL_NAME ADD COLUMN _ts_meta_sequence_num int;
INSERT INTO :CHUNK_FULL_NAME (device_id, time, val, _ts_meta_count, _ts_meta_min_1, _ts_meta_max_1, _ts_meta_sequence_num)
SELECT device_id, time, val, _ts_meta_count, _ts_meta_min_1, _ts_meta_max_1 , 10*row_number() over () as _ts_meta_sequence_num
FROM :CHUNK_FULL_NAME
ORDER BY _ts_meta_min_1, _ts_meta_max_1;
DELETE FROM :CHUNK_FULL_NAME WHERE _ts_meta_sequence_num IS NULL;
SET timescaledb.restoring TO OFF;
\c :TEST_DBNAME :ROLE_DEFAULT_PERM_USER
SELECT comp_ch.table_name AS "CHUNK_NAME", comp_ch.schema_name|| '.' || comp_ch.table_name AS "CHUNK_FULL_NAME"
FROM _timescaledb_catalog.chunk ch1, _timescaledb_catalog.chunk comp_ch, _timescaledb_catalog.hypertable ht
WHERE ch1.hypertable_id = ht.id AND ht.table_name LIKE 'hyper'
AND ch1.compressed_chunk_id = comp_ch.id
ORDER BY ch1.id OFFSET 3 LIMIT 1 \gset
\c :TEST_DBNAME :ROLE_CLUSTER_SUPERUSER
SET timescaledb.restoring TO ON;
-- add sequence number column and fill in the correct sequences
ALTER TABLE :CHUNK_FULL_NAME ADD COLUMN _ts_meta_sequence_num int;
INSERT INTO :CHUNK_FULL_NAME (device_id, time, val, _ts_meta_count, _ts_meta_min_1, _ts_meta_max_1, _ts_meta_sequence_num)
SELECT device_id, time, val, _ts_meta_count, _ts_meta_min_1, _ts_meta_max_1 , 10*row_number() over () as _ts_meta_sequence_num
FROM :CHUNK_FULL_NAME
ORDER BY _ts_meta_min_1, _ts_meta_max_1;
DELETE FROM :CHUNK_FULL_NAME WHERE _ts_meta_sequence_num IS NULL;
\c :TEST_DBNAME :ROLE_DEFAULT_PERM_USER
-- from this point, two chunks should use sequence numbers and the rest will work without them
:EXPLAIN SELECT * FROM hyper
ORDER BY time;
                                                                                                                                                   QUERY PLAN                                                                                                                                                    
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ChunkAppend) on public.hyper
   Output: hyper."time", hyper.device_id, hyper.val
   Order: hyper."time"
   Startup Exclusion: false
   Runtime Exclusion: false
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_10_chunk
         Output: _hyper_1_10_chunk."time", _hyper_1_10_chunk.device_id, _hyper_1_10_chunk.val
         ->  Sort
               Output: compress_hyper_2_14_chunk._ts_meta_count, compress_hyper_2_14_chunk._ts_meta_min_1, compress_hyper_2_14_chunk._ts_meta_max_1, compress_hyper_2_14_chunk."time", compress_hyper_2_14_chunk.device_id, compress_hyper_2_14_chunk.val, compress_hyper_2_14_chunk._ts_meta_sequence_num
               Sort Key: compress_hyper_2_14_chunk._ts_meta_sequence_num
               ->  Seq Scan on _timescaledb_internal.compress_hyper_2_14_chunk
                     Output: compress_hyper_2_14_chunk._ts_meta_count, compress_hyper_2_14_chunk._ts_meta_min_1, compress_hyper_2_14_chunk._ts_meta_max_1, compress_hyper_2_14_chunk."time", compress_hyper_2_14_chunk.device_id, compress_hyper_2_14_chunk.val, compress_hyper_2_14_chunk._ts_meta_sequence_num
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_11_chunk
         Output: _hyper_1_11_chunk."time", _hyper_1_11_chunk.device_id, _hyper_1_11_chunk.val
         ->  Sort
               Output: compress_hyper_2_15_chunk._ts_meta_count, compress_hyper_2_15_chunk._ts_meta_min_1, compress_hyper_2_15_chunk._ts_meta_max_1, compress_hyper_2_15_chunk."time", compress_hyper_2_15_chunk.device_id, compress_hyper_2_15_chunk.val
               Sort Key: compress_hyper_2_15_chunk._ts_meta_min_1, compress_hyper_2_15_chunk._ts_meta_max_1
               ->  Seq Scan on _timescaledb_internal.compress_hyper_2_15_chunk
                     Output: compress_hyper_2_15_chunk._ts_meta_count, compress_hyper_2_15_chunk._ts_meta_min_1, compress_hyper_2_15_chunk._ts_meta_max_1, compress_hyper_2_15_chunk."time", compress_hyper_2_15_chunk.device_id, compress_hyper_2_15_chunk.val
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_12_chunk
         Output: _hyper_1_12_chunk."time", _hyper_1_12_chunk.device_id, _hyper_1_12_chunk.val
         ->  Sort
               Output: compress_hyper_2_16_chunk._ts_meta_count, compress_hyper_2_16_chunk._ts_meta_min_1, compress_hyper_2_16_chunk._ts_meta_max_1, compress_hyper_2_16_chunk."time", compress_hyper_2_16_chunk.device_id, compress_hyper_2_16_chunk.val
               Sort Key: compress_hyper_2_16_chunk._ts_meta_min_1, compress_hyper_2_16_chunk._ts_meta_max_1
               ->  Seq Scan on _timescaledb_internal.compress_hyper_2_16_chunk
                     Output: compress_hyper_2_16_chunk._ts_meta_count, compress_hyper_2_16_chunk._ts_meta_min_1, compress_hyper_2_16_chunk._ts_meta_max_1, compress_hyper_2_16_chunk."time", compress_hyper_2_16_chunk.device_id, compress_hyper_2_16_chunk.val
   ->  Custom Scan (DecompressChunk) on _timescaledb_internal._hyper_1_13_chunk
         Output: _hyper_1_13_chunk."time", _hyper_1_13_chunk.device_id, _hyper_1_13_chunk.val
         ->  Sort
               Output: compress_hyper_2_17_chunk._ts_meta_count, compress_hyper_2_17_chunk._ts_meta_min_1, compress_hyper_2_17_chunk._ts_meta_max_1, compress_hyper_2_17_chunk."time", compress_hyper_2_17_chunk.device_id, compress_hyper_2_17_chunk.val, compress_hyper_2_17_chunk._ts_meta_sequence_num
               Sort Key: compress_hyper_2_17_chunk._ts_meta_sequence_num
               ->  Seq Scan on _timescaledb_internal.compress_hyper_2_17_chunk
                     Output: compress_hyper_2_17_chunk._ts_meta_count, compress_hyper_2_17_chunk._ts_meta_min_1, compress_hyper_2_17_chunk._ts_meta_max_1, compress_hyper_2_17_chunk."time", compress_hyper_2_17_chunk.device_id, compress_hyper_2_17_chunk.val, compress_hyper_2_17_chunk._ts_meta_sequence_num
(33 rows)

-- test rolling up chunks during compression
-- this will not work with chunks which have sequence numbers
-- since the last chunk has sequence numbers, new chunks will be only rolled up together
ALTER TABLE hyper SET (timescaledb.compress_chunk_time_interval = '30');
WARNING:  there was some uncertainty picking the default segment by for the hypertable: You do not have any indexes on columns that can be used for segment_by and thus we are not using segment_by for compression. Please make sure you are not missing any indexes
NOTICE:  default segment by for hypertable "hyper" is set to ""
INSERT INTO hyper VALUES (41, 1, 1), (42, 2, 1), (43, 3, 1), (50, 3, 2), (51, 4, 2), (51, 5, 2);
-- compression should leave the previous 4 chunks alone
-- and roll up the two new chunks into a single chunk
SELECT compress_chunk(show_chunks('hyper'));
NOTICE:  chunk "_hyper_1_10_chunk" is already compressed
NOTICE:  chunk "_hyper_1_11_chunk" is already compressed
NOTICE:  chunk "_hyper_1_12_chunk" is already compressed
NOTICE:  chunk "_hyper_1_13_chunk" is already compressed
             compress_chunk              
-----------------------------------------
 _timescaledb_internal._hyper_1_10_chunk
 _timescaledb_internal._hyper_1_11_chunk
 _timescaledb_internal._hyper_1_12_chunk
 _timescaledb_internal._hyper_1_13_chunk
 _timescaledb_internal._hyper_1_18_chunk
 _timescaledb_internal._hyper_1_18_chunk
(6 rows)

