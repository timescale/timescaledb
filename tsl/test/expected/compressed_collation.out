-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
\c :TEST_DBNAME :ROLE_SUPERUSER
-- We have different collation names such as en_US, en-US-x-icu and so on,
-- that are available on different platforms.
with encodings as (
  select -1
  union all
  select encoding from pg_database where datname = current_database()
)
, pattern(pattern, priority) as (
    values ('en_us%',  2), ('en_us_utf%8%', 1)
)
, collations as (
    select priority, collname
    from pg_collation join pattern
    on collname ilike pattern
    where collencoding in (select * from encodings)
    order by priority, collencoding, collname
)
select * from (
    select 3 priority, 'C' "COLLATION"
    union all select * from collations
) c
order by priority limit 1 \gset
create table compressed_collation_ht(time timestamp, name text collate :"COLLATION",
    value float);
select create_hypertable('compressed_collation_ht', 'time');
WARNING:  column type "timestamp without time zone" used for "time" does not follow best practices
          create_hypertable           
--------------------------------------
 (1,public,compressed_collation_ht,t)

alter table compressed_collation_ht set (timescaledb.compress,
    timescaledb.compress_segmentby = 'name', timescaledb.compress_orderby = 'time');
insert into compressed_collation_ht values ('2021-01-01 01:01:01', 'á', '1'),
    ('2021-01-01 01:01:02', 'b', '2'), ('2021-01-01 01:01:03', 'ç', '2');
SELECT count(compress_chunk(ch)) FROM show_chunks('compressed_collation_ht') ch;
 count 
-------
     1

vacuum analyze compressed_collation_ht;
SELECT format('%I.%I',ch.schema_name, ch.table_name) AS "CHUNK"
FROM _timescaledb_catalog.hypertable ht
    INNER JOIN _timescaledb_catalog.chunk ch
    ON ch.hypertable_id = ht.compressed_hypertable_id
        AND ht.table_name = 'compressed_collation_ht' \gset
create index on :CHUNK (name);
set enable_seqscan to off;
explain (buffers off, costs off)
select * from compressed_collation_ht order by name;
--- QUERY PLAN ---
 Custom Scan (ColumnarScan) on _hyper_1_1_chunk
   ->  Index Scan using compress_hyper_2_2_chunk_name_idx on compress_hyper_2_2_chunk

select * from compressed_collation_ht order by name;
           time           | name | value 
--------------------------+------+-------
 Fri Jan 01 01:01:01 2021 | á    |     1
 Fri Jan 01 01:01:02 2021 | b    |     2
 Fri Jan 01 01:01:03 2021 | ç    |     2

reset enable_seqscan;
-- Test vectorized aggregation with collations. Need multiple chunks for partial
-- aggregation, which is where VectorAgg is used.
create table collation_agg(time int, name text collate :"COLLATION");
select create_hypertable('collation_agg', 'time', chunk_time_interval => 10);
     create_hypertable      
----------------------------
 (3,public,collation_agg,t)

alter table collation_agg set (timescaledb.compress, timescaledb.compress_orderby = 'time');
insert into collation_agg select x, case x % 3 when 0 then 'á' when 1 then 'b' else 'ç' end
from generate_series(1, 30) x;
select count(compress_chunk(ch)) from show_chunks('collation_agg') ch;
 count 
-------
     4

vacuum analyze collation_agg;
-- Vectorized aggregation is not used for non-C collations.
set timescaledb.debug_require_vector_agg = 'forbid';
set enable_sort = false;
select min(name), max(name) from collation_agg;
 min | max 
-----+-----
 á   | ç

reset enable_sort;
reset timescaledb.debug_require_vector_agg;
-- Vectorized aggregation is used when the column has C collation.
-- At the moment we don't support the 'min(name collate "C")' form that is
-- represented by CollateExpr node.
create table collation_agg_c(time int, name text collate "C");
select create_hypertable('collation_agg_c', 'time', chunk_time_interval => 10);
      create_hypertable       
------------------------------
 (5,public,collation_agg_c,t)

alter table collation_agg_c set (timescaledb.compress, timescaledb.compress_orderby = 'time');
insert into collation_agg_c select x, case x % 3 when 0 then 'á' when 1 then 'b' else 'ç' end
from generate_series(1, 30) x;
select count(compress_chunk(ch)) from show_chunks('collation_agg_c') ch;
 count 
-------
     4

vacuum analyze collation_agg_c;
set enable_sort = false;
set timescaledb.debug_require_vector_agg = 'require';
select min(name), max(name) from collation_agg_c;
 min | max 
-----+-----
 b   | ç

reset enable_sort;
reset timescaledb.debug_require_vector_agg;
