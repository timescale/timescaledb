-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- Need to be super user to create extension and add data nodes
\c :TEST_DBNAME :ROLE_SUPERUSER;
\ir include/remote_exec.sql
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
CREATE SCHEMA IF NOT EXISTS test;
psql:include/remote_exec.sql:5: NOTICE:  schema "test" already exists, skipping
GRANT USAGE ON SCHEMA test TO PUBLIC;
CREATE OR REPLACE FUNCTION test.remote_exec(srv_name name[], command text)
RETURNS VOID
AS :TSL_MODULE_PATHNAME, 'ts_remote_exec'
LANGUAGE C;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- Cleanup from other potential tests that created these databases
SET client_min_messages TO ERROR;
DROP DATABASE IF EXISTS data_node_1;
DROP DATABASE IF EXISTS data_node_2;
DROP DATABASE IF EXISTS data_node_3;
SET client_min_messages TO NOTICE;
\set TEST_TABLE 'conditions'
\ir 'include/aggregate_table_create.sql'
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- This file creates a table with a lot of different types to allow a range of aggregate functions.
-- This does not include the creation of a corresponding hypertable, as we may want to vary how that is done.
CREATE TYPE custom_type AS (high int, low int);
CREATE TABLE :TEST_TABLE (
      timec       TIMESTAMPTZ       NOT NULL,
      location    TEXT              NOT NULL,
      region      TEXT              NOT NULL,
      temperature DOUBLE PRECISION  NULL,
      humidity    DOUBLE PRECISION  NULL,
      lowp        double precision NULL,
      highp       double precision null,
      allnull     double precision null,
      highlow     custom_type null,
      bit_int     smallint,
      good_life   boolean
    );
-- Add data nodes using the TimescaleDB node management API
SELECT * FROM add_data_node('data_node_1',
                            database => 'data_node_1',
                            password => :'ROLE_DEFAULT_CLUSTER_USER_PASS',
                            bootstrap_user => :'ROLE_CLUSTER_SUPERUSER',
                            bootstrap_password => :'ROLE_CLUSTER_SUPERUSER_PASS');
NOTICE:  adding user mapping for "default_cluster_user" to connect to "data_node_1"
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_1 | localhost | 15432 | data_node_1 | t            | t                | t
(1 row)

SELECT * FROM add_data_node('data_node_2',
                            database => 'data_node_2',
                            password => :'ROLE_DEFAULT_CLUSTER_USER_PASS',
                            bootstrap_user => :'ROLE_CLUSTER_SUPERUSER',
                            bootstrap_password => :'ROLE_CLUSTER_SUPERUSER_PASS');
NOTICE:  adding user mapping for "default_cluster_user" to connect to "data_node_2"
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_2 | localhost | 15432 | data_node_2 | t            | t                | t
(1 row)

SELECT * FROM add_data_node('data_node_3',
                            database => 'data_node_3',
                            password => :'ROLE_DEFAULT_CLUSTER_USER_PASS',
                            bootstrap_user => :'ROLE_CLUSTER_SUPERUSER',
                            bootstrap_password => :'ROLE_CLUSTER_SUPERUSER_PASS');
NOTICE:  adding user mapping for "default_cluster_user" to connect to "data_node_3"
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_3 | localhost | 15432 | data_node_3 | t            | t                | t
(1 row)

SELECT * FROM test.remote_exec('{ data_node_1, data_node_2, data_node_3 }',
$$
       CREATE TYPE custom_type AS (high int, low int);
$$);
NOTICE:  [data_node_1]: 
       CREATE TYPE custom_type AS (high int, low int)
NOTICE:  [data_node_2]: 
       CREATE TYPE custom_type AS (high int, low int)
NOTICE:  [data_node_3]: 
       CREATE TYPE custom_type AS (high int, low int)
 remote_exec 
-------------
 
(1 row)

SELECT table_name FROM create_distributed_hypertable( 'conditions', 'timec', 'location', 3, chunk_time_interval => INTERVAL '1 day');
 table_name 
------------
 conditions
(1 row)

-- We need a lot of data and a lot of chunks to make the planner push down all of the aggregates
\ir 'include/aggregate_table_populate.sql'
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- This files assumes the existence of some table with definition as seen in the aggregate_table.sql file.
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'POR', 'west', generate_series(25, 85, 0.0625), 75, 40, 70, NULL, (1,2)::custom_type, 2, true;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'SFO', 'west', generate_series(25, 85, 0.0625), 75, 40, 70, NULL, (1,2)::custom_type, 2, true;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'SAC', 'west', generate_series(25, 85, 0.0625), 75, 40, 70, NULL, (1,2)::custom_type, 2, true;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'SEA', 'west', generate_series(25, 85, 0.0625), 75, 40, 70, NULL, (1,2)::custom_type, 2, true;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'TAC', 'west', generate_series(25, 85, 0.0625), 75, 40, 70, NULL, (1,2)::custom_type, 2, true;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'NYC', 'north-east', generate_series(29, 41, 0.0125), 45, 50, 40, NULL, (3,4)::custom_type, 4, false;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'BOS', 'north-east', generate_series(29, 41, 0.0125), 45, 50, 40, NULL, (3,4)::custom_type, 4, false;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'CHI', 'midwest', generate_series(29, 41, 0.0125), 45, 50, 40, NULL, (3,4)::custom_type, 4, false;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'MIN', 'midwest', generate_series(29, 41, 0.0125), 45, 50, 40, NULL, (3,4)::custom_type, 4, false;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'DET', 'midwest', generate_series(29, 41, 0.0125), 45, 50, 40, NULL, (3,4)::custom_type, 4, false;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'LA', 'west', generate_series(61, 85, 0.025), 55, NULL, 28, NULL, NULL, 8, true;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'SDG', 'west', generate_series(61, 85, 0.025), 55, NULL, 28, NULL, NULL, 8, true;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'PHX', 'west', generate_series(61, 85, 0.025), 55, NULL, 28, NULL, NULL, 8, true;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'DAL', 'south', generate_series(61, 85, 0.025), 55, NULL, 28, NULL, NULL, 8, true;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'AUS', 'south', generate_series(61, 85, 0.025), 55, NULL, 28, NULL, NULL, 8, true;
SET enable_partitionwise_aggregate = ON;
-- Run an explain on the aggregate queries to make sure expected aggregates are being pushed down.
-- Grouping by the paritioning column should result in full aggregate pushdown where possible,
-- while using a non-partitioning column should result in a partial pushdown
\set PREFIX 'EXPLAIN (VERBOSE, COSTS OFF)'
\set GROUPING 'location'
\ir 'include/aggregate_queries.sql'
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- This files assumes the existence of some table with definition as seen in the aggregate_table.sql file.
-- All of these should be able to be pushed down if enabled
:PREFIX SELECT :GROUPING,
   min(allnull) as min_allnull,
   max(temperature) as max_temp,
   sum(temperature)+sum(humidity) as agg_sum_expr,
   avg(humidity),
   ROUND( CAST(stddev(humidity) AS NUMERIC), 5),
   bit_and(bit_int),
   bit_or(bit_int),
   bool_and(good_life),
   every(temperature > 0),
   bool_or(good_life),
   count(*) as count_rows,
   count(temperature) as count_temp,
   count(allnull) as count_zero,
   ROUND( CAST(corr(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(covar_pop(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(covar_samp(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(regr_avgx(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(regr_avgy(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(regr_count(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(regr_intercept(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(regr_r2(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(regr_slope(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(regr_sxx(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(regr_sxy(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(regr_syy(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(stddev(temperature) AS NUMERIC), 5) as stddev_temp,
   ROUND( CAST(stddev_pop(temperature) AS NUMERIC), 5),
   ROUND( CAST(stddev_samp(temperature) AS NUMERIC), 5),
   ROUND( CAST(variance(temperature) AS NUMERIC), 5),
   ROUND( CAST(var_pop(temperature) AS NUMERIC), 5),
   ROUND( CAST(var_samp(temperature) AS NUMERIC), 5),
   last(temperature, timec) as last_temp,
   histogram(temperature, 0, 100, 5)
  FROM :TEST_TABLE
  GROUP BY :GROUPING
  ORDER BY :GROUPING;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: conditions.location, (min(conditions.allnull)), (max(conditions.temperature)), ((sum(conditions.temperature) + sum(conditions.humidity))), (avg(conditions.humidity)), (round((stddev(conditions.humidity))::numeric, 5)), (bit_and(conditions.bit_int)), (bit_or(conditions.bit_int)), (bool_and(conditions.good_life)), (every((conditions.temperature > '0'::double precision))), (bool_or(conditions.good_life)), (count(*)), (count(conditions.temperature)), (count(conditions.allnull)), (round((corr(conditions.temperature, conditions.humidity))::numeric, 5)), (round((covar_pop(conditions.temperature, conditions.humidity))::numeric, 5)), (round((covar_samp(conditions.temperature, conditions.humidity))::numeric, 5)), (round((regr_avgx(conditions.temperature, conditions.humidity))::numeric, 5)), (round((regr_avgy(conditions.temperature, conditions.humidity))::numeric, 5)), (round((regr_count(conditions.temperature, conditions.humidity))::numeric, 5)), (round((regr_intercept(conditions.temperature, conditions.humidity))::numeric, 5)), (round((regr_r2(conditions.temperature, conditions.humidity))::numeric, 5)), (round((regr_slope(conditions.temperature, conditions.humidity))::numeric, 5)), (round((regr_sxx(conditions.temperature, conditions.humidity))::numeric, 5)), (round((regr_sxy(conditions.temperature, conditions.humidity))::numeric, 5)), (round((regr_syy(conditions.temperature, conditions.humidity))::numeric, 5)), (round((stddev(conditions.temperature))::numeric, 5)), (round((stddev_pop(conditions.temperature))::numeric, 5)), (round((stddev_samp(conditions.temperature))::numeric, 5)), (round((variance(conditions.temperature))::numeric, 5)), (round((var_pop(conditions.temperature))::numeric, 5)), (round((var_samp(conditions.temperature))::numeric, 5)), (last(conditions.temperature, conditions.timec)), (histogram(conditions.temperature, '0'::double precision, '100'::double precision, 5))
   Sort Key: conditions.location
   ->  Append
         ->  Custom Scan (ServerScan)
               Output: conditions.location, (min(conditions.allnull)), (max(conditions.temperature)), ((sum(conditions.temperature) + sum(conditions.humidity))), (avg(conditions.humidity)), (round((stddev(conditions.humidity))::numeric, 5)), (bit_and(conditions.bit_int)), (bit_or(conditions.bit_int)), (bool_and(conditions.good_life)), (every((conditions.temperature > '0'::double precision))), (bool_or(conditions.good_life)), (count(*)), (count(conditions.temperature)), (count(conditions.allnull)), (round((corr(conditions.temperature, conditions.humidity))::numeric, 5)), (round((covar_pop(conditions.temperature, conditions.humidity))::numeric, 5)), (round((covar_samp(conditions.temperature, conditions.humidity))::numeric, 5)), (round((regr_avgx(conditions.temperature, conditions.humidity))::numeric, 5)), (round((regr_avgy(conditions.temperature, conditions.humidity))::numeric, 5)), (round((regr_count(conditions.temperature, conditions.humidity))::numeric, 5)), (round((regr_intercept(conditions.temperature, conditions.humidity))::numeric, 5)), (round((regr_r2(conditions.temperature, conditions.humidity))::numeric, 5)), (round((regr_slope(conditions.temperature, conditions.humidity))::numeric, 5)), (round((regr_sxx(conditions.temperature, conditions.humidity))::numeric, 5)), (round((regr_sxy(conditions.temperature, conditions.humidity))::numeric, 5)), (round((regr_syy(conditions.temperature, conditions.humidity))::numeric, 5)), (round((stddev(conditions.temperature))::numeric, 5)), (round((stddev_pop(conditions.temperature))::numeric, 5)), (round((stddev_samp(conditions.temperature))::numeric, 5)), (round((variance(conditions.temperature))::numeric, 5)), (round((var_pop(conditions.temperature))::numeric, 5)), (round((var_samp(conditions.temperature))::numeric, 5)), (last(conditions.temperature, conditions.timec)), (histogram(conditions.temperature, '0'::double precision, '100'::double precision, 5))
               Relations: Aggregate on (public.conditions)
               Data node: data_node_1
               Chunks: _hyper_1_1_dist_chunk, _hyper_1_2_dist_chunk, _hyper_1_3_dist_chunk, _hyper_1_4_dist_chunk
               Remote SQL: SELECT location, min(allnull), max(temperature), (sum(temperature) + sum(humidity)), avg(humidity), round(stddev(humidity)::numeric, 5), bit_and(bit_int), bit_or(bit_int), bool_and(good_life), every((temperature > 0::double precision)), bool_or(good_life), count(*), count(temperature), count(allnull), round(corr(temperature, humidity)::numeric, 5), round(covar_pop(temperature, humidity)::numeric, 5), round(covar_samp(temperature, humidity)::numeric, 5), round(regr_avgx(temperature, humidity)::numeric, 5), round(regr_avgy(temperature, humidity)::numeric, 5), round(regr_count(temperature, humidity)::numeric, 5), round(regr_intercept(temperature, humidity)::numeric, 5), round(regr_r2(temperature, humidity)::numeric, 5), round(regr_slope(temperature, humidity)::numeric, 5), round(regr_sxx(temperature, humidity)::numeric, 5), round(regr_sxy(temperature, humidity)::numeric, 5), round(regr_syy(temperature, humidity)::numeric, 5), round(stddev(temperature)::numeric, 5), round(stddev_pop(temperature)::numeric, 5), round(stddev_samp(temperature)::numeric, 5), round(variance(temperature)::numeric, 5), round(var_pop(temperature)::numeric, 5), round(var_samp(temperature)::numeric, 5), public.last(temperature, timec), public.histogram(temperature, 0::double precision, 100::double precision, 5) FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) GROUP BY 1
         ->  Custom Scan (ServerScan)
               Output: conditions_1.location, (min(conditions_1.allnull)), (max(conditions_1.temperature)), ((sum(conditions_1.temperature) + sum(conditions_1.humidity))), (avg(conditions_1.humidity)), (round((stddev(conditions_1.humidity))::numeric, 5)), (bit_and(conditions_1.bit_int)), (bit_or(conditions_1.bit_int)), (bool_and(conditions_1.good_life)), (every((conditions_1.temperature > '0'::double precision))), (bool_or(conditions_1.good_life)), (count(*)), (count(conditions_1.temperature)), (count(conditions_1.allnull)), (round((corr(conditions_1.temperature, conditions_1.humidity))::numeric, 5)), (round((covar_pop(conditions_1.temperature, conditions_1.humidity))::numeric, 5)), (round((covar_samp(conditions_1.temperature, conditions_1.humidity))::numeric, 5)), (round((regr_avgx(conditions_1.temperature, conditions_1.humidity))::numeric, 5)), (round((regr_avgy(conditions_1.temperature, conditions_1.humidity))::numeric, 5)), (round((regr_count(conditions_1.temperature, conditions_1.humidity))::numeric, 5)), (round((regr_intercept(conditions_1.temperature, conditions_1.humidity))::numeric, 5)), (round((regr_r2(conditions_1.temperature, conditions_1.humidity))::numeric, 5)), (round((regr_slope(conditions_1.temperature, conditions_1.humidity))::numeric, 5)), (round((regr_sxx(conditions_1.temperature, conditions_1.humidity))::numeric, 5)), (round((regr_sxy(conditions_1.temperature, conditions_1.humidity))::numeric, 5)), (round((regr_syy(conditions_1.temperature, conditions_1.humidity))::numeric, 5)), (round((stddev(conditions_1.temperature))::numeric, 5)), (round((stddev_pop(conditions_1.temperature))::numeric, 5)), (round((stddev_samp(conditions_1.temperature))::numeric, 5)), (round((variance(conditions_1.temperature))::numeric, 5)), (round((var_pop(conditions_1.temperature))::numeric, 5)), (round((var_samp(conditions_1.temperature))::numeric, 5)), (last(conditions_1.temperature, conditions_1.timec)), (histogram(conditions_1.temperature, '0'::double precision, '100'::double precision, 5))
               Relations: Aggregate on (public.conditions)
               Data node: data_node_2
               Chunks: _hyper_1_9_dist_chunk, _hyper_1_10_dist_chunk, _hyper_1_11_dist_chunk, _hyper_1_12_dist_chunk
               Remote SQL: SELECT location, min(allnull), max(temperature), (sum(temperature) + sum(humidity)), avg(humidity), round(stddev(humidity)::numeric, 5), bit_and(bit_int), bit_or(bit_int), bool_and(good_life), every((temperature > 0::double precision)), bool_or(good_life), count(*), count(temperature), count(allnull), round(corr(temperature, humidity)::numeric, 5), round(covar_pop(temperature, humidity)::numeric, 5), round(covar_samp(temperature, humidity)::numeric, 5), round(regr_avgx(temperature, humidity)::numeric, 5), round(regr_avgy(temperature, humidity)::numeric, 5), round(regr_count(temperature, humidity)::numeric, 5), round(regr_intercept(temperature, humidity)::numeric, 5), round(regr_r2(temperature, humidity)::numeric, 5), round(regr_slope(temperature, humidity)::numeric, 5), round(regr_sxx(temperature, humidity)::numeric, 5), round(regr_sxy(temperature, humidity)::numeric, 5), round(regr_syy(temperature, humidity)::numeric, 5), round(stddev(temperature)::numeric, 5), round(stddev_pop(temperature)::numeric, 5), round(stddev_samp(temperature)::numeric, 5), round(variance(temperature)::numeric, 5), round(var_pop(temperature)::numeric, 5), round(var_samp(temperature)::numeric, 5), public.last(temperature, timec), public.histogram(temperature, 0::double precision, 100::double precision, 5) FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) GROUP BY 1
         ->  Custom Scan (ServerScan)
               Output: conditions_2.location, (min(conditions_2.allnull)), (max(conditions_2.temperature)), ((sum(conditions_2.temperature) + sum(conditions_2.humidity))), (avg(conditions_2.humidity)), (round((stddev(conditions_2.humidity))::numeric, 5)), (bit_and(conditions_2.bit_int)), (bit_or(conditions_2.bit_int)), (bool_and(conditions_2.good_life)), (every((conditions_2.temperature > '0'::double precision))), (bool_or(conditions_2.good_life)), (count(*)), (count(conditions_2.temperature)), (count(conditions_2.allnull)), (round((corr(conditions_2.temperature, conditions_2.humidity))::numeric, 5)), (round((covar_pop(conditions_2.temperature, conditions_2.humidity))::numeric, 5)), (round((covar_samp(conditions_2.temperature, conditions_2.humidity))::numeric, 5)), (round((regr_avgx(conditions_2.temperature, conditions_2.humidity))::numeric, 5)), (round((regr_avgy(conditions_2.temperature, conditions_2.humidity))::numeric, 5)), (round((regr_count(conditions_2.temperature, conditions_2.humidity))::numeric, 5)), (round((regr_intercept(conditions_2.temperature, conditions_2.humidity))::numeric, 5)), (round((regr_r2(conditions_2.temperature, conditions_2.humidity))::numeric, 5)), (round((regr_slope(conditions_2.temperature, conditions_2.humidity))::numeric, 5)), (round((regr_sxx(conditions_2.temperature, conditions_2.humidity))::numeric, 5)), (round((regr_sxy(conditions_2.temperature, conditions_2.humidity))::numeric, 5)), (round((regr_syy(conditions_2.temperature, conditions_2.humidity))::numeric, 5)), (round((stddev(conditions_2.temperature))::numeric, 5)), (round((stddev_pop(conditions_2.temperature))::numeric, 5)), (round((stddev_samp(conditions_2.temperature))::numeric, 5)), (round((variance(conditions_2.temperature))::numeric, 5)), (round((var_pop(conditions_2.temperature))::numeric, 5)), (round((var_samp(conditions_2.temperature))::numeric, 5)), (last(conditions_2.temperature, conditions_2.timec)), (histogram(conditions_2.temperature, '0'::double precision, '100'::double precision, 5))
               Relations: Aggregate on (public.conditions)
               Data node: data_node_3
               Chunks: _hyper_1_5_dist_chunk, _hyper_1_6_dist_chunk, _hyper_1_7_dist_chunk, _hyper_1_8_dist_chunk
               Remote SQL: SELECT location, min(allnull), max(temperature), (sum(temperature) + sum(humidity)), avg(humidity), round(stddev(humidity)::numeric, 5), bit_and(bit_int), bit_or(bit_int), bool_and(good_life), every((temperature > 0::double precision)), bool_or(good_life), count(*), count(temperature), count(allnull), round(corr(temperature, humidity)::numeric, 5), round(covar_pop(temperature, humidity)::numeric, 5), round(covar_samp(temperature, humidity)::numeric, 5), round(regr_avgx(temperature, humidity)::numeric, 5), round(regr_avgy(temperature, humidity)::numeric, 5), round(regr_count(temperature, humidity)::numeric, 5), round(regr_intercept(temperature, humidity)::numeric, 5), round(regr_r2(temperature, humidity)::numeric, 5), round(regr_slope(temperature, humidity)::numeric, 5), round(regr_sxx(temperature, humidity)::numeric, 5), round(regr_sxy(temperature, humidity)::numeric, 5), round(regr_syy(temperature, humidity)::numeric, 5), round(stddev(temperature)::numeric, 5), round(stddev_pop(temperature)::numeric, 5), round(stddev_samp(temperature)::numeric, 5), round(variance(temperature)::numeric, 5), round(var_pop(temperature)::numeric, 5), round(var_samp(temperature)::numeric, 5), public.last(temperature, timec), public.histogram(temperature, 0::double precision, 100::double precision, 5) FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) GROUP BY 1
(22 rows)

-- Aggregates on custom types are not yet pushed down
:PREFIX SELECT :GROUPING,
   last(highlow, timec) as last_hl,
   first(highlow, timec) as first_hl
  FROM :TEST_TABLE
  GROUP BY :GROUPING
  ORDER BY :GROUPING;
                                                                                       QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Append
   Sort Key: conditions.location
   ->  GroupAggregate
         Output: conditions.location, last(conditions.highlow, conditions.timec), first(conditions.highlow, conditions.timec)
         Group Key: conditions.location
         ->  Custom Scan (ServerScan) on public.conditions
               Output: conditions.location, conditions.highlow, conditions.timec
               Data node: data_node_1
               Chunks: _hyper_1_1_dist_chunk, _hyper_1_2_dist_chunk, _hyper_1_3_dist_chunk, _hyper_1_4_dist_chunk
               Remote SQL: SELECT timec, location, highlow FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) ORDER BY location ASC NULLS LAST
   ->  GroupAggregate
         Output: conditions_1.location, last(conditions_1.highlow, conditions_1.timec), first(conditions_1.highlow, conditions_1.timec)
         Group Key: conditions_1.location
         ->  Custom Scan (ServerScan) on public.conditions conditions_1
               Output: conditions_1.location, conditions_1.highlow, conditions_1.timec
               Data node: data_node_2
               Chunks: _hyper_1_9_dist_chunk, _hyper_1_10_dist_chunk, _hyper_1_11_dist_chunk, _hyper_1_12_dist_chunk
               Remote SQL: SELECT timec, location, highlow FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) ORDER BY location ASC NULLS LAST
   ->  GroupAggregate
         Output: conditions_2.location, last(conditions_2.highlow, conditions_2.timec), first(conditions_2.highlow, conditions_2.timec)
         Group Key: conditions_2.location
         ->  Custom Scan (ServerScan) on public.conditions conditions_2
               Output: conditions_2.location, conditions_2.highlow, conditions_2.timec
               Data node: data_node_3
               Chunks: _hyper_1_5_dist_chunk, _hyper_1_6_dist_chunk, _hyper_1_7_dist_chunk, _hyper_1_8_dist_chunk
               Remote SQL: SELECT timec, location, highlow FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) ORDER BY location ASC NULLS LAST
(26 rows)

-- Mix of aggregates that push down and those that don't
:PREFIX SELECT :GROUPING,
   min(allnull) as min_allnull,
   max(temperature) as max_temp,
   sum(temperature)+sum(humidity) as agg_sum_expr,
   avg(humidity),
   ROUND( CAST(stddev(humidity) AS NUMERIC), 5),
   bit_and(bit_int),
   bit_or(bit_int),
   bool_and(good_life),
   every(temperature > 0),
   bool_or(good_life),
   first(highlow, timec) as first_hl
  FROM :TEST_TABLE
  GROUP BY :GROUPING
  ORDER BY :GROUPING;
                                                                                                                                                                                                                                        QUERY PLAN                                                                                                                                                                                                                                         
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Append
   Sort Key: conditions.location
   ->  GroupAggregate
         Output: conditions.location, min(conditions.allnull), max(conditions.temperature), (sum(conditions.temperature) + sum(conditions.humidity)), avg(conditions.humidity), round((stddev(conditions.humidity))::numeric, 5), bit_and(conditions.bit_int), bit_or(conditions.bit_int), bool_and(conditions.good_life), every((conditions.temperature > '0'::double precision)), bool_or(conditions.good_life), first(conditions.highlow, conditions.timec)
         Group Key: conditions.location
         ->  Custom Scan (ServerScan) on public.conditions
               Output: conditions.location, conditions.allnull, conditions.temperature, conditions.humidity, conditions.bit_int, conditions.good_life, conditions.highlow, conditions.timec
               Data node: data_node_1
               Chunks: _hyper_1_1_dist_chunk, _hyper_1_2_dist_chunk, _hyper_1_3_dist_chunk, _hyper_1_4_dist_chunk
               Remote SQL: SELECT timec, location, temperature, humidity, allnull, highlow, bit_int, good_life FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) ORDER BY location ASC NULLS LAST
   ->  GroupAggregate
         Output: conditions_1.location, min(conditions_1.allnull), max(conditions_1.temperature), (sum(conditions_1.temperature) + sum(conditions_1.humidity)), avg(conditions_1.humidity), round((stddev(conditions_1.humidity))::numeric, 5), bit_and(conditions_1.bit_int), bit_or(conditions_1.bit_int), bool_and(conditions_1.good_life), every((conditions_1.temperature > '0'::double precision)), bool_or(conditions_1.good_life), first(conditions_1.highlow, conditions_1.timec)
         Group Key: conditions_1.location
         ->  Custom Scan (ServerScan) on public.conditions conditions_1
               Output: conditions_1.location, conditions_1.allnull, conditions_1.temperature, conditions_1.humidity, conditions_1.bit_int, conditions_1.good_life, conditions_1.highlow, conditions_1.timec
               Data node: data_node_2
               Chunks: _hyper_1_9_dist_chunk, _hyper_1_10_dist_chunk, _hyper_1_11_dist_chunk, _hyper_1_12_dist_chunk
               Remote SQL: SELECT timec, location, temperature, humidity, allnull, highlow, bit_int, good_life FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) ORDER BY location ASC NULLS LAST
   ->  GroupAggregate
         Output: conditions_2.location, min(conditions_2.allnull), max(conditions_2.temperature), (sum(conditions_2.temperature) + sum(conditions_2.humidity)), avg(conditions_2.humidity), round((stddev(conditions_2.humidity))::numeric, 5), bit_and(conditions_2.bit_int), bit_or(conditions_2.bit_int), bool_and(conditions_2.good_life), every((conditions_2.temperature > '0'::double precision)), bool_or(conditions_2.good_life), first(conditions_2.highlow, conditions_2.timec)
         Group Key: conditions_2.location
         ->  Custom Scan (ServerScan) on public.conditions conditions_2
               Output: conditions_2.location, conditions_2.allnull, conditions_2.temperature, conditions_2.humidity, conditions_2.bit_int, conditions_2.good_life, conditions_2.highlow, conditions_2.timec
               Data node: data_node_3
               Chunks: _hyper_1_5_dist_chunk, _hyper_1_6_dist_chunk, _hyper_1_7_dist_chunk, _hyper_1_8_dist_chunk
               Remote SQL: SELECT timec, location, temperature, humidity, allnull, highlow, bit_int, good_life FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) ORDER BY location ASC NULLS LAST
(26 rows)

\set GROUPING 'region'
\ir 'include/aggregate_queries.sql'
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- This files assumes the existence of some table with definition as seen in the aggregate_table.sql file.
-- All of these should be able to be pushed down if enabled
:PREFIX SELECT :GROUPING,
   min(allnull) as min_allnull,
   max(temperature) as max_temp,
   sum(temperature)+sum(humidity) as agg_sum_expr,
   avg(humidity),
   ROUND( CAST(stddev(humidity) AS NUMERIC), 5),
   bit_and(bit_int),
   bit_or(bit_int),
   bool_and(good_life),
   every(temperature > 0),
   bool_or(good_life),
   count(*) as count_rows,
   count(temperature) as count_temp,
   count(allnull) as count_zero,
   ROUND( CAST(corr(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(covar_pop(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(covar_samp(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(regr_avgx(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(regr_avgy(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(regr_count(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(regr_intercept(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(regr_r2(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(regr_slope(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(regr_sxx(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(regr_sxy(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(regr_syy(temperature, humidity) AS NUMERIC), 5),
   ROUND( CAST(stddev(temperature) AS NUMERIC), 5) as stddev_temp,
   ROUND( CAST(stddev_pop(temperature) AS NUMERIC), 5),
   ROUND( CAST(stddev_samp(temperature) AS NUMERIC), 5),
   ROUND( CAST(variance(temperature) AS NUMERIC), 5),
   ROUND( CAST(var_pop(temperature) AS NUMERIC), 5),
   ROUND( CAST(var_samp(temperature) AS NUMERIC), 5),
   last(temperature, timec) as last_temp,
   histogram(temperature, 0, 100, 5)
  FROM :TEST_TABLE
  GROUP BY :GROUPING
  ORDER BY :GROUPING;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Finalize GroupAggregate
   Output: conditions.region, min(conditions.allnull), max(conditions.temperature), (sum(conditions.temperature) + sum(conditions.humidity)), avg(conditions.humidity), round((stddev(conditions.humidity))::numeric, 5), bit_and(conditions.bit_int), bit_or(conditions.bit_int), bool_and(conditions.good_life), every((conditions.temperature > '0'::double precision)), bool_or(conditions.good_life), count(*), count(conditions.temperature), count(conditions.allnull), round((corr(conditions.temperature, conditions.humidity))::numeric, 5), round((covar_pop(conditions.temperature, conditions.humidity))::numeric, 5), round((covar_samp(conditions.temperature, conditions.humidity))::numeric, 5), round((regr_avgx(conditions.temperature, conditions.humidity))::numeric, 5), round((regr_avgy(conditions.temperature, conditions.humidity))::numeric, 5), round((regr_count(conditions.temperature, conditions.humidity))::numeric, 5), round((regr_intercept(conditions.temperature, conditions.humidity))::numeric, 5), round((regr_r2(conditions.temperature, conditions.humidity))::numeric, 5), round((regr_slope(conditions.temperature, conditions.humidity))::numeric, 5), round((regr_sxx(conditions.temperature, conditions.humidity))::numeric, 5), round((regr_sxy(conditions.temperature, conditions.humidity))::numeric, 5), round((regr_syy(conditions.temperature, conditions.humidity))::numeric, 5), round((stddev(conditions.temperature))::numeric, 5), round((stddev_pop(conditions.temperature))::numeric, 5), round((stddev_samp(conditions.temperature))::numeric, 5), round((variance(conditions.temperature))::numeric, 5), round((var_pop(conditions.temperature))::numeric, 5), round((var_samp(conditions.temperature))::numeric, 5), last(conditions.temperature, conditions.timec), histogram(conditions.temperature, '0'::double precision, '100'::double precision, 5)
   Group Key: conditions.region
   ->  Merge Append
         Sort Key: conditions.region
         ->  Custom Scan (ServerScan)
               Output: conditions.region, (PARTIAL min(conditions.allnull)), (PARTIAL max(conditions.temperature)), (PARTIAL sum(conditions.temperature)), (PARTIAL sum(conditions.humidity)), (PARTIAL avg(conditions.humidity)), (PARTIAL stddev(conditions.humidity)), (PARTIAL bit_and(conditions.bit_int)), (PARTIAL bit_or(conditions.bit_int)), (PARTIAL bool_and(conditions.good_life)), (PARTIAL every((conditions.temperature > '0'::double precision))), (PARTIAL bool_or(conditions.good_life)), (PARTIAL count(*)), (PARTIAL count(conditions.temperature)), (PARTIAL count(conditions.allnull)), (PARTIAL corr(conditions.temperature, conditions.humidity)), (PARTIAL covar_pop(conditions.temperature, conditions.humidity)), (PARTIAL covar_samp(conditions.temperature, conditions.humidity)), (PARTIAL regr_avgx(conditions.temperature, conditions.humidity)), (PARTIAL regr_avgy(conditions.temperature, conditions.humidity)), (PARTIAL regr_count(conditions.temperature, conditions.humidity)), (PARTIAL regr_intercept(conditions.temperature, conditions.humidity)), (PARTIAL regr_r2(conditions.temperature, conditions.humidity)), (PARTIAL regr_slope(conditions.temperature, conditions.humidity)), (PARTIAL regr_sxx(conditions.temperature, conditions.humidity)), (PARTIAL regr_sxy(conditions.temperature, conditions.humidity)), (PARTIAL regr_syy(conditions.temperature, conditions.humidity)), (PARTIAL stddev(conditions.temperature)), (PARTIAL stddev_pop(conditions.temperature)), (PARTIAL stddev_samp(conditions.temperature)), (PARTIAL variance(conditions.temperature)), (PARTIAL var_pop(conditions.temperature)), (PARTIAL var_samp(conditions.temperature)), (PARTIAL last(conditions.temperature, conditions.timec)), (PARTIAL histogram(conditions.temperature, '0'::double precision, '100'::double precision, 5))
               Relations: Aggregate on (public.conditions)
               Data node: data_node_1
               Chunks: _hyper_1_1_dist_chunk, _hyper_1_2_dist_chunk, _hyper_1_3_dist_chunk, _hyper_1_4_dist_chunk
               Remote SQL: SELECT region, _timescaledb_internal.partialize_agg(min(allnull)), _timescaledb_internal.partialize_agg(max(temperature)), _timescaledb_internal.partialize_agg(sum(temperature)), _timescaledb_internal.partialize_agg(sum(humidity)), _timescaledb_internal.partialize_agg(avg(humidity)), _timescaledb_internal.partialize_agg(stddev(humidity)), _timescaledb_internal.partialize_agg(bit_and(bit_int)), _timescaledb_internal.partialize_agg(bit_or(bit_int)), _timescaledb_internal.partialize_agg(bool_and(good_life)), _timescaledb_internal.partialize_agg(every((temperature > 0::double precision))), _timescaledb_internal.partialize_agg(bool_or(good_life)), _timescaledb_internal.partialize_agg(count(*)), _timescaledb_internal.partialize_agg(count(temperature)), _timescaledb_internal.partialize_agg(count(allnull)), _timescaledb_internal.partialize_agg(corr(temperature, humidity)), _timescaledb_internal.partialize_agg(covar_pop(temperature, humidity)), _timescaledb_internal.partialize_agg(covar_samp(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_avgx(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_avgy(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_count(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_intercept(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_r2(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_slope(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_sxx(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_sxy(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_syy(temperature, humidity)), _timescaledb_internal.partialize_agg(stddev(temperature)), _timescaledb_internal.partialize_agg(stddev_pop(temperature)), _timescaledb_internal.partialize_agg(stddev_samp(temperature)), _timescaledb_internal.partialize_agg(variance(temperature)), _timescaledb_internal.partialize_agg(var_pop(temperature)), _timescaledb_internal.partialize_agg(var_samp(temperature)), _timescaledb_internal.partialize_agg(public.last(temperature, timec)), _timescaledb_internal.partialize_agg(public.histogram(temperature, 0::double precision, 100::double precision, 5)) FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) GROUP BY 1 ORDER BY region ASC NULLS LAST
         ->  Custom Scan (ServerScan)
               Output: conditions_1.region, (PARTIAL min(conditions_1.allnull)), (PARTIAL max(conditions_1.temperature)), (PARTIAL sum(conditions_1.temperature)), (PARTIAL sum(conditions_1.humidity)), (PARTIAL avg(conditions_1.humidity)), (PARTIAL stddev(conditions_1.humidity)), (PARTIAL bit_and(conditions_1.bit_int)), (PARTIAL bit_or(conditions_1.bit_int)), (PARTIAL bool_and(conditions_1.good_life)), (PARTIAL every((conditions_1.temperature > '0'::double precision))), (PARTIAL bool_or(conditions_1.good_life)), (PARTIAL count(*)), (PARTIAL count(conditions_1.temperature)), (PARTIAL count(conditions_1.allnull)), (PARTIAL corr(conditions_1.temperature, conditions_1.humidity)), (PARTIAL covar_pop(conditions_1.temperature, conditions_1.humidity)), (PARTIAL covar_samp(conditions_1.temperature, conditions_1.humidity)), (PARTIAL regr_avgx(conditions_1.temperature, conditions_1.humidity)), (PARTIAL regr_avgy(conditions_1.temperature, conditions_1.humidity)), (PARTIAL regr_count(conditions_1.temperature, conditions_1.humidity)), (PARTIAL regr_intercept(conditions_1.temperature, conditions_1.humidity)), (PARTIAL regr_r2(conditions_1.temperature, conditions_1.humidity)), (PARTIAL regr_slope(conditions_1.temperature, conditions_1.humidity)), (PARTIAL regr_sxx(conditions_1.temperature, conditions_1.humidity)), (PARTIAL regr_sxy(conditions_1.temperature, conditions_1.humidity)), (PARTIAL regr_syy(conditions_1.temperature, conditions_1.humidity)), (PARTIAL stddev(conditions_1.temperature)), (PARTIAL stddev_pop(conditions_1.temperature)), (PARTIAL stddev_samp(conditions_1.temperature)), (PARTIAL variance(conditions_1.temperature)), (PARTIAL var_pop(conditions_1.temperature)), (PARTIAL var_samp(conditions_1.temperature)), (PARTIAL last(conditions_1.temperature, conditions_1.timec)), (PARTIAL histogram(conditions_1.temperature, '0'::double precision, '100'::double precision, 5))
               Relations: Aggregate on (public.conditions)
               Data node: data_node_2
               Chunks: _hyper_1_9_dist_chunk, _hyper_1_10_dist_chunk, _hyper_1_11_dist_chunk, _hyper_1_12_dist_chunk
               Remote SQL: SELECT region, _timescaledb_internal.partialize_agg(min(allnull)), _timescaledb_internal.partialize_agg(max(temperature)), _timescaledb_internal.partialize_agg(sum(temperature)), _timescaledb_internal.partialize_agg(sum(humidity)), _timescaledb_internal.partialize_agg(avg(humidity)), _timescaledb_internal.partialize_agg(stddev(humidity)), _timescaledb_internal.partialize_agg(bit_and(bit_int)), _timescaledb_internal.partialize_agg(bit_or(bit_int)), _timescaledb_internal.partialize_agg(bool_and(good_life)), _timescaledb_internal.partialize_agg(every((temperature > 0::double precision))), _timescaledb_internal.partialize_agg(bool_or(good_life)), _timescaledb_internal.partialize_agg(count(*)), _timescaledb_internal.partialize_agg(count(temperature)), _timescaledb_internal.partialize_agg(count(allnull)), _timescaledb_internal.partialize_agg(corr(temperature, humidity)), _timescaledb_internal.partialize_agg(covar_pop(temperature, humidity)), _timescaledb_internal.partialize_agg(covar_samp(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_avgx(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_avgy(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_count(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_intercept(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_r2(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_slope(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_sxx(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_sxy(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_syy(temperature, humidity)), _timescaledb_internal.partialize_agg(stddev(temperature)), _timescaledb_internal.partialize_agg(stddev_pop(temperature)), _timescaledb_internal.partialize_agg(stddev_samp(temperature)), _timescaledb_internal.partialize_agg(variance(temperature)), _timescaledb_internal.partialize_agg(var_pop(temperature)), _timescaledb_internal.partialize_agg(var_samp(temperature)), _timescaledb_internal.partialize_agg(public.last(temperature, timec)), _timescaledb_internal.partialize_agg(public.histogram(temperature, 0::double precision, 100::double precision, 5)) FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) GROUP BY 1 ORDER BY region ASC NULLS LAST
         ->  Custom Scan (ServerScan)
               Output: conditions_2.region, (PARTIAL min(conditions_2.allnull)), (PARTIAL max(conditions_2.temperature)), (PARTIAL sum(conditions_2.temperature)), (PARTIAL sum(conditions_2.humidity)), (PARTIAL avg(conditions_2.humidity)), (PARTIAL stddev(conditions_2.humidity)), (PARTIAL bit_and(conditions_2.bit_int)), (PARTIAL bit_or(conditions_2.bit_int)), (PARTIAL bool_and(conditions_2.good_life)), (PARTIAL every((conditions_2.temperature > '0'::double precision))), (PARTIAL bool_or(conditions_2.good_life)), (PARTIAL count(*)), (PARTIAL count(conditions_2.temperature)), (PARTIAL count(conditions_2.allnull)), (PARTIAL corr(conditions_2.temperature, conditions_2.humidity)), (PARTIAL covar_pop(conditions_2.temperature, conditions_2.humidity)), (PARTIAL covar_samp(conditions_2.temperature, conditions_2.humidity)), (PARTIAL regr_avgx(conditions_2.temperature, conditions_2.humidity)), (PARTIAL regr_avgy(conditions_2.temperature, conditions_2.humidity)), (PARTIAL regr_count(conditions_2.temperature, conditions_2.humidity)), (PARTIAL regr_intercept(conditions_2.temperature, conditions_2.humidity)), (PARTIAL regr_r2(conditions_2.temperature, conditions_2.humidity)), (PARTIAL regr_slope(conditions_2.temperature, conditions_2.humidity)), (PARTIAL regr_sxx(conditions_2.temperature, conditions_2.humidity)), (PARTIAL regr_sxy(conditions_2.temperature, conditions_2.humidity)), (PARTIAL regr_syy(conditions_2.temperature, conditions_2.humidity)), (PARTIAL stddev(conditions_2.temperature)), (PARTIAL stddev_pop(conditions_2.temperature)), (PARTIAL stddev_samp(conditions_2.temperature)), (PARTIAL variance(conditions_2.temperature)), (PARTIAL var_pop(conditions_2.temperature)), (PARTIAL var_samp(conditions_2.temperature)), (PARTIAL last(conditions_2.temperature, conditions_2.timec)), (PARTIAL histogram(conditions_2.temperature, '0'::double precision, '100'::double precision, 5))
               Relations: Aggregate on (public.conditions)
               Data node: data_node_3
               Chunks: _hyper_1_5_dist_chunk, _hyper_1_6_dist_chunk, _hyper_1_7_dist_chunk, _hyper_1_8_dist_chunk
               Remote SQL: SELECT region, _timescaledb_internal.partialize_agg(min(allnull)), _timescaledb_internal.partialize_agg(max(temperature)), _timescaledb_internal.partialize_agg(sum(temperature)), _timescaledb_internal.partialize_agg(sum(humidity)), _timescaledb_internal.partialize_agg(avg(humidity)), _timescaledb_internal.partialize_agg(stddev(humidity)), _timescaledb_internal.partialize_agg(bit_and(bit_int)), _timescaledb_internal.partialize_agg(bit_or(bit_int)), _timescaledb_internal.partialize_agg(bool_and(good_life)), _timescaledb_internal.partialize_agg(every((temperature > 0::double precision))), _timescaledb_internal.partialize_agg(bool_or(good_life)), _timescaledb_internal.partialize_agg(count(*)), _timescaledb_internal.partialize_agg(count(temperature)), _timescaledb_internal.partialize_agg(count(allnull)), _timescaledb_internal.partialize_agg(corr(temperature, humidity)), _timescaledb_internal.partialize_agg(covar_pop(temperature, humidity)), _timescaledb_internal.partialize_agg(covar_samp(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_avgx(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_avgy(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_count(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_intercept(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_r2(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_slope(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_sxx(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_sxy(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_syy(temperature, humidity)), _timescaledb_internal.partialize_agg(stddev(temperature)), _timescaledb_internal.partialize_agg(stddev_pop(temperature)), _timescaledb_internal.partialize_agg(stddev_samp(temperature)), _timescaledb_internal.partialize_agg(variance(temperature)), _timescaledb_internal.partialize_agg(var_pop(temperature)), _timescaledb_internal.partialize_agg(var_samp(temperature)), _timescaledb_internal.partialize_agg(public.last(temperature, timec)), _timescaledb_internal.partialize_agg(public.histogram(temperature, 0::double precision, 100::double precision, 5)) FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) GROUP BY 1 ORDER BY region ASC NULLS LAST
(23 rows)

-- Aggregates on custom types are not yet pushed down
:PREFIX SELECT :GROUPING,
   last(highlow, timec) as last_hl,
   first(highlow, timec) as first_hl
  FROM :TEST_TABLE
  GROUP BY :GROUPING
  ORDER BY :GROUPING;
                                                                                        QUERY PLAN                                                                                        
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Finalize GroupAggregate
   Output: conditions.region, last(conditions.highlow, conditions.timec), first(conditions.highlow, conditions.timec)
   Group Key: conditions.region
   ->  Merge Append
         Sort Key: conditions.region
         ->  Partial GroupAggregate
               Output: conditions.region, PARTIAL last(conditions.highlow, conditions.timec), PARTIAL first(conditions.highlow, conditions.timec)
               Group Key: conditions.region
               ->  Custom Scan (ServerScan) on public.conditions
                     Output: conditions.region, conditions.highlow, conditions.timec
                     Data node: data_node_1
                     Chunks: _hyper_1_1_dist_chunk, _hyper_1_2_dist_chunk, _hyper_1_3_dist_chunk, _hyper_1_4_dist_chunk
                     Remote SQL: SELECT timec, region, highlow FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) ORDER BY region ASC NULLS LAST
         ->  Partial GroupAggregate
               Output: conditions_1.region, PARTIAL last(conditions_1.highlow, conditions_1.timec), PARTIAL first(conditions_1.highlow, conditions_1.timec)
               Group Key: conditions_1.region
               ->  Custom Scan (ServerScan) on public.conditions conditions_1
                     Output: conditions_1.region, conditions_1.highlow, conditions_1.timec
                     Data node: data_node_2
                     Chunks: _hyper_1_9_dist_chunk, _hyper_1_10_dist_chunk, _hyper_1_11_dist_chunk, _hyper_1_12_dist_chunk
                     Remote SQL: SELECT timec, region, highlow FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) ORDER BY region ASC NULLS LAST
         ->  Partial GroupAggregate
               Output: conditions_2.region, PARTIAL last(conditions_2.highlow, conditions_2.timec), PARTIAL first(conditions_2.highlow, conditions_2.timec)
               Group Key: conditions_2.region
               ->  Custom Scan (ServerScan) on public.conditions conditions_2
                     Output: conditions_2.region, conditions_2.highlow, conditions_2.timec
                     Data node: data_node_3
                     Chunks: _hyper_1_5_dist_chunk, _hyper_1_6_dist_chunk, _hyper_1_7_dist_chunk, _hyper_1_8_dist_chunk
                     Remote SQL: SELECT timec, region, highlow FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) ORDER BY region ASC NULLS LAST
(29 rows)

-- Mix of aggregates that push down and those that don't
:PREFIX SELECT :GROUPING,
   min(allnull) as min_allnull,
   max(temperature) as max_temp,
   sum(temperature)+sum(humidity) as agg_sum_expr,
   avg(humidity),
   ROUND( CAST(stddev(humidity) AS NUMERIC), 5),
   bit_and(bit_int),
   bit_or(bit_int),
   bool_and(good_life),
   every(temperature > 0),
   bool_or(good_life),
   first(highlow, timec) as first_hl
  FROM :TEST_TABLE
  GROUP BY :GROUPING
  ORDER BY :GROUPING;
                                                                                                                                                                                                                                                                              QUERY PLAN                                                                                                                                                                                                                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Finalize GroupAggregate
   Output: conditions.region, min(conditions.allnull), max(conditions.temperature), (sum(conditions.temperature) + sum(conditions.humidity)), avg(conditions.humidity), round((stddev(conditions.humidity))::numeric, 5), bit_and(conditions.bit_int), bit_or(conditions.bit_int), bool_and(conditions.good_life), every((conditions.temperature > '0'::double precision)), bool_or(conditions.good_life), first(conditions.highlow, conditions.timec)
   Group Key: conditions.region
   ->  Merge Append
         Sort Key: conditions.region
         ->  Partial GroupAggregate
               Output: conditions.region, PARTIAL min(conditions.allnull), PARTIAL max(conditions.temperature), PARTIAL sum(conditions.temperature), PARTIAL sum(conditions.humidity), PARTIAL avg(conditions.humidity), PARTIAL stddev(conditions.humidity), PARTIAL bit_and(conditions.bit_int), PARTIAL bit_or(conditions.bit_int), PARTIAL bool_and(conditions.good_life), PARTIAL every((conditions.temperature > '0'::double precision)), PARTIAL bool_or(conditions.good_life), PARTIAL first(conditions.highlow, conditions.timec)
               Group Key: conditions.region
               ->  Custom Scan (ServerScan) on public.conditions
                     Output: conditions.region, conditions.allnull, conditions.temperature, conditions.humidity, conditions.bit_int, conditions.good_life, conditions.highlow, conditions.timec
                     Data node: data_node_1
                     Chunks: _hyper_1_1_dist_chunk, _hyper_1_2_dist_chunk, _hyper_1_3_dist_chunk, _hyper_1_4_dist_chunk
                     Remote SQL: SELECT timec, region, temperature, humidity, allnull, highlow, bit_int, good_life FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) ORDER BY region ASC NULLS LAST
         ->  Partial GroupAggregate
               Output: conditions_1.region, PARTIAL min(conditions_1.allnull), PARTIAL max(conditions_1.temperature), PARTIAL sum(conditions_1.temperature), PARTIAL sum(conditions_1.humidity), PARTIAL avg(conditions_1.humidity), PARTIAL stddev(conditions_1.humidity), PARTIAL bit_and(conditions_1.bit_int), PARTIAL bit_or(conditions_1.bit_int), PARTIAL bool_and(conditions_1.good_life), PARTIAL every((conditions_1.temperature > '0'::double precision)), PARTIAL bool_or(conditions_1.good_life), PARTIAL first(conditions_1.highlow, conditions_1.timec)
               Group Key: conditions_1.region
               ->  Custom Scan (ServerScan) on public.conditions conditions_1
                     Output: conditions_1.region, conditions_1.allnull, conditions_1.temperature, conditions_1.humidity, conditions_1.bit_int, conditions_1.good_life, conditions_1.highlow, conditions_1.timec
                     Data node: data_node_2
                     Chunks: _hyper_1_9_dist_chunk, _hyper_1_10_dist_chunk, _hyper_1_11_dist_chunk, _hyper_1_12_dist_chunk
                     Remote SQL: SELECT timec, region, temperature, humidity, allnull, highlow, bit_int, good_life FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) ORDER BY region ASC NULLS LAST
         ->  Partial GroupAggregate
               Output: conditions_2.region, PARTIAL min(conditions_2.allnull), PARTIAL max(conditions_2.temperature), PARTIAL sum(conditions_2.temperature), PARTIAL sum(conditions_2.humidity), PARTIAL avg(conditions_2.humidity), PARTIAL stddev(conditions_2.humidity), PARTIAL bit_and(conditions_2.bit_int), PARTIAL bit_or(conditions_2.bit_int), PARTIAL bool_and(conditions_2.good_life), PARTIAL every((conditions_2.temperature > '0'::double precision)), PARTIAL bool_or(conditions_2.good_life), PARTIAL first(conditions_2.highlow, conditions_2.timec)
               Group Key: conditions_2.region
               ->  Custom Scan (ServerScan) on public.conditions conditions_2
                     Output: conditions_2.region, conditions_2.allnull, conditions_2.temperature, conditions_2.humidity, conditions_2.bit_int, conditions_2.good_life, conditions_2.highlow, conditions_2.timec
                     Data node: data_node_3
                     Chunks: _hyper_1_5_dist_chunk, _hyper_1_6_dist_chunk, _hyper_1_7_dist_chunk, _hyper_1_8_dist_chunk
                     Remote SQL: SELECT timec, region, temperature, humidity, allnull, highlow, bit_int, good_life FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) ORDER BY region ASC NULLS LAST
(29 rows)

-- Full aggregate pushdown correctness check, compare location grouped query results with partionwise aggregates on and off
\set GROUPING 'location'
SELECT format('%s/results/dist_agg_loc_results_test.out', :'TEST_OUTPUT_DIR') as "RESULTS_TEST1",
       format('%s/results/dist_agg_loc_results_control.out', :'TEST_OUTPUT_DIR') as "RESULTS_CONTROL1"
\gset
SELECT format('\! diff %s %s', :'RESULTS_CONTROL1', :'RESULTS_TEST1') as "DIFF_CMD1"
\gset
--generate the results into two different files
\set ECHO errors
:DIFF_CMD1
-- Partial aggregate pushdown correctness check, compare region grouped query results with partionwise aggregates on and off
\set GROUPING 'region'
SELECT format('%s/results/dist_agg_region_results_test.out', :'TEST_OUTPUT_DIR') as "RESULTS_TEST2",
       format('%s/results/dist_agg_region_results_control.out', :'TEST_OUTPUT_DIR') as "RESULTS_CONTROL2"
\gset
SELECT format('\! diff %s %s', :'RESULTS_CONTROL2', :'RESULTS_TEST2') as "DIFF_CMD2"
\gset
--generate the results into two different files
\set ECHO errors
-- Note that some difference in output is expected here because
-- queries include last(col, time) and first(col, time); there are
-- multiple values for "col" that has the same timestamp, so the
-- output depends on the order of arriving tuples.
:DIFF_CMD2
14c14
<  west       | (1,2)   | (1,2)
---
>  west       | (1,2)   | 
22c22
<  west       |             |       85 |       993674 | 67.5 | 9.68309 |       0 |     10 | t        | t     | t       | (1,2)
---
>  west       |             |       85 |       993674 | 67.5 | 9.68309 |       0 |     10 | t        | t     | t       | 
