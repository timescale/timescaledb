-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- need superuser to modify statistics
\c :TEST_DBNAME :ROLE_CLUSTER_SUPERUSER
\ir include/skip_scan_load.sql
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
CREATE TABLE skip_scan(time int, dev int, dev_name text, val int);
INSERT INTO skip_scan SELECT t, d, 'device_' || d::text, t*d FROM generate_series(1, 1000) t, generate_series(1, 10) d;
INSERT INTO skip_scan VALUES (NULL, 0, -1, NULL), (0, NULL, -1, NULL);
INSERT INTO skip_scan(time,dev,dev_name,val) SELECT t, NULL, NULL, NULL FROM generate_series(0, 999, 50) t;
ANALYZE skip_scan;
CREATE TABLE skip_scan_nulls(time int);
CREATE INDEX ON skip_scan_nulls(time);
INSERT INTO skip_scan_nulls SELECT NULL FROM generate_series(1,100);
ANALYZE skip_scan_nulls;
-- create hypertable with different physical layouts in the chunks
CREATE TABLE skip_scan_ht(f1 int, f2 int, f3 int, time int NOT NULL, dev int, dev_name text, val int);
SELECT create_hypertable('skip_scan_ht', 'time', chunk_time_interval => 250, create_default_indexes => false);
     create_hypertable     
---------------------------
 (1,public,skip_scan_ht,t)
(1 row)

INSERT INTO skip_scan_ht(time,dev,dev_name,val) SELECT t, d, 'device_' || d::text, random() FROM generate_series(0, 249) t, generate_series(1, 10) d;
ALTER TABLE skip_scan_ht DROP COLUMN f1;
INSERT INTO skip_scan_ht(time,dev,dev_name,val) SELECT t, d, 'device_' || d::text, random() FROM generate_series(250, 499) t, generate_series(1, 10) d;
ALTER TABLE skip_scan_ht DROP COLUMN f2;
INSERT INTO skip_scan_ht(time,dev,dev_name,val) SELECT t, d, 'device_' || d::text, random() FROM generate_series(500, 749) t, generate_series(1, 10) d;
ALTER TABLE skip_scan_ht DROP COLUMN f3;
INSERT INTO skip_scan_ht(time,dev,dev_name,val) SELECT t, d, 'device_' || d::text, random() FROM generate_series(750, 999) t, generate_series(1, 10) d;
INSERT INTO skip_scan_ht(time,dev,dev_name,val) SELECT t, NULL, NULL, NULL FROM generate_series(0, 999, 50) t;
ANALYZE skip_scan_ht;
ALTER TABLE skip_scan_ht SET (timescaledb.compress,timescaledb.compress_orderby='time desc', timescaledb.compress_segmentby='dev');
CREATE TABLE skip_scan_insert(time int, dev int, dev_name text, val int, query text);
CREATE OR REPLACE FUNCTION int_func_immutable() RETURNS int LANGUAGE SQL IMMUTABLE SECURITY DEFINER AS $$SELECT 1; $$;
CREATE OR REPLACE FUNCTION int_func_stable() RETURNS int LANGUAGE SQL STABLE SECURITY DEFINER AS $$ SELECT 2; $$;
CREATE OR REPLACE FUNCTION int_func_volatile() RETURNS int LANGUAGE SQL VOLATILE SECURITY DEFINER AS $$ SELECT 3; $$;
CREATE OR REPLACE FUNCTION inta_func_immutable() RETURNS int[] LANGUAGE SQL IMMUTABLE SECURITY DEFINER AS $$ SELECT ARRAY[1,2,3]; $$;
CREATE OR REPLACE FUNCTION inta_func_stable() RETURNS int[] LANGUAGE SQL STABLE SECURITY DEFINER AS $$ SELECT ARRAY[2,3,4]; $$;
CREATE OR REPLACE FUNCTION inta_func_volatile() RETURNS int[] LANGUAGE SQL VOLATILE SECURITY DEFINER AS $$ SELECT ARRAY[3,4,5]; $$;
-- adjust statistics so we get skipscan plans
UPDATE pg_statistic SET stadistinct=1, stanullfrac=0.5 WHERE starelid='skip_scan'::regclass;
UPDATE pg_statistic SET stadistinct=1, stanullfrac=0.5 WHERE starelid='skip_scan_nulls'::regclass;
UPDATE pg_statistic SET stadistinct=1, stanullfrac=0.5 WHERE starelid='skip_scan_ht'::regclass;
UPDATE pg_statistic SET stadistinct=1, stanullfrac=0.5 WHERE starelid IN (select inhrelid from pg_inherits where inhparent='skip_scan_ht'::regclass);
-- Turn off autovacuum to not trigger new vacuums that restores the
-- adjusted statistics
alter table skip_scan set (autovacuum_enabled = off);
alter table skip_scan_nulls set (autovacuum_enabled = off);
alter table skip_scan_ht set (autovacuum_enabled = off);
-- we want to run with analyze here so we can see counts in the nodes
\set PREFIX 'EXPLAIN (analyze, costs off, timing off, summary off)'
\set TABLE skip_scan
\ir include/skip_scan_dagg_query.sql
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- canary for result diff
SELECT current_setting('timescaledb.enable_skipscan_for_distinct_aggregates') AS enable_skipscan;
 enable_skipscan 
-----------------
 on
(1 row)

-- test different index configurations
-- no index so we cant do SkipScan
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE;
                          QUERY PLAN                           
---------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Sort (actual rows=10022 loops=1)
         Sort Key: dev
         Sort Method: quicksort 
         ->  Seq Scan on skip_scan (actual rows=10022 loops=1)
(5 rows)

-- NULLS LAST index on dev
CREATE INDEX skip_scan_idx_dev_nulls_last ON :TABLE(dev);
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_idx_dev_nulls_last on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev > NULL::integer)
(5 rows)

:PREFIX SELECT count(DISTINCT dev), dev FROM :TABLE GROUP BY dev ORDER BY dev DESC;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: dev
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan Backward using skip_scan_idx_dev_nulls_last on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev < NULL::integer)
(6 rows)

DROP INDEX skip_scan_idx_dev_nulls_last;
-- NULLS FIRST index on dev
CREATE INDEX skip_scan_idx_dev_nulls_first ON :TABLE(dev NULLS FIRST);
:PREFIX SELECT count(DISTINCT dev), dev FROM :TABLE GROUP BY dev ORDER BY dev NULLS FIRST;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: dev
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_idx_dev_nulls_first on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev > NULL::integer)
(6 rows)

DROP INDEX skip_scan_idx_dev_nulls_first;
-- multicolumn index with dev as leading column
CREATE INDEX skip_scan_idx_dev_time_idx ON :TABLE(dev, time);
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_idx_dev_time_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev > NULL::integer)
(5 rows)

:PREFIX SELECT count(DISTINCT dev), dev FROM :TABLE GROUP BY dev ORDER BY dev DESC;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: dev
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan Backward using skip_scan_idx_dev_time_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev < NULL::integer)
(6 rows)

DROP INDEX skip_scan_idx_dev_time_idx;
-- multicolumn index with dev as non-leading column
CREATE INDEX skip_scan_idx_time_dev_idx ON :TABLE(time, dev);
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE WHERE time = 100;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=11 loops=1)
         ->  Index Only Scan using skip_scan_idx_time_dev_idx on skip_scan (actual rows=11 loops=1)
               Index Cond: (("time" = 100) AND (dev > NULL::integer))
(5 rows)

:PREFIX SELECT count(DISTINCT dev), dev FROM :TABLE WHERE time = 100 GROUP BY dev;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: dev
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=11 loops=1)
         ->  Index Only Scan using skip_scan_idx_time_dev_idx on skip_scan (actual rows=11 loops=1)
               Index Cond: (("time" = 100) AND (dev > NULL::integer))
(6 rows)

DROP INDEX skip_scan_idx_time_dev_idx;
-- hash index is not ordered so can't use skipscan
CREATE INDEX skip_scan_idx_hash ON :TABLE USING hash(dev_name);
:PREFIX SELECT count(DISTINCT dev_name) FROM :TABLE WHERE dev_name IN ('device_1','device_2');
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Sort (actual rows=2000 loops=1)
         Sort Key: dev_name
         Sort Method: quicksort 
         ->  Bitmap Heap Scan on skip_scan (actual rows=2000 loops=1)
               Recheck Cond: (dev_name = ANY ('{device_1,device_2}'::text[]))
               Heap Blocks: exact=13
               ->  Bitmap Index Scan on skip_scan_idx_hash (actual rows=2000 loops=1)
                     Index Cond: (dev_name = ANY ('{device_1,device_2}'::text[]))
(9 rows)

DROP INDEX skip_scan_idx_hash;
-- expression indexes
-- currently not supported by skipscan
CREATE INDEX skip_scan_expr_idx ON :TABLE((dev % 3));
:PREFIX SELECT count(DISTINCT dev%3) FROM :TABLE;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Index Scan using skip_scan_expr_idx on skip_scan (actual rows=10022 loops=1)
(2 rows)

:PREFIX SELECT count(DISTINCT dev%3), dev%3 FROM :TABLE GROUP BY dev%3 ORDER BY dev%3;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 GroupAggregate (actual rows=4 loops=1)
   Group Key: (dev % 3)
   ->  Index Scan using skip_scan_expr_idx on skip_scan (actual rows=10022 loops=1)
(3 rows)

DROP INDEX skip_scan_expr_idx;
CREATE INDEX ON :TABLE(dev_name);
CREATE INDEX ON :TABLE(dev);
CREATE INDEX ON :TABLE(dev, time);
CREATE INDEX ON :TABLE(time,dev);
CREATE INDEX ON :TABLE(time,dev,val);
\qecho basic DISTINCT queries on :TABLE
basic DISTINCT queries on skip_scan
-- Various distint aggs over same column is OK
:PREFIX SELECT count(DISTINCT dev), sum(DISTINCT dev), 'q1_1' FROM :TABLE;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev > NULL::integer)
(5 rows)

:PREFIX SELECT count(DISTINCT dev_name), max(DISTINCT dev_name), 'q1_2' FROM :TABLE;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_name_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev_name > NULL::text)
(5 rows)

-- Distinct agg over Const is OK
:PREFIX SELECT count(DISTINCT dev), count(DISTINCT 2), 'q1_3', NULL FROM :TABLE;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev > NULL::integer)
(5 rows)

-- DISTINCT over distinct agg is OK
:PREFIX SELECT DISTINCT count(DISTINCT dev), dev, 'q1_4' FROM :TABLE GROUP BY dev ORDER BY dev;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Sort (actual rows=12 loops=1)
   Sort Key: dev
   Sort Method: quicksort 
   ->  HashAggregate (actual rows=12 loops=1)
         Group Key: dev, count(DISTINCT dev)
         Batches: 1 
         ->  GroupAggregate (actual rows=12 loops=1)
               Group Key: dev
               ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
                     ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
                           Index Cond: (dev > NULL::integer)
(12 rows)

\qecho stable expression in targetlist on :TABLE
stable expression in targetlist on skip_scan
:PREFIX SELECT count(DISTINCT dev), 'q1_5', length(md5(now()::text)) FROM :TABLE;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev > NULL::integer)
(5 rows)

:PREFIX SELECT count(DISTINCT dev_name), 'q1_6', length(md5(now()::text)) FROM :TABLE;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_name_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev_name > NULL::text)
(5 rows)

-- volatile expression in targetlist
:PREFIX SELECT count(DISTINCT dev), 'q1_7', length(md5(random()::text)) FROM :TABLE;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev > NULL::integer)
(5 rows)

:PREFIX SELECT count(DISTINCT dev_name), 'q1_8', length(md5(random()::text)) FROM :TABLE;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_name_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev_name > NULL::text)
(5 rows)

-- Mix of aggregates on different columns and distinct/not distinct
-- currently not supported by skipscan
:PREFIX SELECT count(DISTINCT dev), max(DISTINCT dev_name), 'q1_9' FROM :TABLE;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Index Scan using skip_scan_dev_idx on skip_scan (actual rows=10022 loops=1)
(2 rows)

:PREFIX SELECT count(DISTINCT dev), sum(dev), 'q1_10' FROM :TABLE;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=10022 loops=1)
(3 rows)

:PREFIX SELECT count(DISTINCT dev), dev_name, 'q1_11' FROM :TABLE GROUP BY dev_name ORDER BY dev_name;
                          QUERY PLAN                           
---------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: dev_name
   ->  Sort (actual rows=10022 loops=1)
         Sort Key: dev_name, dev
         Sort Method: quicksort 
         ->  Seq Scan on skip_scan (actual rows=10022 loops=1)
(6 rows)

-- distinct on expressions not supported
:PREFIX SELECT count(DISTINCT time_bucket(10,time)), 'q1_12' FROM :TABLE;
                          QUERY PLAN                           
---------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Sort (actual rows=10022 loops=1)
         Sort Key: (time_bucket(10, "time"))
         Sort Method: quicksort 
         ->  Seq Scan on skip_scan (actual rows=10022 loops=1)
(5 rows)

:PREFIX SELECT count(DISTINCT length(dev_name)), 'q1_13' FROM :TABLE;
                          QUERY PLAN                           
---------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Sort (actual rows=10022 loops=1)
         Sort Key: (length(dev_name))
         Sort Method: quicksort 
         ->  Seq Scan on skip_scan (actual rows=10022 loops=1)
(5 rows)

:PREFIX SELECT count(DISTINCT 3*time), 'q1_14' FROM :TABLE;
                          QUERY PLAN                           
---------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Sort (actual rows=10022 loops=1)
         Sort Key: ((3 * "time"))
         Sort Method: quicksort 
         ->  Seq Scan on skip_scan (actual rows=10022 loops=1)
(5 rows)

-- But expressions over distinct aggregates are supported
:PREFIX SELECT count(DISTINCT dev) + 1, sum(DISTINCT dev)/count(DISTINCT dev), 'q1_15' FROM :TABLE;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev > NULL::integer)
(5 rows)

-- DISTINCT aggs grouped on their args
:PREFIX SELECT count(DISTINCT dev), dev, 'q2_1' FROM :TABLE GROUP BY dev;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: dev
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev > NULL::integer)
(6 rows)

:PREFIX SELECT count(DISTINCT dev), dev, 'q2_2', NULL FROM :TABLE GROUP BY dev;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: dev
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev > NULL::integer)
(6 rows)

:PREFIX SELECT count(DISTINCT dev), dev, 'q2_3', length(md5(now()::text)) FROM :TABLE GROUP BY dev;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: dev
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev > NULL::integer)
(6 rows)

:PREFIX SELECT count(DISTINCT dev), dev, 'q2_4', length(md5(random()::text)) FROM :TABLE GROUP BY dev;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: dev
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev > NULL::integer)
(6 rows)

:PREFIX SELECT count(DISTINCT dev), dev, int_func_immutable(), 'q2_5' FROM :TABLE GROUP BY dev;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: dev
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev > NULL::integer)
(6 rows)

:PREFIX SELECT count(DISTINCT dev), dev, int_func_stable(), 'q2_6' FROM :TABLE GROUP BY dev;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: dev
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev > NULL::integer)
(6 rows)

:PREFIX SELECT count(DISTINCT dev), dev, int_func_volatile(), 'q2_7' FROM :TABLE GROUP BY dev;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: dev
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev > NULL::integer)
(6 rows)

:PREFIX SELECT count(DISTINCT dev), dev+1, 'q2_8' FROM :TABLE GROUP BY dev ORDER BY 2;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Sort (actual rows=12 loops=1)
   Sort Key: ((dev + 1))
   Sort Method: quicksort 
   ->  GroupAggregate (actual rows=12 loops=1)
         Group Key: dev
         ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
               ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
                     Index Cond: (dev > NULL::integer)
(9 rows)

:PREFIX SELECT count(DISTINCT dev), dev+1, dev+2, 'q2_9' FROM :TABLE GROUP BY dev, dev;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: dev
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev > NULL::integer)
(6 rows)

-- Cannot do SkipScan as we group on a column which is not the distinct agg argument
:PREFIX SELECT time, count(DISTINCT dev), 'q2_10' FROM :TABLE GROUP BY time;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=1002 loops=1)
   Group Key: "time"
   ->  Index Only Scan using skip_scan_time_dev_idx on skip_scan (actual rows=10022 loops=1)
(4 rows)

-- Cannot do SkipScan if we group on 2+ columns
:PREFIX SELECT count(DISTINCT dev), dev, tableoid::regclass, 'q2_11' FROM :TABLE GROUP BY dev, tableoid ORDER BY dev, tableoid;
                          QUERY PLAN                           
---------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: dev, tableoid
   ->  Sort (actual rows=10022 loops=1)
         Sort Key: dev, tableoid
         Sort Method: quicksort 
         ->  Seq Scan on skip_scan (actual rows=10022 loops=1)
(6 rows)

-- DISTINCT aggs grouped on their TEXT args
:PREFIX SELECT count(DISTINCT dev_name), dev_name, 'q3_1' FROM :TABLE GROUP BY dev_name;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: dev_name
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_name_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev_name > NULL::text)
(6 rows)

:PREFIX SELECT count(DISTINCT dev_name), dev_name, 'q3_2', NULL FROM :TABLE GROUP BY dev_name;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: dev_name
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_name_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev_name > NULL::text)
(6 rows)

:PREFIX SELECT count(DISTINCT dev_name), dev_name, 'q3_3', length(md5(now()::text)) FROM :TABLE GROUP BY dev_name;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: dev_name
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_name_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev_name > NULL::text)
(6 rows)

:PREFIX SELECT count(DISTINCT dev_name), dev_name, 'q3_4', length(md5(random()::text)) FROM :TABLE GROUP BY dev_name;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: dev_name
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_name_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev_name > NULL::text)
(6 rows)

:PREFIX SELECT count(DISTINCT dev_name::varchar), dev_name::varchar, 'q3_5' FROM :TABLE GROUP BY dev_name;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: dev_name
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_name_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev_name > NULL::text)
(6 rows)

:PREFIX SELECT count(DISTINCT dev_name), dev_name, int_func_immutable(), 'q3_6' FROM :TABLE GROUP BY dev_name;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: dev_name
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_name_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev_name > NULL::text)
(6 rows)

:PREFIX SELECT count(DISTINCT dev_name), dev_name, int_func_stable(), 'q3_7' FROM :TABLE GROUP BY dev_name;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: dev_name
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_name_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev_name > NULL::text)
(6 rows)

:PREFIX SELECT count(DISTINCT dev_name), dev_name, int_func_volatile(), 'q3_8' FROM :TABLE GROUP BY dev_name;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: dev_name
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_name_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev_name > NULL::text)
(6 rows)

-- Cannot do SkipScan as we group on a column which is not the distinct agg argument
:PREFIX SELECT count(DISTINCT dev_name), dev_name, tableoid::regclass, 'q3_9' FROM :TABLE GROUP BY dev_name, tableoid ORDER BY dev_name, tableoid;
                          QUERY PLAN                           
---------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: dev_name, tableoid
   ->  Sort (actual rows=10022 loops=1)
         Sort Key: dev_name, tableoid
         Sort Method: quicksort 
         ->  Seq Scan on skip_scan (actual rows=10022 loops=1)
(6 rows)

-- Can do SkipScan if extra group column is eliminated by pinning to a Const
-- and when it changes group by ordering
:PREFIX SELECT count(DISTINCT dev_name), dev, dev_name FROM :TABLE WHERE dev = 1 GROUP BY dev, dev_name ORDER BY dev, dev_name;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=1 loops=1)
   Group Key: dev_name
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=1 loops=1)
         ->  Index Scan using skip_scan_dev_name_idx on skip_scan (actual rows=1 loops=1)
               Filter: (dev = 1)
               Rows Removed by Filter: 9022
(6 rows)

\qecho LIMIT queries on :TABLE
LIMIT queries on skip_scan
:PREFIX SELECT count(DISTINCT dev), dev FROM :TABLE GROUP BY dev LIMIT 3;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Limit (actual rows=3 loops=1)
   ->  GroupAggregate (actual rows=3 loops=1)
         Group Key: dev
         ->  Custom Scan (SkipScan) on skip_scan (actual rows=4 loops=1)
               ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=4 loops=1)
                     Index Cond: (dev > NULL::integer)
(7 rows)

:PREFIX SELECT count(DISTINCT dev), dev FROM :TABLE GROUP BY dev ORDER BY dev DESC LIMIT 3;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit (actual rows=3 loops=1)
   ->  GroupAggregate (actual rows=3 loops=1)
         Group Key: dev
         ->  Custom Scan (SkipScan) on skip_scan (actual rows=4 loops=1)
               ->  Index Only Scan Backward using skip_scan_dev_idx on skip_scan (actual rows=4 loops=1)
                     Index Cond: (dev < NULL::integer)
(7 rows)

\qecho range queries on :TABLE
range queries on skip_scan
:PREFIX SELECT count(DISTINCT dev), dev FROM :TABLE WHERE time BETWEEN 100 AND 300 GROUP BY dev;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: dev
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=11 loops=1)
         ->  Index Only Scan using skip_scan_dev_time_idx on skip_scan (actual rows=11 loops=1)
               Index Cond: ((dev > NULL::integer) AND ("time" >= 100) AND ("time" <= 300))
(6 rows)

:PREFIX SELECT count(DISTINCT dev), dev FROM :TABLE WHERE time < 200 GROUP BY dev;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: dev
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=11 loops=1)
         ->  Index Only Scan using skip_scan_dev_time_idx on skip_scan (actual rows=11 loops=1)
               Index Cond: ((dev > NULL::integer) AND ("time" < 200))
(6 rows)

:PREFIX SELECT count(DISTINCT dev), dev FROM :TABLE WHERE time > 800 GROUP BY dev;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: dev
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=11 loops=1)
         ->  Index Only Scan using skip_scan_dev_time_idx on skip_scan (actual rows=11 loops=1)
               Index Cond: ((dev > NULL::integer) AND ("time" > 800))
(6 rows)

\qecho ordered append on :TABLE
ordered append on skip_scan
:PREFIX SELECT count(DISTINCT time), time FROM :TABLE WHERE time BETWEEN 0 AND 5000  GROUP BY time;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=1001 loops=1)
   Group Key: "time"
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=1001 loops=1)
         ->  Index Only Scan using skip_scan_time_dev_idx on skip_scan (actual rows=1001 loops=1)
               Index Cond: (("time" > NULL::integer) AND ("time" >= 0) AND ("time" <= 5000))
(6 rows)

\qecho SUBSELECTS on :TABLE
SUBSELECTS on skip_scan
:PREFIX SELECT c1, c2, 'q4_1' FROM (SELECT count(DISTINCT dev) as c1, sum(DISTINCT dev) as c2 FROM :TABLE) a;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Subquery Scan on a (actual rows=1 loops=1)
   ->  Aggregate (actual rows=1 loops=1)
         ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
               ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
                     Index Cond: (dev > NULL::integer)
(6 rows)

:PREFIX SELECT NULL, dev, NULL, 'q4_2' FROM (SELECT count(DISTINCT dev) as dev FROM :TABLE) a;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Subquery Scan on a (actual rows=1 loops=1)
   ->  Aggregate (actual rows=1 loops=1)
         ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
               ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
                     Index Cond: (dev > NULL::integer)
(6 rows)

:PREFIX SELECT NULL, dev, NULL, c1, 2, c3, 'q4_3' FROM (SELECT count(DISTINCT dev) as c1, dev, 1 as c3 FROM :TABLE GROUP BY dev) a;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Subquery Scan on a (actual rows=12 loops=1)
   ->  GroupAggregate (actual rows=12 loops=1)
         Group Key: skip_scan.dev
         ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
               ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
                     Index Cond: (dev > NULL::integer)
(7 rows)

\qecho ORDER BY
ORDER BY
:PREFIX SELECT c, dev, 'q5_1' FROM (SELECT count(DISTINCT dev) as c, dev FROM :TABLE GROUP BY dev ORDER BY dev) a;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Subquery Scan on a (actual rows=12 loops=1)
   ->  GroupAggregate (actual rows=12 loops=1)
         Group Key: skip_scan.dev
         ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
               ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
                     Index Cond: (dev > NULL::integer)
(7 rows)

:PREFIX SELECT c, dev, 'q5_2' FROM (SELECT count(DISTINCT dev) as c, dev FROM :TABLE GROUP BY dev ORDER BY dev DESC) a;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Subquery Scan on a (actual rows=12 loops=1)
   ->  GroupAggregate (actual rows=12 loops=1)
         Group Key: skip_scan.dev
         ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
               ->  Index Only Scan Backward using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
                     Index Cond: (dev < NULL::integer)
(7 rows)

\qecho WHERE CLAUSES
WHERE CLAUSES
:PREFIX SELECT c, dev, 'q6_1' FROM (SELECT count(DISTINCT dev) as c, dev FROM :TABLE WHERE dev > 5 GROUP BY dev) a;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Subquery Scan on a (actual rows=5 loops=1)
   ->  GroupAggregate (actual rows=5 loops=1)
         Group Key: skip_scan.dev
         ->  Custom Scan (SkipScan) on skip_scan (actual rows=5 loops=1)
               ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=5 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev > 5))
(7 rows)

:PREFIX SELECT c, dev, 'q6_2' FROM (SELECT sum(DISTINCT dev) as c, dev FROM :TABLE GROUP BY dev HAVING sum(DISTINCT dev)>2) a;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Subquery Scan on a (actual rows=8 loops=1)
   ->  GroupAggregate (actual rows=8 loops=1)
         Group Key: skip_scan.dev
         Filter: (sum(DISTINCT skip_scan.dev) > 2)
         Rows Removed by Filter: 4
         ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
               ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
                     Index Cond: (dev > NULL::integer)
(9 rows)

:PREFIX SELECT c, dev, 'q6_3' FROM (SELECT count(DISTINCT dev) as c, dev FROM :TABLE GROUP BY dev) a WHERE dev > 5;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Subquery Scan on a (actual rows=5 loops=1)
   ->  GroupAggregate (actual rows=5 loops=1)
         Group Key: skip_scan.dev
         ->  Custom Scan (SkipScan) on skip_scan (actual rows=5 loops=1)
               ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=5 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev > 5))
(7 rows)

:PREFIX SELECT c, dev, 'q6_4' FROM (SELECT sum(DISTINCT dev) as c, dev FROM :TABLE GROUP BY dev) a WHERE c > 2;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Subquery Scan on a (actual rows=8 loops=1)
   ->  GroupAggregate (actual rows=8 loops=1)
         Group Key: skip_scan.dev
         Filter: (sum(DISTINCT skip_scan.dev) > 2)
         Rows Removed by Filter: 4
         ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
               ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
                     Index Cond: (dev > NULL::integer)
(9 rows)

--\qecho immutable func in WHERE clause on :TABLE
:PREFIX SELECT count(DISTINCT dev), 'q6_5' FROM :TABLE WHERE dev > int_func_immutable();
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=9 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=9 loops=1)
               Index Cond: ((dev > NULL::integer) AND (dev > 1))
(5 rows)

--\qecho stable func in WHERE clause on :TABLE
:PREFIX SELECT count(DISTINCT dev), 'q6_6' FROM :TABLE WHERE dev > int_func_stable();
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=8 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=8 loops=1)
               Index Cond: ((dev > NULL::integer) AND (dev > int_func_stable()))
(5 rows)

--\qecho volatile func in WHERE clause on :TABLE:PREFIX SELECT count(DISTINCT dev), 'q6_7' FROM :TABLE WHERE dev > int_func_volatile();
:PREFIX SELECT count(DISTINCT dev), 'q6_8' FROM :TABLE WHERE dev = ANY(inta_func_immutable());
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=3 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=3 loops=1)
               Index Cond: ((dev > NULL::integer) AND (dev = ANY ('{1,2,3}'::integer[])))
(5 rows)

:PREFIX SELECT count(DISTINCT dev), 'q6_9' FROM :TABLE WHERE dev = ANY(inta_func_stable());
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=3 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=3 loops=1)
               Index Cond: ((dev > NULL::integer) AND (dev = ANY (inta_func_stable())))
(5 rows)

:PREFIX SELECT count(DISTINCT dev), 'q6_10' FROM :TABLE WHERE dev = ANY(inta_func_volatile());
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=3 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=3 loops=1)
               Index Cond: (dev > NULL::integer)
               Filter: (dev = ANY (inta_func_volatile()))
               Rows Removed by Filter: 7022
(7 rows)

-- always false expr similar to our initial skip qual
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE WHERE dev > NULL;
                  QUERY PLAN                  
----------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Sort (actual rows=0 loops=1)
         Sort Key: dev
         Sort Method: quicksort 
         ->  Result (actual rows=0 loops=1)
               One-Time Filter: false
(6 rows)

-- no tuples matching
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE WHERE dev > 20;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=0 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=0 loops=1)
               Index Cond: ((dev > NULL::integer) AND (dev > 20))
(5 rows)

-- multiple constraints in WHERE clause
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE WHERE dev > 5 AND time = 100;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=5 loops=1)
         ->  Index Only Scan using skip_scan_time_dev_val_idx on skip_scan (actual rows=5 loops=1)
               Index Cond: (("time" = 100) AND (dev > NULL::integer) AND (dev > 5))
(5 rows)

:PREFIX SELECT count(DISTINCT dev) FROM :TABLE WHERE dev > 5 AND time > 200;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=5 loops=1)
         ->  Index Scan using skip_scan_dev_idx on skip_scan (actual rows=5 loops=1)
               Index Cond: (dev > 5)
               Filter: ("time" > 200)
               Rows Removed by Filter: 1000
(6 rows)

:PREFIX SELECT count(DISTINCT dev) FROM :TABLE WHERE dev >= 5 AND dev < 7 AND dev >= 2;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=2 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=2 loops=1)
               Index Cond: ((dev > NULL::integer) AND (dev >= 5) AND (dev < 7) AND (dev >= 2))
(5 rows)

:PREFIX SELECT count(DISTINCT dev), dev FROM :TABLE WHERE time > 100 AND time < 200 AND val > 10 AND val < 10000 AND dev > 2 AND dev < 7 GROUP BY dev ORDER BY dev;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=4 loops=1)
   Group Key: dev
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=4 loops=1)
         ->  Index Scan using skip_scan_dev_time_idx on skip_scan (actual rows=4 loops=1)
               Index Cond: ((dev > 2) AND (dev < 7) AND ("time" > 100) AND ("time" < 200))
               Filter: ((val > 10) AND (val < 10000))
(6 rows)

:PREFIX SELECT count(DISTINCT dev) FROM :TABLE WHERE dev IS NULL;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=1 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=1 loops=1)
               Index Cond: ((dev > NULL::integer) AND (dev IS NULL))
(5 rows)

:PREFIX SELECT count(DISTINCT dev_name) FROM :TABLE WHERE dev_name IS NULL;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=1 loops=1)
         ->  Index Only Scan using skip_scan_dev_name_idx on skip_scan (actual rows=1 loops=1)
               Index Cond: ((dev_name > NULL::text) AND (dev_name IS NULL))
(5 rows)

-- Distinct aggregate path with no pathkeys because of Const predicate.
-- PG is smart to add LIMIT 1 to SELECT DISTINCT in this case,
-- but not smart enough to add LIMIT 1 to distinct aggregate input.
-- TODO: create an issue for this task, i.e. add LIMIT 1 to distinct aggregate input when input equals to a Const
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE WHERE dev = 1;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=1000 loops=1)
         Index Cond: (dev = 1)
(4 rows)

:PREFIX SELECT count(DISTINCT dev), dev FROM :TABLE WHERE dev = 1 GROUP BY dev ORDER BY dev DESC;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 GroupAggregate (actual rows=1 loops=1)
   ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=1000 loops=1)
         Index Cond: (dev = 1)
(4 rows)

-- CTE
:PREFIX WITH devices AS (
	SELECT count(DISTINCT dev) FROM :TABLE
)
SELECT * FROM devices;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev > NULL::integer)
(5 rows)

:PREFIX WITH devices AS (
	SELECT dev, count(DISTINCT dev) FROM :TABLE GROUP BY dev
)
SELECT * FROM devices ORDER BY dev;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=12 loops=1)
   Group Key: skip_scan.dev
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev > NULL::integer)
(6 rows)

-- prepared statements
PREPARE prep AS SELECT count(DISTINCT dev_name) FROM :TABLE;
:PREFIX EXECUTE prep;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_name_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev_name > NULL::text)
(5 rows)

:PREFIX EXECUTE prep;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_name_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev_name > NULL::text)
(5 rows)

:PREFIX EXECUTE prep;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_name_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev_name > NULL::text)
(5 rows)

DEALLOCATE prep;
-- ReScan tests
:PREFIX SELECT c, 'q7_1' FROM (SELECT count(DISTINCT dev) c FROM (
    VALUES (1), (2)) a(v),
    LATERAL (SELECT * FROM :TABLE WHERE time != a.v) b) a;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Subquery Scan on a (actual rows=1 loops=1)
   ->  Aggregate (actual rows=1 loops=1)
         ->  Nested Loop (actual rows=20022 loops=1)
               Join Filter: (skip_scan."time" <> "*VALUES*".column1)
               Rows Removed by Join Filter: 22
               ->  Index Scan using skip_scan_dev_idx on skip_scan (actual rows=10022 loops=1)
               ->  Materialize (actual rows=2 loops=10022)
                     ->  Values Scan on "*VALUES*" (actual rows=2 loops=1)
(8 rows)

:PREFIX SELECT c, 'q7_2' FROM (SELECT * FROM (
    VALUES (1), (2)) a(v),
    LATERAL (SELECT count(DISTINCT dev) c FROM :TABLE WHERE dev != a.v) b) a;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Nested Loop (actual rows=2 loops=1)
   ->  Values Scan on "*VALUES*" (actual rows=2 loops=1)
   ->  Aggregate (actual rows=1 loops=2)
         ->  Custom Scan (SkipScan) on skip_scan (actual rows=10 loops=2)
               ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=10 loops=2)
                     Index Cond: (dev > NULL::integer)
                     Filter: (dev <> "*VALUES*".column1)
                     Rows Removed by Filter: 1021
(9 rows)

-- RuntimeKeys
:PREFIX SELECT c, 'q8_1' FROM (SELECT * FROM (VALUES (1), (2)) a(v), LATERAL (SELECT count(DISTINCT dev) c FROM :TABLE WHERE dev >= a.v) b) c;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Nested Loop (actual rows=2 loops=1)
   ->  Values Scan on "*VALUES*" (actual rows=2 loops=1)
   ->  Aggregate (actual rows=1 loops=2)
         ->  Custom Scan (SkipScan) on skip_scan (actual rows=10 loops=2)
               ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=10 loops=2)
                     Index Cond: ((dev > NULL::integer) AND (dev >= "*VALUES*".column1))
(7 rows)

--  DISTINCT aggs on different columns in different subqueries
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE UNION ALL SELECT count(DISTINCT time) FROM :TABLE;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Append (actual rows=2 loops=1)
   ->  Aggregate (actual rows=1 loops=1)
         ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
               ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
                     Index Cond: (dev > NULL::integer)
   ->  Aggregate (actual rows=1 loops=1)
         ->  Custom Scan (SkipScan) on skip_scan skip_scan_1 (actual rows=1002 loops=1)
               ->  Index Only Scan using skip_scan_time_dev_idx on skip_scan skip_scan_1 (actual rows=1002 loops=1)
                     Index Cond: ("time" > NULL::integer)
(11 rows)

:PREFIX SELECT *, 'q9_2' FROM (SELECT count(DISTINCT dev) cd, dev FROM :TABLE GROUP BY dev) a, LATERAL (SELECT count(DISTINCT time) ct FROM :TABLE WHERE dev = a.dev) b;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Nested Loop (actual rows=12 loops=1)
   ->  GroupAggregate (actual rows=12 loops=1)
         Group Key: skip_scan.dev
         ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
               ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
                     Index Cond: (dev > NULL::integer)
   ->  Aggregate (actual rows=1 loops=12)
         ->  Custom Scan (SkipScan) on skip_scan skip_scan_1 (actual rows=833 loops=12)
               ->  Index Only Scan using skip_scan_dev_time_idx on skip_scan skip_scan_1 (actual rows=833 loops=12)
                     Index Cond: ((dev = skip_scan.dev) AND ("time" > NULL::integer))
(12 rows)

-- SkipScan into INSERT
:PREFIX INSERT INTO skip_scan_insert(dev, val, query) SELECT dev, sd, 'q10_1' FROM (SELECT sum(DISTINCT dev) sd, dev FROM :TABLE GROUP BY dev) a;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Insert on skip_scan_insert (actual rows=0 loops=1)
   ->  Subquery Scan on a (actual rows=12 loops=1)
         ->  GroupAggregate (actual rows=12 loops=1)
               Group Key: skip_scan.dev
               ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
                     ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
                           Index Cond: (dev > NULL::integer)
(8 rows)

-- parallel query
SELECT set_config(CASE WHEN current_setting('server_version_num')::int < 160000 THEN 'force_parallel_mode' ELSE 'debug_parallel_query' END,'on', false);
 set_config 
------------
 on
(1 row)

:PREFIX SELECT count(DISTINCT dev) FROM :TABLE;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan (actual rows=12 loops=1)
         ->  Index Only Scan using skip_scan_dev_idx on skip_scan (actual rows=12 loops=1)
               Index Cond: (dev > NULL::integer)
(5 rows)

SELECT set_config(CASE WHEN current_setting('server_version_num')::int < 160000 THEN 'force_parallel_mode' ELSE 'debug_parallel_query' END,'off', false);
 set_config 
------------
 off
(1 row)

TRUNCATE skip_scan_insert;
-- table with only nulls
:PREFIX SELECT count(DISTINCT time) FROM skip_scan_nulls;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan_nulls (actual rows=1 loops=1)
         ->  Index Only Scan using skip_scan_nulls_time_idx on skip_scan_nulls (actual rows=1 loops=1)
               Index Cond: ("time" > NULL::integer)
(5 rows)

-- no tuples in resultset
:PREFIX SELECT count(DISTINCT time) FROM skip_scan_nulls WHERE time IS NOT NULL;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan_nulls (actual rows=0 loops=1)
         ->  Index Only Scan using skip_scan_nulls_time_idx on skip_scan_nulls (actual rows=0 loops=1)
               Index Cond: (("time" > NULL::integer) AND ("time" IS NOT NULL))
(5 rows)

\set TABLE skip_scan_ht
\ir include/skip_scan_dagg_query.sql
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- canary for result diff
SELECT current_setting('timescaledb.enable_skipscan_for_distinct_aggregates') AS enable_skipscan;
 enable_skipscan 
-----------------
 on
(1 row)

-- test different index configurations
-- no index so we cant do SkipScan
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Sort (actual rows=10020 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         Sort Method: quicksort 
         ->  Append (actual rows=10020 loops=1)
               ->  Seq Scan on _hyper_1_1_chunk (actual rows=2505 loops=1)
               ->  Seq Scan on _hyper_1_2_chunk (actual rows=2505 loops=1)
               ->  Seq Scan on _hyper_1_3_chunk (actual rows=2505 loops=1)
               ->  Seq Scan on _hyper_1_4_chunk (actual rows=2505 loops=1)
(9 rows)

-- NULLS LAST index on dev
CREATE INDEX skip_scan_idx_dev_nulls_last ON :TABLE(dev);
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_idx_dev_nulls_last on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_idx_dev_nulls_last on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_idx_dev_nulls_last on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_idx_dev_nulls_last on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(19 rows)

:PREFIX SELECT count(DISTINCT dev), dev FROM :TABLE GROUP BY dev ORDER BY dev DESC;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev DESC
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan Backward using _hyper_1_1_chunk_skip_scan_idx_dev_nulls_last on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev < NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan Backward using _hyper_1_2_chunk_skip_scan_idx_dev_nulls_last on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev < NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan Backward using _hyper_1_3_chunk_skip_scan_idx_dev_nulls_last on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev < NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan Backward using _hyper_1_4_chunk_skip_scan_idx_dev_nulls_last on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev < NULL::integer)
(20 rows)

DROP INDEX skip_scan_idx_dev_nulls_last;
-- NULLS FIRST index on dev
CREATE INDEX skip_scan_idx_dev_nulls_first ON :TABLE(dev NULLS FIRST);
:PREFIX SELECT count(DISTINCT dev), dev FROM :TABLE GROUP BY dev ORDER BY dev NULLS FIRST;
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev NULLS FIRST
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_idx_dev_nulls_first on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_idx_dev_nulls_first on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_idx_dev_nulls_first on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_idx_dev_nulls_first on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(20 rows)

DROP INDEX skip_scan_idx_dev_nulls_first;
-- multicolumn index with dev as leading column
CREATE INDEX skip_scan_idx_dev_time_idx ON :TABLE(dev, time);
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_idx_dev_time_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_idx_dev_time_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_idx_dev_time_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_idx_dev_time_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(19 rows)

:PREFIX SELECT count(DISTINCT dev), dev FROM :TABLE GROUP BY dev ORDER BY dev DESC;
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev DESC
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan Backward using _hyper_1_1_chunk_skip_scan_idx_dev_time_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev < NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan Backward using _hyper_1_2_chunk_skip_scan_idx_dev_time_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev < NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan Backward using _hyper_1_3_chunk_skip_scan_idx_dev_time_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev < NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan Backward using _hyper_1_4_chunk_skip_scan_idx_dev_time_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev < NULL::integer)
(20 rows)

DROP INDEX skip_scan_idx_dev_time_idx;
-- multicolumn index with dev as non-leading column
CREATE INDEX skip_scan_idx_time_dev_idx ON :TABLE(time, dev);
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE WHERE time = 100;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
         ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_idx_time_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
               Index Cond: (("time" = 100) AND (dev > NULL::integer))
(5 rows)

:PREFIX SELECT count(DISTINCT dev), dev FROM :TABLE WHERE time = 100 GROUP BY dev;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev
   ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
         ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_idx_time_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
               Index Cond: (("time" = 100) AND (dev > NULL::integer))
(6 rows)

DROP INDEX skip_scan_idx_time_dev_idx;
-- hash index is not ordered so can't use skipscan
CREATE INDEX skip_scan_idx_hash ON :TABLE USING hash(dev_name);
:PREFIX SELECT count(DISTINCT dev_name) FROM :TABLE WHERE dev_name IN ('device_1','device_2');
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Sort (actual rows=2000 loops=1)
         Sort Key: _hyper_1_1_chunk.dev_name
         Sort Method: quicksort 
         ->  Append (actual rows=2000 loops=1)
               ->  Bitmap Heap Scan on _hyper_1_1_chunk (actual rows=500 loops=1)
                     Recheck Cond: (dev_name = ANY ('{device_1,device_2}'::text[]))
                     Heap Blocks: exact=4
                     ->  Bitmap Index Scan on _hyper_1_1_chunk_skip_scan_idx_hash (actual rows=500 loops=1)
                           Index Cond: (dev_name = ANY ('{device_1,device_2}'::text[]))
               ->  Bitmap Heap Scan on _hyper_1_2_chunk (actual rows=500 loops=1)
                     Recheck Cond: (dev_name = ANY ('{device_1,device_2}'::text[]))
                     Heap Blocks: exact=4
                     ->  Bitmap Index Scan on _hyper_1_2_chunk_skip_scan_idx_hash (actual rows=500 loops=1)
                           Index Cond: (dev_name = ANY ('{device_1,device_2}'::text[]))
               ->  Bitmap Heap Scan on _hyper_1_3_chunk (actual rows=500 loops=1)
                     Recheck Cond: (dev_name = ANY ('{device_1,device_2}'::text[]))
                     Heap Blocks: exact=4
                     ->  Bitmap Index Scan on _hyper_1_3_chunk_skip_scan_idx_hash (actual rows=500 loops=1)
                           Index Cond: (dev_name = ANY ('{device_1,device_2}'::text[]))
               ->  Bitmap Heap Scan on _hyper_1_4_chunk (actual rows=500 loops=1)
                     Recheck Cond: (dev_name = ANY ('{device_1,device_2}'::text[]))
                     Heap Blocks: exact=4
                     ->  Bitmap Index Scan on _hyper_1_4_chunk_skip_scan_idx_hash (actual rows=500 loops=1)
                           Index Cond: (dev_name = ANY ('{device_1,device_2}'::text[]))
(25 rows)

DROP INDEX skip_scan_idx_hash;
-- expression indexes
-- currently not supported by skipscan
CREATE INDEX skip_scan_expr_idx ON :TABLE((dev % 3));
:PREFIX SELECT count(DISTINCT dev%3) FROM :TABLE;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=10020 loops=1)
         Sort Key: ((_hyper_1_1_chunk.dev % 3))
         ->  Index Scan using _hyper_1_1_chunk_skip_scan_expr_idx on _hyper_1_1_chunk (actual rows=2505 loops=1)
         ->  Index Scan using _hyper_1_2_chunk_skip_scan_expr_idx on _hyper_1_2_chunk (actual rows=2505 loops=1)
         ->  Index Scan using _hyper_1_3_chunk_skip_scan_expr_idx on _hyper_1_3_chunk (actual rows=2505 loops=1)
         ->  Index Scan using _hyper_1_4_chunk_skip_scan_expr_idx on _hyper_1_4_chunk (actual rows=2505 loops=1)
(7 rows)

:PREFIX SELECT count(DISTINCT dev%3), dev%3 FROM :TABLE GROUP BY dev%3 ORDER BY dev%3;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=4 loops=1)
   Group Key: ((_hyper_1_1_chunk.dev % 3))
   ->  Result (actual rows=10020 loops=1)
         ->  Merge Append (actual rows=10020 loops=1)
               Sort Key: ((_hyper_1_1_chunk.dev % 3))
               ->  Index Scan using _hyper_1_1_chunk_skip_scan_expr_idx on _hyper_1_1_chunk (actual rows=2505 loops=1)
               ->  Index Scan using _hyper_1_2_chunk_skip_scan_expr_idx on _hyper_1_2_chunk (actual rows=2505 loops=1)
               ->  Index Scan using _hyper_1_3_chunk_skip_scan_expr_idx on _hyper_1_3_chunk (actual rows=2505 loops=1)
               ->  Index Scan using _hyper_1_4_chunk_skip_scan_expr_idx on _hyper_1_4_chunk (actual rows=2505 loops=1)
(9 rows)

DROP INDEX skip_scan_expr_idx;
CREATE INDEX ON :TABLE(dev_name);
CREATE INDEX ON :TABLE(dev);
CREATE INDEX ON :TABLE(dev, time);
CREATE INDEX ON :TABLE(time,dev);
CREATE INDEX ON :TABLE(time,dev,val);
\qecho basic DISTINCT queries on :TABLE
basic DISTINCT queries on skip_scan_ht
-- Various distint aggs over same column is OK
:PREFIX SELECT count(DISTINCT dev), sum(DISTINCT dev), 'q1_1' FROM :TABLE;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(19 rows)

:PREFIX SELECT count(DISTINCT dev_name), max(DISTINCT dev_name), 'q1_2' FROM :TABLE;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev_name
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_name_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_name_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_name_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_name_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
(19 rows)

-- Distinct agg over Const is OK
:PREFIX SELECT count(DISTINCT dev), count(DISTINCT 2), 'q1_3', NULL FROM :TABLE;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(19 rows)

-- DISTINCT over distinct agg is OK
:PREFIX SELECT DISTINCT count(DISTINCT dev), dev, 'q1_4' FROM :TABLE GROUP BY dev ORDER BY dev;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Sort (actual rows=11 loops=1)
   Sort Key: _hyper_1_1_chunk.dev
   Sort Method: quicksort 
   ->  HashAggregate (actual rows=11 loops=1)
         Group Key: _hyper_1_1_chunk.dev, count(DISTINCT _hyper_1_1_chunk.dev)
         Batches: 1 
         ->  GroupAggregate (actual rows=11 loops=1)
               Group Key: _hyper_1_1_chunk.dev
               ->  Merge Append (actual rows=44 loops=1)
                     Sort Key: _hyper_1_1_chunk.dev
                     ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
                           ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                                 Index Cond: (dev > NULL::integer)
                     ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
                           ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                                 Index Cond: (dev > NULL::integer)
                     ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
                           ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                                 Index Cond: (dev > NULL::integer)
                     ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
                           ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                                 Index Cond: (dev > NULL::integer)
(26 rows)

\qecho stable expression in targetlist on :TABLE
stable expression in targetlist on skip_scan_ht
:PREFIX SELECT count(DISTINCT dev), 'q1_5', length(md5(now()::text)) FROM :TABLE;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(19 rows)

:PREFIX SELECT count(DISTINCT dev_name), 'q1_6', length(md5(now()::text)) FROM :TABLE;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev_name
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_name_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_name_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_name_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_name_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
(19 rows)

-- volatile expression in targetlist
:PREFIX SELECT count(DISTINCT dev), 'q1_7', length(md5(random()::text)) FROM :TABLE;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(19 rows)

:PREFIX SELECT count(DISTINCT dev_name), 'q1_8', length(md5(random()::text)) FROM :TABLE;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev_name
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_name_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_name_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_name_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_name_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
(19 rows)

-- Mix of aggregates on different columns and distinct/not distinct
-- currently not supported by skipscan
:PREFIX SELECT count(DISTINCT dev), max(DISTINCT dev_name), 'q1_9' FROM :TABLE;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=10020 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Index Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=2505 loops=1)
         ->  Index Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=2505 loops=1)
         ->  Index Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=2505 loops=1)
         ->  Index Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=2505 loops=1)
(7 rows)

:PREFIX SELECT count(DISTINCT dev), sum(dev), 'q1_10' FROM :TABLE;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=10020 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=2505 loops=1)
         ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=2505 loops=1)
         ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=2505 loops=1)
         ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=2505 loops=1)
(11 rows)

:PREFIX SELECT count(DISTINCT dev), dev_name, 'q1_11' FROM :TABLE GROUP BY dev_name ORDER BY dev_name;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev_name
   ->  Sort (actual rows=10020 loops=1)
         Sort Key: _hyper_1_1_chunk.dev_name, _hyper_1_1_chunk.dev
         Sort Method: quicksort 
         ->  Result (actual rows=10020 loops=1)
               ->  Append (actual rows=10020 loops=1)
                     ->  Seq Scan on _hyper_1_1_chunk (actual rows=2505 loops=1)
                     ->  Seq Scan on _hyper_1_2_chunk (actual rows=2505 loops=1)
                     ->  Seq Scan on _hyper_1_3_chunk (actual rows=2505 loops=1)
                     ->  Seq Scan on _hyper_1_4_chunk (actual rows=2505 loops=1)
(11 rows)

-- distinct on expressions not supported
:PREFIX SELECT count(DISTINCT time_bucket(10,time)), 'q1_12' FROM :TABLE;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=10020 loops=1)
         Sort Key: (time_bucket(10, _hyper_1_1_chunk."time"))
         ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_time_dev_idx on _hyper_1_1_chunk (actual rows=2505 loops=1)
         ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_time_dev_idx on _hyper_1_2_chunk (actual rows=2505 loops=1)
         ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_time_dev_idx on _hyper_1_3_chunk (actual rows=2505 loops=1)
         ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_time_dev_idx on _hyper_1_4_chunk (actual rows=2505 loops=1)
(11 rows)

:PREFIX SELECT count(DISTINCT length(dev_name)), 'q1_13' FROM :TABLE;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Sort (actual rows=10020 loops=1)
         Sort Key: (length(_hyper_1_1_chunk.dev_name))
         Sort Method: quicksort 
         ->  Result (actual rows=10020 loops=1)
               ->  Append (actual rows=10020 loops=1)
                     ->  Seq Scan on _hyper_1_1_chunk (actual rows=2505 loops=1)
                     ->  Seq Scan on _hyper_1_2_chunk (actual rows=2505 loops=1)
                     ->  Seq Scan on _hyper_1_3_chunk (actual rows=2505 loops=1)
                     ->  Seq Scan on _hyper_1_4_chunk (actual rows=2505 loops=1)
(10 rows)

:PREFIX SELECT count(DISTINCT 3*time), 'q1_14' FROM :TABLE;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=10020 loops=1)
         Sort Key: ((3 * _hyper_1_1_chunk."time"))
         ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_time_dev_idx on _hyper_1_1_chunk (actual rows=2505 loops=1)
         ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_time_dev_idx on _hyper_1_2_chunk (actual rows=2505 loops=1)
         ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_time_dev_idx on _hyper_1_3_chunk (actual rows=2505 loops=1)
         ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_time_dev_idx on _hyper_1_4_chunk (actual rows=2505 loops=1)
(11 rows)

-- But expressions over distinct aggregates are supported
:PREFIX SELECT count(DISTINCT dev) + 1, sum(DISTINCT dev)/count(DISTINCT dev), 'q1_15' FROM :TABLE;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(19 rows)

-- DISTINCT aggs grouped on their args
:PREFIX SELECT count(DISTINCT dev), dev, 'q2_1' FROM :TABLE GROUP BY dev;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(20 rows)

:PREFIX SELECT count(DISTINCT dev), dev, 'q2_2', NULL FROM :TABLE GROUP BY dev;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(20 rows)

:PREFIX SELECT count(DISTINCT dev), dev, 'q2_3', length(md5(now()::text)) FROM :TABLE GROUP BY dev;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(20 rows)

:PREFIX SELECT count(DISTINCT dev), dev, 'q2_4', length(md5(random()::text)) FROM :TABLE GROUP BY dev;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(20 rows)

:PREFIX SELECT count(DISTINCT dev), dev, int_func_immutable(), 'q2_5' FROM :TABLE GROUP BY dev;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(20 rows)

:PREFIX SELECT count(DISTINCT dev), dev, int_func_stable(), 'q2_6' FROM :TABLE GROUP BY dev;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(20 rows)

:PREFIX SELECT count(DISTINCT dev), dev, int_func_volatile(), 'q2_7' FROM :TABLE GROUP BY dev;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(20 rows)

:PREFIX SELECT count(DISTINCT dev), dev+1, 'q2_8' FROM :TABLE GROUP BY dev ORDER BY 2;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Sort (actual rows=11 loops=1)
   Sort Key: ((_hyper_1_1_chunk.dev + 1))
   Sort Method: quicksort 
   ->  GroupAggregate (actual rows=11 loops=1)
         Group Key: _hyper_1_1_chunk.dev
         ->  Merge Append (actual rows=44 loops=1)
               Sort Key: _hyper_1_1_chunk.dev
               ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
(23 rows)

:PREFIX SELECT count(DISTINCT dev), dev+1, dev+2, 'q2_9' FROM :TABLE GROUP BY dev, dev;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(20 rows)

-- Cannot do SkipScan as we group on a column which is not the distinct agg argument
:PREFIX SELECT time, count(DISTINCT dev), 'q2_10' FROM :TABLE GROUP BY time;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=1000 loops=1)
   Group Key: _hyper_1_1_chunk."time"
   ->  Merge Append (actual rows=10020 loops=1)
         Sort Key: _hyper_1_1_chunk."time", _hyper_1_1_chunk.dev
         ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_time_dev_idx on _hyper_1_1_chunk (actual rows=2505 loops=1)
         ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_time_dev_idx on _hyper_1_2_chunk (actual rows=2505 loops=1)
         ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_time_dev_idx on _hyper_1_3_chunk (actual rows=2505 loops=1)
         ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_time_dev_idx on _hyper_1_4_chunk (actual rows=2505 loops=1)
(12 rows)

-- Cannot do SkipScan if we group on 2+ columns
:PREFIX SELECT count(DISTINCT dev), dev, tableoid::regclass, 'q2_11' FROM :TABLE GROUP BY dev, tableoid ORDER BY dev, tableoid;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 GroupAggregate (actual rows=44 loops=1)
   Group Key: _hyper_1_1_chunk.dev, skip_scan_ht.tableoid
   ->  Sort (actual rows=10020 loops=1)
         Sort Key: _hyper_1_1_chunk.dev, skip_scan_ht.tableoid
         Sort Method: quicksort 
         ->  Append (actual rows=10020 loops=1)
               ->  Seq Scan on _hyper_1_1_chunk (actual rows=2505 loops=1)
               ->  Seq Scan on _hyper_1_2_chunk (actual rows=2505 loops=1)
               ->  Seq Scan on _hyper_1_3_chunk (actual rows=2505 loops=1)
               ->  Seq Scan on _hyper_1_4_chunk (actual rows=2505 loops=1)
(10 rows)

-- DISTINCT aggs grouped on their TEXT args
:PREFIX SELECT count(DISTINCT dev_name), dev_name, 'q3_1' FROM :TABLE GROUP BY dev_name;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev_name
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev_name
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_name_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_name_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_name_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_name_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
(20 rows)

:PREFIX SELECT count(DISTINCT dev_name), dev_name, 'q3_2', NULL FROM :TABLE GROUP BY dev_name;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev_name
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev_name
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_name_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_name_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_name_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_name_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
(20 rows)

:PREFIX SELECT count(DISTINCT dev_name), dev_name, 'q3_3', length(md5(now()::text)) FROM :TABLE GROUP BY dev_name;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev_name
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev_name
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_name_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_name_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_name_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_name_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
(20 rows)

:PREFIX SELECT count(DISTINCT dev_name), dev_name, 'q3_4', length(md5(random()::text)) FROM :TABLE GROUP BY dev_name;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev_name
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev_name
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_name_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_name_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_name_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_name_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
(20 rows)

:PREFIX SELECT count(DISTINCT dev_name::varchar), dev_name::varchar, 'q3_5' FROM :TABLE GROUP BY dev_name;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev_name
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev_name
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_name_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_name_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_name_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_name_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
(20 rows)

:PREFIX SELECT count(DISTINCT dev_name), dev_name, int_func_immutable(), 'q3_6' FROM :TABLE GROUP BY dev_name;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev_name
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev_name
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_name_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_name_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_name_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_name_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
(20 rows)

:PREFIX SELECT count(DISTINCT dev_name), dev_name, int_func_stable(), 'q3_7' FROM :TABLE GROUP BY dev_name;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev_name
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev_name
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_name_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_name_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_name_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_name_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
(20 rows)

:PREFIX SELECT count(DISTINCT dev_name), dev_name, int_func_volatile(), 'q3_8' FROM :TABLE GROUP BY dev_name;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev_name
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev_name
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_name_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_name_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_name_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_name_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
(20 rows)

-- Cannot do SkipScan as we group on a column which is not the distinct agg argument
:PREFIX SELECT count(DISTINCT dev_name), dev_name, tableoid::regclass, 'q3_9' FROM :TABLE GROUP BY dev_name, tableoid ORDER BY dev_name, tableoid;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 GroupAggregate (actual rows=44 loops=1)
   Group Key: _hyper_1_1_chunk.dev_name, skip_scan_ht.tableoid
   ->  Sort (actual rows=10020 loops=1)
         Sort Key: _hyper_1_1_chunk.dev_name, skip_scan_ht.tableoid
         Sort Method: quicksort 
         ->  Append (actual rows=10020 loops=1)
               ->  Seq Scan on _hyper_1_1_chunk (actual rows=2505 loops=1)
               ->  Seq Scan on _hyper_1_2_chunk (actual rows=2505 loops=1)
               ->  Seq Scan on _hyper_1_3_chunk (actual rows=2505 loops=1)
               ->  Seq Scan on _hyper_1_4_chunk (actual rows=2505 loops=1)
(10 rows)

-- Can do SkipScan if extra group column is eliminated by pinning to a Const
-- and when it changes group by ordering
:PREFIX SELECT count(DISTINCT dev_name), dev, dev_name FROM :TABLE WHERE dev = 1 GROUP BY dev, dev_name ORDER BY dev, dev_name;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=1 loops=1)
   Group Key: _hyper_1_1_chunk.dev_name
   ->  Merge Append (actual rows=4 loops=1)
         Sort Key: _hyper_1_1_chunk.dev_name
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=1 loops=1)
               ->  Index Scan using _hyper_1_1_chunk_skip_scan_ht_dev_name_idx on _hyper_1_1_chunk (actual rows=1 loops=1)
                     Filter: (dev = 1)
                     Rows Removed by Filter: 2255
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=1 loops=1)
               ->  Index Scan using _hyper_1_2_chunk_skip_scan_ht_dev_name_idx on _hyper_1_2_chunk (actual rows=1 loops=1)
                     Filter: (dev = 1)
                     Rows Removed by Filter: 2255
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=1 loops=1)
               ->  Index Scan using _hyper_1_3_chunk_skip_scan_ht_dev_name_idx on _hyper_1_3_chunk (actual rows=1 loops=1)
                     Filter: (dev = 1)
                     Rows Removed by Filter: 2255
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=1 loops=1)
               ->  Index Scan using _hyper_1_4_chunk_skip_scan_ht_dev_name_idx on _hyper_1_4_chunk (actual rows=1 loops=1)
                     Filter: (dev = 1)
                     Rows Removed by Filter: 2255
(20 rows)

\qecho LIMIT queries on :TABLE
LIMIT queries on skip_scan_ht
:PREFIX SELECT count(DISTINCT dev), dev FROM :TABLE GROUP BY dev LIMIT 3;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=3 loops=1)
   ->  GroupAggregate (actual rows=3 loops=1)
         Group Key: _hyper_1_1_chunk.dev
         ->  Merge Append (actual rows=13 loops=1)
               Sort Key: _hyper_1_1_chunk.dev
               ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=4 loops=1)
                     ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=4 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=4 loops=1)
                     ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=4 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=4 loops=1)
                     ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=4 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=4 loops=1)
                     ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=4 loops=1)
                           Index Cond: (dev > NULL::integer)
(21 rows)

:PREFIX SELECT count(DISTINCT dev), dev FROM :TABLE GROUP BY dev ORDER BY dev DESC LIMIT 3;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=3 loops=1)
   ->  GroupAggregate (actual rows=3 loops=1)
         Group Key: _hyper_1_1_chunk.dev
         ->  Merge Append (actual rows=13 loops=1)
               Sort Key: _hyper_1_1_chunk.dev DESC
               ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=4 loops=1)
                     ->  Index Only Scan Backward using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=4 loops=1)
                           Index Cond: (dev < NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=4 loops=1)
                     ->  Index Only Scan Backward using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=4 loops=1)
                           Index Cond: (dev < NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=4 loops=1)
                     ->  Index Only Scan Backward using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=4 loops=1)
                           Index Cond: (dev < NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=4 loops=1)
                     ->  Index Only Scan Backward using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=4 loops=1)
                           Index Cond: (dev < NULL::integer)
(21 rows)

\qecho range queries on :TABLE
range queries on skip_scan_ht
:PREFIX SELECT count(DISTINCT dev), dev FROM :TABLE WHERE time BETWEEN 100 AND 300 GROUP BY dev;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev
   ->  Merge Append (actual rows=22 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_time_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: ((dev > NULL::integer) AND ("time" >= 100) AND ("time" <= 300))
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_time_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: ((dev > NULL::integer) AND ("time" >= 100) AND ("time" <= 300))
(12 rows)

:PREFIX SELECT count(DISTINCT dev), dev FROM :TABLE WHERE time < 200 GROUP BY dev;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev
   ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
         ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_time_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
               Index Cond: ((dev > NULL::integer) AND ("time" < 200))
(6 rows)

:PREFIX SELECT count(DISTINCT dev), dev FROM :TABLE WHERE time > 800 GROUP BY dev;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_4_chunk.dev
   ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
         ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_time_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
               Index Cond: ((dev > NULL::integer) AND ("time" > 800))
(6 rows)

\qecho ordered append on :TABLE
ordered append on skip_scan_ht
:PREFIX SELECT count(DISTINCT time), time FROM :TABLE WHERE time BETWEEN 0 AND 5000  GROUP BY time;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=1000 loops=1)
   Group Key: _hyper_1_1_chunk."time"
   ->  Merge Append (actual rows=1000 loops=1)
         Sort Key: _hyper_1_1_chunk."time"
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=250 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_time_dev_idx on _hyper_1_1_chunk (actual rows=250 loops=1)
                     Index Cond: (("time" > NULL::integer) AND ("time" >= 0) AND ("time" <= 5000))
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=250 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_time_dev_idx on _hyper_1_2_chunk (actual rows=250 loops=1)
                     Index Cond: (("time" > NULL::integer) AND ("time" >= 0) AND ("time" <= 5000))
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=250 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_time_dev_idx on _hyper_1_3_chunk (actual rows=250 loops=1)
                     Index Cond: (("time" > NULL::integer) AND ("time" >= 0) AND ("time" <= 5000))
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=250 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_time_dev_idx on _hyper_1_4_chunk (actual rows=250 loops=1)
                     Index Cond: (("time" > NULL::integer) AND ("time" >= 0) AND ("time" <= 5000))
(20 rows)

\qecho SUBSELECTS on :TABLE
SUBSELECTS on skip_scan_ht
:PREFIX SELECT c1, c2, 'q4_1' FROM (SELECT count(DISTINCT dev) as c1, sum(DISTINCT dev) as c2 FROM :TABLE) a;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on a (actual rows=1 loops=1)
   ->  Aggregate (actual rows=1 loops=1)
         ->  Merge Append (actual rows=44 loops=1)
               Sort Key: _hyper_1_1_chunk.dev
               ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
(20 rows)

:PREFIX SELECT NULL, dev, NULL, 'q4_2' FROM (SELECT count(DISTINCT dev) as dev FROM :TABLE) a;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on a (actual rows=1 loops=1)
   ->  Aggregate (actual rows=1 loops=1)
         ->  Merge Append (actual rows=44 loops=1)
               Sort Key: _hyper_1_1_chunk.dev
               ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
(20 rows)

:PREFIX SELECT NULL, dev, NULL, c1, 2, c3, 'q4_3' FROM (SELECT count(DISTINCT dev) as c1, dev, 1 as c3 FROM :TABLE GROUP BY dev) a;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on a (actual rows=11 loops=1)
   ->  GroupAggregate (actual rows=11 loops=1)
         Group Key: _hyper_1_1_chunk.dev
         ->  Merge Append (actual rows=44 loops=1)
               Sort Key: _hyper_1_1_chunk.dev
               ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
(21 rows)

\qecho ORDER BY
ORDER BY
:PREFIX SELECT c, dev, 'q5_1' FROM (SELECT count(DISTINCT dev) as c, dev FROM :TABLE GROUP BY dev ORDER BY dev) a;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on a (actual rows=11 loops=1)
   ->  GroupAggregate (actual rows=11 loops=1)
         Group Key: _hyper_1_1_chunk.dev
         ->  Merge Append (actual rows=44 loops=1)
               Sort Key: _hyper_1_1_chunk.dev
               ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
(21 rows)

:PREFIX SELECT c, dev, 'q5_2' FROM (SELECT count(DISTINCT dev) as c, dev FROM :TABLE GROUP BY dev ORDER BY dev DESC) a;
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on a (actual rows=11 loops=1)
   ->  GroupAggregate (actual rows=11 loops=1)
         Group Key: _hyper_1_1_chunk.dev
         ->  Merge Append (actual rows=44 loops=1)
               Sort Key: _hyper_1_1_chunk.dev DESC
               ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan Backward using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                           Index Cond: (dev < NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan Backward using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                           Index Cond: (dev < NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan Backward using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                           Index Cond: (dev < NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan Backward using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                           Index Cond: (dev < NULL::integer)
(21 rows)

\qecho WHERE CLAUSES
WHERE CLAUSES
:PREFIX SELECT c, dev, 'q6_1' FROM (SELECT count(DISTINCT dev) as c, dev FROM :TABLE WHERE dev > 5 GROUP BY dev) a;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on a (actual rows=5 loops=1)
   ->  GroupAggregate (actual rows=5 loops=1)
         Group Key: _hyper_1_1_chunk.dev
         ->  Merge Append (actual rows=20 loops=1)
               Sort Key: _hyper_1_1_chunk.dev
               ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=5 loops=1)
                     ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=5 loops=1)
                           Index Cond: ((dev > NULL::integer) AND (dev > 5))
               ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=5 loops=1)
                     ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=5 loops=1)
                           Index Cond: ((dev > NULL::integer) AND (dev > 5))
               ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=5 loops=1)
                     ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=5 loops=1)
                           Index Cond: ((dev > NULL::integer) AND (dev > 5))
               ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=5 loops=1)
                     ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=5 loops=1)
                           Index Cond: ((dev > NULL::integer) AND (dev > 5))
(21 rows)

:PREFIX SELECT c, dev, 'q6_2' FROM (SELECT sum(DISTINCT dev) as c, dev FROM :TABLE GROUP BY dev HAVING sum(DISTINCT dev)>2) a;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on a (actual rows=8 loops=1)
   ->  GroupAggregate (actual rows=8 loops=1)
         Group Key: _hyper_1_1_chunk.dev
         Filter: (sum(DISTINCT _hyper_1_1_chunk.dev) > 2)
         Rows Removed by Filter: 3
         ->  Merge Append (actual rows=44 loops=1)
               Sort Key: _hyper_1_1_chunk.dev
               ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
(23 rows)

:PREFIX SELECT c, dev, 'q6_3' FROM (SELECT count(DISTINCT dev) as c, dev FROM :TABLE GROUP BY dev) a WHERE dev > 5;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on a (actual rows=5 loops=1)
   ->  GroupAggregate (actual rows=5 loops=1)
         Group Key: _hyper_1_1_chunk.dev
         ->  Merge Append (actual rows=20 loops=1)
               Sort Key: _hyper_1_1_chunk.dev
               ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=5 loops=1)
                     ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=5 loops=1)
                           Index Cond: ((dev > NULL::integer) AND (dev > 5))
               ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=5 loops=1)
                     ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=5 loops=1)
                           Index Cond: ((dev > NULL::integer) AND (dev > 5))
               ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=5 loops=1)
                     ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=5 loops=1)
                           Index Cond: ((dev > NULL::integer) AND (dev > 5))
               ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=5 loops=1)
                     ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=5 loops=1)
                           Index Cond: ((dev > NULL::integer) AND (dev > 5))
(21 rows)

:PREFIX SELECT c, dev, 'q6_4' FROM (SELECT sum(DISTINCT dev) as c, dev FROM :TABLE GROUP BY dev) a WHERE c > 2;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on a (actual rows=8 loops=1)
   ->  GroupAggregate (actual rows=8 loops=1)
         Group Key: _hyper_1_1_chunk.dev
         Filter: (sum(DISTINCT _hyper_1_1_chunk.dev) > 2)
         Rows Removed by Filter: 3
         ->  Merge Append (actual rows=44 loops=1)
               Sort Key: _hyper_1_1_chunk.dev
               ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
(23 rows)

--\qecho immutable func in WHERE clause on :TABLE
:PREFIX SELECT count(DISTINCT dev), 'q6_5' FROM :TABLE WHERE dev > int_func_immutable();
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=36 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=9 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=9 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev > 1))
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=9 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=9 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev > 1))
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=9 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=9 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev > 1))
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=9 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=9 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev > 1))
(19 rows)

--\qecho stable func in WHERE clause on :TABLE
:PREFIX SELECT count(DISTINCT dev), 'q6_6' FROM :TABLE WHERE dev > int_func_stable();
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (ConstraintAwareAppend) (actual rows=32 loops=1)
         Hypertable: skip_scan_ht
         Chunks excluded during startup: 0
         ->  Merge Append (actual rows=32 loops=1)
               Sort Key: _hyper_1_1_chunk.dev
               ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=8 loops=1)
                     ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=8 loops=1)
                           Index Cond: ((dev > NULL::integer) AND (dev > int_func_stable()))
               ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=8 loops=1)
                     ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=8 loops=1)
                           Index Cond: ((dev > NULL::integer) AND (dev > int_func_stable()))
               ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=8 loops=1)
                     ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=8 loops=1)
                           Index Cond: ((dev > NULL::integer) AND (dev > int_func_stable()))
               ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=8 loops=1)
                     ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=8 loops=1)
                           Index Cond: ((dev > NULL::integer) AND (dev > int_func_stable()))
(22 rows)

--\qecho volatile func in WHERE clause on :TABLE:PREFIX SELECT count(DISTINCT dev), 'q6_7' FROM :TABLE WHERE dev > int_func_volatile();
:PREFIX SELECT count(DISTINCT dev), 'q6_8' FROM :TABLE WHERE dev = ANY(inta_func_immutable());
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=12 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=3 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=3 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev = ANY ('{1,2,3}'::integer[])))
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=3 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=3 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev = ANY ('{1,2,3}'::integer[])))
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=3 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=3 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev = ANY ('{1,2,3}'::integer[])))
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=3 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=3 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev = ANY ('{1,2,3}'::integer[])))
(19 rows)

:PREFIX SELECT count(DISTINCT dev), 'q6_9' FROM :TABLE WHERE dev = ANY(inta_func_stable());
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (ConstraintAwareAppend) (actual rows=12 loops=1)
         Hypertable: skip_scan_ht
         Chunks excluded during startup: 0
         ->  Merge Append (actual rows=12 loops=1)
               Sort Key: _hyper_1_1_chunk.dev
               ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=3 loops=1)
                     ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=3 loops=1)
                           Index Cond: ((dev > NULL::integer) AND (dev = ANY (inta_func_stable())))
               ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=3 loops=1)
                     ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=3 loops=1)
                           Index Cond: ((dev > NULL::integer) AND (dev = ANY (inta_func_stable())))
               ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=3 loops=1)
                     ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=3 loops=1)
                           Index Cond: ((dev > NULL::integer) AND (dev = ANY (inta_func_stable())))
               ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=3 loops=1)
                     ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=3 loops=1)
                           Index Cond: ((dev > NULL::integer) AND (dev = ANY (inta_func_stable())))
(22 rows)

:PREFIX SELECT count(DISTINCT dev), 'q6_10' FROM :TABLE WHERE dev = ANY(inta_func_volatile());
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (ConstraintAwareAppend) (actual rows=12 loops=1)
         Hypertable: skip_scan_ht
         Chunks excluded during startup: 0
         ->  Merge Append (actual rows=12 loops=1)
               Sort Key: _hyper_1_1_chunk.dev
               ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=3 loops=1)
                     ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=3 loops=1)
                           Index Cond: (dev > NULL::integer)
                           Filter: (dev = ANY (inta_func_volatile()))
                           Rows Removed by Filter: 1755
               ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=3 loops=1)
                     ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=3 loops=1)
                           Index Cond: (dev > NULL::integer)
                           Filter: (dev = ANY (inta_func_volatile()))
                           Rows Removed by Filter: 1755
               ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=3 loops=1)
                     ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=3 loops=1)
                           Index Cond: (dev > NULL::integer)
                           Filter: (dev = ANY (inta_func_volatile()))
                           Rows Removed by Filter: 1755
               ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=3 loops=1)
                     ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=3 loops=1)
                           Index Cond: (dev > NULL::integer)
                           Filter: (dev = ANY (inta_func_volatile()))
                           Rows Removed by Filter: 1755
(30 rows)

-- always false expr similar to our initial skip qual
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE WHERE dev > NULL;
                  QUERY PLAN                  
----------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Sort (actual rows=0 loops=1)
         Sort Key: dev
         Sort Method: quicksort 
         ->  Result (actual rows=0 loops=1)
               One-Time Filter: false
(6 rows)

-- no tuples matching
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE WHERE dev > 20;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=0 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=0 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=0 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev > 20))
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=0 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=0 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev > 20))
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=0 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=0 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev > 20))
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=0 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=0 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev > 20))
(19 rows)

-- multiple constraints in WHERE clause
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE WHERE dev > 5 AND time = 100;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=5 loops=1)
         ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_time_dev_val_idx on _hyper_1_1_chunk (actual rows=5 loops=1)
               Index Cond: (("time" = 100) AND (dev > NULL::integer) AND (dev > 5))
(5 rows)

:PREFIX SELECT count(DISTINCT dev) FROM :TABLE WHERE dev > 5 AND time > 200;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=20 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=5 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_time_idx on _hyper_1_1_chunk (actual rows=5 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev > 5) AND ("time" > 200))
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=5 loops=1)
               ->  Index Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=5 loops=1)
                     Index Cond: (dev > 5)
                     Filter: ("time" > 200)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=5 loops=1)
               ->  Index Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=5 loops=1)
                     Index Cond: (dev > 5)
                     Filter: ("time" > 200)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=5 loops=1)
               ->  Index Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=5 loops=1)
                     Index Cond: (dev > 5)
                     Filter: ("time" > 200)
(19 rows)

:PREFIX SELECT count(DISTINCT dev) FROM :TABLE WHERE dev >= 5 AND dev < 7 AND dev >= 2;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=8 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=2 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=2 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev >= 5) AND (dev < 7) AND (dev >= 2))
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=2 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=2 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev >= 5) AND (dev < 7) AND (dev >= 2))
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=2 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=2 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev >= 5) AND (dev < 7) AND (dev >= 2))
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=2 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=2 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev >= 5) AND (dev < 7) AND (dev >= 2))
(19 rows)

:PREFIX SELECT count(DISTINCT dev), dev FROM :TABLE WHERE time > 100 AND time < 200 AND val > 10 AND val < 10000 AND dev > 2 AND dev < 7 GROUP BY dev ORDER BY dev;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=0 loops=1)
   Group Key: _hyper_1_1_chunk.dev
   ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=0 loops=1)
         ->  Index Scan using _hyper_1_1_chunk_skip_scan_ht_dev_time_idx on _hyper_1_1_chunk (actual rows=0 loops=1)
               Index Cond: ((dev > 2) AND (dev < 7) AND ("time" > 100) AND ("time" < 200))
               Filter: ((val > 10) AND (val < 10000))
               Rows Removed by Filter: 396
(7 rows)

:PREFIX SELECT count(DISTINCT dev) FROM :TABLE WHERE dev IS NULL;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=4 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=1 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=1 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev IS NULL))
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=1 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=1 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev IS NULL))
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=1 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=1 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev IS NULL))
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=1 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=1 loops=1)
                     Index Cond: ((dev > NULL::integer) AND (dev IS NULL))
(19 rows)

:PREFIX SELECT count(DISTINCT dev_name) FROM :TABLE WHERE dev_name IS NULL;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=4 loops=1)
         Sort Key: _hyper_1_1_chunk.dev_name
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=1 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_name_idx on _hyper_1_1_chunk (actual rows=1 loops=1)
                     Index Cond: ((dev_name > NULL::text) AND (dev_name IS NULL))
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=1 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_name_idx on _hyper_1_2_chunk (actual rows=1 loops=1)
                     Index Cond: ((dev_name > NULL::text) AND (dev_name IS NULL))
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=1 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_name_idx on _hyper_1_3_chunk (actual rows=1 loops=1)
                     Index Cond: ((dev_name > NULL::text) AND (dev_name IS NULL))
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=1 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_name_idx on _hyper_1_4_chunk (actual rows=1 loops=1)
                     Index Cond: ((dev_name > NULL::text) AND (dev_name IS NULL))
(19 rows)

-- Distinct aggregate path with no pathkeys because of Const predicate.
-- PG is smart to add LIMIT 1 to SELECT DISTINCT in this case,
-- but not smart enough to add LIMIT 1 to distinct aggregate input.
-- TODO: create an issue for this task, i.e. add LIMIT 1 to distinct aggregate input when input equals to a Const
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE WHERE dev = 1;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Append (actual rows=1000 loops=1)
         ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=250 loops=1)
               Index Cond: (dev = 1)
         ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=250 loops=1)
               Index Cond: (dev = 1)
         ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=250 loops=1)
               Index Cond: (dev = 1)
         ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=250 loops=1)
               Index Cond: (dev = 1)
(14 rows)

:PREFIX SELECT count(DISTINCT dev), dev FROM :TABLE WHERE dev = 1 GROUP BY dev ORDER BY dev DESC;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=1 loops=1)
   ->  Append (actual rows=1000 loops=1)
         ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=250 loops=1)
               Index Cond: (dev = 1)
         ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=250 loops=1)
               Index Cond: (dev = 1)
         ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=250 loops=1)
               Index Cond: (dev = 1)
         ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=250 loops=1)
               Index Cond: (dev = 1)
(14 rows)

-- CTE
:PREFIX WITH devices AS (
	SELECT count(DISTINCT dev) FROM :TABLE
)
SELECT * FROM devices;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(19 rows)

:PREFIX WITH devices AS (
	SELECT dev, count(DISTINCT dev) FROM :TABLE GROUP BY dev
)
SELECT * FROM devices ORDER BY dev;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=11 loops=1)
   Group Key: _hyper_1_1_chunk.dev
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(20 rows)

-- prepared statements
PREPARE prep AS SELECT count(DISTINCT dev_name) FROM :TABLE;
:PREFIX EXECUTE prep;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev_name
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_name_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_name_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_name_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_name_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
(19 rows)

:PREFIX EXECUTE prep;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev_name
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_name_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_name_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_name_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_name_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
(19 rows)

:PREFIX EXECUTE prep;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev_name
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_name_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_name_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_name_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_name_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev_name > NULL::text)
(19 rows)

DEALLOCATE prep;
-- ReScan tests
:PREFIX SELECT c, 'q7_1' FROM (SELECT count(DISTINCT dev) c FROM (
    VALUES (1), (2)) a(v),
    LATERAL (SELECT * FROM :TABLE WHERE time != a.v) b) a;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on a (actual rows=1 loops=1)
   ->  Aggregate (actual rows=1 loops=1)
         ->  Nested Loop (actual rows=20020 loops=1)
               Join Filter: (_hyper_1_1_chunk."time" <> "*VALUES*".column1)
               Rows Removed by Join Filter: 20
               ->  Merge Append (actual rows=10020 loops=1)
                     Sort Key: _hyper_1_1_chunk.dev
                     ->  Index Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=2505 loops=1)
                     ->  Index Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=2505 loops=1)
                     ->  Index Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=2505 loops=1)
                     ->  Index Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=2505 loops=1)
               ->  Materialize (actual rows=2 loops=10020)
                     ->  Values Scan on "*VALUES*" (actual rows=2 loops=1)
(13 rows)

:PREFIX SELECT c, 'q7_2' FROM (SELECT * FROM (
    VALUES (1), (2)) a(v),
    LATERAL (SELECT count(DISTINCT dev) c FROM :TABLE WHERE dev != a.v) b) a;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Nested Loop (actual rows=2 loops=1)
   ->  Values Scan on "*VALUES*" (actual rows=2 loops=1)
   ->  Aggregate (actual rows=1 loops=2)
         ->  Merge Append (actual rows=36 loops=2)
               Sort Key: _hyper_1_1_chunk.dev
               ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=9 loops=2)
                     ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=9 loops=2)
                           Index Cond: (dev > NULL::integer)
                           Filter: (dev <> "*VALUES*".column1)
                           Rows Removed by Filter: 255
               ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=9 loops=2)
                     ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=9 loops=2)
                           Index Cond: (dev > NULL::integer)
                           Filter: (dev <> "*VALUES*".column1)
                           Rows Removed by Filter: 255
               ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=9 loops=2)
                     ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=9 loops=2)
                           Index Cond: (dev > NULL::integer)
                           Filter: (dev <> "*VALUES*".column1)
                           Rows Removed by Filter: 255
               ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=9 loops=2)
                     ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=9 loops=2)
                           Index Cond: (dev > NULL::integer)
                           Filter: (dev <> "*VALUES*".column1)
                           Rows Removed by Filter: 255
(29 rows)

-- RuntimeKeys
:PREFIX SELECT c, 'q8_1' FROM (SELECT * FROM (VALUES (1), (2)) a(v), LATERAL (SELECT count(DISTINCT dev) c FROM :TABLE WHERE dev >= a.v) b) c;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Nested Loop (actual rows=2 loops=1)
   ->  Values Scan on "*VALUES*" (actual rows=2 loops=1)
   ->  Aggregate (actual rows=1 loops=2)
         ->  Merge Append (actual rows=38 loops=2)
               Sort Key: _hyper_1_1_chunk.dev
               ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=10 loops=2)
                     ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=10 loops=2)
                           Index Cond: ((dev > NULL::integer) AND (dev >= "*VALUES*".column1))
               ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=10 loops=2)
                     ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=10 loops=2)
                           Index Cond: ((dev > NULL::integer) AND (dev >= "*VALUES*".column1))
               ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=10 loops=2)
                     ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=10 loops=2)
                           Index Cond: ((dev > NULL::integer) AND (dev >= "*VALUES*".column1))
               ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=10 loops=2)
                     ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=10 loops=2)
                           Index Cond: ((dev > NULL::integer) AND (dev >= "*VALUES*".column1))
(21 rows)

--  DISTINCT aggs on different columns in different subqueries
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE UNION ALL SELECT count(DISTINCT time) FROM :TABLE;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Append (actual rows=2 loops=1)
   ->  Aggregate (actual rows=1 loops=1)
         ->  Merge Append (actual rows=44 loops=1)
               Sort Key: _hyper_1_1_chunk.dev
               ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
   ->  Aggregate (actual rows=1 loops=1)
         ->  Merge Append (actual rows=1000 loops=1)
               Sort Key: _hyper_1_1_chunk_1."time"
               ->  Custom Scan (SkipScan) on _hyper_1_1_chunk _hyper_1_1_chunk_1 (actual rows=250 loops=1)
                     ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_time_dev_idx on _hyper_1_1_chunk _hyper_1_1_chunk_1 (actual rows=250 loops=1)
                           Index Cond: ("time" > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_2_chunk _hyper_1_2_chunk_1 (actual rows=250 loops=1)
                     ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_time_dev_idx on _hyper_1_2_chunk _hyper_1_2_chunk_1 (actual rows=250 loops=1)
                           Index Cond: ("time" > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_3_chunk _hyper_1_3_chunk_1 (actual rows=250 loops=1)
                     ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_time_dev_idx on _hyper_1_3_chunk _hyper_1_3_chunk_1 (actual rows=250 loops=1)
                           Index Cond: ("time" > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_4_chunk _hyper_1_4_chunk_1 (actual rows=250 loops=1)
                     ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_time_dev_idx on _hyper_1_4_chunk _hyper_1_4_chunk_1 (actual rows=250 loops=1)
                           Index Cond: ("time" > NULL::integer)
(39 rows)

:PREFIX SELECT *, 'q9_2' FROM (SELECT count(DISTINCT dev) cd, dev FROM :TABLE GROUP BY dev) a, LATERAL (SELECT count(DISTINCT time) ct FROM :TABLE WHERE dev = a.dev) b;
                                                                         QUERY PLAN                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop (actual rows=11 loops=1)
   ->  GroupAggregate (actual rows=11 loops=1)
         Group Key: _hyper_1_1_chunk.dev
         ->  Merge Append (actual rows=44 loops=1)
               Sort Key: _hyper_1_1_chunk.dev
               ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
               ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
                     ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                           Index Cond: (dev > NULL::integer)
   ->  Aggregate (actual rows=1 loops=11)
         ->  Merge Append (actual rows=909 loops=11)
               Sort Key: _hyper_1_1_chunk_1."time"
               ->  Custom Scan (SkipScan) on _hyper_1_1_chunk _hyper_1_1_chunk_1 (actual rows=227 loops=11)
                     ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_time_idx on _hyper_1_1_chunk _hyper_1_1_chunk_1 (actual rows=227 loops=11)
                           Index Cond: ((dev = _hyper_1_1_chunk.dev) AND ("time" > NULL::integer))
               ->  Custom Scan (SkipScan) on _hyper_1_2_chunk _hyper_1_2_chunk_1 (actual rows=227 loops=11)
                     ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_time_idx on _hyper_1_2_chunk _hyper_1_2_chunk_1 (actual rows=227 loops=11)
                           Index Cond: ((dev = _hyper_1_1_chunk.dev) AND ("time" > NULL::integer))
               ->  Custom Scan (SkipScan) on _hyper_1_3_chunk _hyper_1_3_chunk_1 (actual rows=227 loops=11)
                     ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_time_idx on _hyper_1_3_chunk _hyper_1_3_chunk_1 (actual rows=227 loops=11)
                           Index Cond: ((dev = _hyper_1_1_chunk.dev) AND ("time" > NULL::integer))
               ->  Custom Scan (SkipScan) on _hyper_1_4_chunk _hyper_1_4_chunk_1 (actual rows=227 loops=11)
                     ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_time_idx on _hyper_1_4_chunk _hyper_1_4_chunk_1 (actual rows=227 loops=11)
                           Index Cond: ((dev = _hyper_1_1_chunk.dev) AND ("time" > NULL::integer))
(40 rows)

-- SkipScan into INSERT
:PREFIX INSERT INTO skip_scan_insert(dev, val, query) SELECT dev, sd, 'q10_1' FROM (SELECT sum(DISTINCT dev) sd, dev FROM :TABLE GROUP BY dev) a;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Insert on skip_scan_insert (actual rows=0 loops=1)
   ->  Subquery Scan on a (actual rows=11 loops=1)
         ->  GroupAggregate (actual rows=11 loops=1)
               Group Key: _hyper_1_1_chunk.dev
               ->  Merge Append (actual rows=44 loops=1)
                     Sort Key: _hyper_1_1_chunk.dev
                     ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
                           ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                                 Index Cond: (dev > NULL::integer)
                     ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
                           ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                                 Index Cond: (dev > NULL::integer)
                     ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
                           ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                                 Index Cond: (dev > NULL::integer)
                     ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
                           ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                                 Index Cond: (dev > NULL::integer)
(22 rows)

-- parallel query
SELECT set_config(CASE WHEN current_setting('server_version_num')::int < 160000 THEN 'force_parallel_mode' ELSE 'debug_parallel_query' END,'on', false);
 set_config 
------------
 on
(1 row)

:PREFIX SELECT count(DISTINCT dev) FROM :TABLE;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(19 rows)

SELECT set_config(CASE WHEN current_setting('server_version_num')::int < 160000 THEN 'force_parallel_mode' ELSE 'debug_parallel_query' END,'off', false);
 set_config 
------------
 off
(1 row)

TRUNCATE skip_scan_insert;
-- table with only nulls
:PREFIX SELECT count(DISTINCT time) FROM skip_scan_nulls;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan_nulls (actual rows=1 loops=1)
         ->  Index Only Scan using skip_scan_nulls_time_idx on skip_scan_nulls (actual rows=1 loops=1)
               Index Cond: ("time" > NULL::integer)
(5 rows)

-- no tuples in resultset
:PREFIX SELECT count(DISTINCT time) FROM skip_scan_nulls WHERE time IS NOT NULL;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on skip_scan_nulls (actual rows=0 loops=1)
         ->  Index Only Scan using skip_scan_nulls_time_idx on skip_scan_nulls (actual rows=0 loops=1)
               Index Cond: (("time" > NULL::integer) AND ("time" IS NOT NULL))
(5 rows)

\ir include/skip_scan_dagg_query_ht.sql
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
CREATE INDEX ON :TABLE(dev);
CREATE INDEX ON :TABLE(time);
-- IndexPath without pathkeys doesnt use SkipScan
EXPLAIN (costs off, timing off, summary off) SELECT count(DISTINCT 1) FROM pg_rewrite;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Aggregate
   ->  Index Only Scan using pg_rewrite_rel_rulename_index on pg_rewrite
(2 rows)

:PREFIX SELECT count(DISTINCT dev) FROM :TABLE where dev=1;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Append (actual rows=1000 loops=1)
         ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx1 on _hyper_1_1_chunk (actual rows=250 loops=1)
               Index Cond: (dev = 1)
         ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx1 on _hyper_1_2_chunk (actual rows=250 loops=1)
               Index Cond: (dev = 1)
         ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx1 on _hyper_1_3_chunk (actual rows=250 loops=1)
               Index Cond: (dev = 1)
         ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx1 on _hyper_1_4_chunk (actual rows=250 loops=1)
               Index Cond: (dev = 1)
(14 rows)

-- SkipScan with ordered append
:PREFIX SELECT count(DISTINCT time), time FROM :TABLE GROUP BY time ORDER BY time;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate (actual rows=1000 loops=1)
   Group Key: skip_scan_ht."time"
   ->  Custom Scan (ChunkAppend) on skip_scan_ht (actual rows=1000 loops=1)
         Order: skip_scan_ht."time"
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=250 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_time_idx on _hyper_1_1_chunk (actual rows=250 loops=1)
                     Index Cond: ("time" > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=250 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_time_idx on _hyper_1_2_chunk (actual rows=250 loops=1)
                     Index Cond: ("time" > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=250 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_time_idx on _hyper_1_3_chunk (actual rows=250 loops=1)
                     Index Cond: ("time" > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=250 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_time_idx on _hyper_1_4_chunk (actual rows=250 loops=1)
                     Index Cond: ("time" > NULL::integer)
(20 rows)

--baseline query with skipscan
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx1 on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx1 on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx1 on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx1 on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(19 rows)

-- compression on one chunk doesnt prevent skipscan on other chunks
SELECT compress_chunk('_timescaledb_internal._hyper_1_1_chunk');
             compress_chunk             
----------------------------------------
 _timescaledb_internal._hyper_1_1_chunk
(1 row)

:PREFIX SELECT count(DISTINCT dev) FROM :TABLE;
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=2538 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (DecompressChunk) on _hyper_1_1_chunk (actual rows=2505 loops=1)
               ->  Index Scan using compress_hyper_2_5_chunk_dev__ts_meta_min_1__ts_meta_max_1_idx on compress_hyper_2_5_chunk (actual rows=11 loops=1)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx1 on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx1 on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx1 on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(17 rows)

-- compression on one chunk will prevent skipscan if it's the only chunk remaining
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE WHERE time = 100;
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (DecompressChunk) on _hyper_1_1_chunk (actual rows=11 loops=1)
         Vectorized Filter: ("time" = 100)
         Rows Removed by Filter: 2494
         ->  Index Scan using compress_hyper_2_5_chunk_dev__ts_meta_min_1__ts_meta_max_1_idx on compress_hyper_2_5_chunk (actual rows=11 loops=1)
               Index Cond: ((_ts_meta_min_1 <= 100) AND (_ts_meta_max_1 >= 100))
(6 rows)

SELECT decompress_chunk('_timescaledb_internal._hyper_1_1_chunk');
            decompress_chunk            
----------------------------------------
 _timescaledb_internal._hyper_1_1_chunk
(1 row)

-- skipscan will be applied on decompressed chunk if it's the only chunk remaining
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE WHERE time = 100;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
         ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_time_dev_val_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
               Index Cond: (("time" = 100) AND (dev > NULL::integer))
(5 rows)

--baseline query with skipscan
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_idx1 on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx1 on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx1 on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx1 on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(19 rows)

-- partial indexes don't prevent skipscan
DROP INDEX _timescaledb_internal._hyper_1_1_chunk_skip_scan_ht_dev_idx;
DROP INDEX _timescaledb_internal._hyper_1_1_chunk_skip_scan_ht_dev_idx1;
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=44 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Custom Scan (SkipScan) on _hyper_1_1_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_1_chunk_skip_scan_ht_dev_time_idx on _hyper_1_1_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx1 on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx1 on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx1 on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(19 rows)

DROP INDEX _timescaledb_internal._hyper_1_1_chunk_skip_scan_ht_dev_time_idx;
:PREFIX SELECT count(DISTINCT dev) FROM :TABLE;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Merge Append (actual rows=2538 loops=1)
         Sort Key: _hyper_1_1_chunk.dev
         ->  Sort (actual rows=2505 loops=1)
               Sort Key: _hyper_1_1_chunk.dev
               Sort Method: quicksort 
               ->  Seq Scan on _hyper_1_1_chunk (actual rows=2505 loops=1)
         ->  Custom Scan (SkipScan) on _hyper_1_2_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_2_chunk_skip_scan_ht_dev_idx1 on _hyper_1_2_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_3_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_3_chunk_skip_scan_ht_dev_idx1 on _hyper_1_3_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
         ->  Custom Scan (SkipScan) on _hyper_1_4_chunk (actual rows=11 loops=1)
               ->  Index Only Scan using _hyper_1_4_chunk_skip_scan_ht_dev_idx1 on _hyper_1_4_chunk (actual rows=11 loops=1)
                     Index Cond: (dev > NULL::integer)
(19 rows)

