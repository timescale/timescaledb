-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
\c :TEST_DBNAME :ROLE_SUPERUSER
create function stable_abs(x int4) returns int4 as 'int4abs' language internal stable;
create table vectorqual(metric1 int8, ts timestamp, metric2 int8, device int8);
select create_hypertable('vectorqual', 'ts');
WARNING:  column type "timestamp without time zone" used for "ts" does not follow best practices
NOTICE:  adding not-null constraint to column "ts"
    create_hypertable    
-------------------------
 (1,public,vectorqual,t)
(1 row)

alter table vectorqual set (timescaledb.compress, timescaledb.compress_segmentby = 'device');
NOTICE:  default order by for hypertable "vectorqual" is set to "ts DESC"
insert into vectorqual(ts, device, metric1, metric2) values ('2020-01-01 00:00:00', 1, 11, 12);
select count(compress_chunk(x, true)) from show_chunks('vectorqual') x;
 count 
-------
     1
(1 row)

alter table vectorqual drop column metric1;
insert into vectorqual(ts, device, metric2) values ('2021-01-01 00:00:00', 2, 22);
select count(compress_chunk(x, true)) from show_chunks('vectorqual') x;
NOTICE:  chunk "_hyper_1_1_chunk" is already compressed
 count 
-------
     2
(1 row)

alter table vectorqual add column metric3 int4 default 777;
insert into vectorqual(ts, device, metric2, metric3) values ('2022-01-01 00:00:00', 3, 32, 33);
select count(compress_chunk(x, true)) from show_chunks('vectorqual') x;
NOTICE:  chunk "_hyper_1_1_chunk" is already compressed
NOTICE:  chunk "_hyper_1_3_chunk" is already compressed
 count 
-------
     3
(1 row)

alter table vectorqual add column metric4 int8;
insert into vectorqual(ts, device, metric2, metric3, metric4) values ('2023-01-01 00:00:00', 4, 42, 43, 44);
select count(compress_chunk(x, true)) from show_chunks('vectorqual') x;
NOTICE:  chunk "_hyper_1_1_chunk" is already compressed
NOTICE:  chunk "_hyper_1_3_chunk" is already compressed
NOTICE:  chunk "_hyper_1_5_chunk" is already compressed
 count 
-------
     4
(1 row)

select * from vectorqual order by vectorqual;
            ts            | metric2 | device | metric3 | metric4 
--------------------------+---------+--------+---------+---------
 Wed Jan 01 00:00:00 2020 |      12 |      1 |     777 |        
 Fri Jan 01 00:00:00 2021 |      22 |      2 |     777 |        
 Sat Jan 01 00:00:00 2022 |      32 |      3 |      33 |        
 Sun Jan 01 00:00:00 2023 |      42 |      4 |      43 |      44
(4 rows)

-- single chunk
select * from vectorqual where ts between '2019-02-02' and '2020-02-02' order by vectorqual;
            ts            | metric2 | device | metric3 | metric4 
--------------------------+---------+--------+---------+---------
 Wed Jan 01 00:00:00 2020 |      12 |      1 |     777 |        
(1 row)

select * from vectorqual where ts between '2020-02-02' and '2021-02-02' order by vectorqual;
            ts            | metric2 | device | metric3 | metric4 
--------------------------+---------+--------+---------+---------
 Fri Jan 01 00:00:00 2021 |      22 |      2 |     777 |        
(1 row)

select * from vectorqual where ts between '2021-02-02' and '2022-02-02' order by vectorqual;
            ts            | metric2 | device | metric3 | metric4 
--------------------------+---------+--------+---------+---------
 Sat Jan 01 00:00:00 2022 |      32 |      3 |      33 |        
(1 row)

select * from vectorqual where ts between '2022-02-02' and '2023-02-02' order by vectorqual;
            ts            | metric2 | device | metric3 | metric4 
--------------------------+---------+--------+---------+---------
 Sun Jan 01 00:00:00 2023 |      42 |      4 |      43 |      44
(1 row)

set timescaledb.debug_require_vector_qual to 'require' /* all following quals must be vectorized */;
select count(*) from vectorqual where ts > '1999-01-01 00:00:00';
 count 
-------
     4
(1 row)

select count(*) from vectorqual where metric2 = 22;
 count 
-------
     1
(1 row)

select count(*) from vectorqual where 22 = metric2 /* commutators */;
 count 
-------
     1
(1 row)

select count(*) from vectorqual where metric3 = 33;
 count 
-------
     1
(1 row)

select count(*) from vectorqual where metric3 = 777 /* default value */;
 count 
-------
     2
(1 row)

select count(*) from vectorqual where metric4 = 44 /* column with default null */;
 count 
-------
     1
(1 row)

select count(*) from vectorqual where metric4 >= 0 /* nulls shouldn't pass the qual */;
 count 
-------
     1
(1 row)

set timescaledb.debug_require_vector_qual to 'forbid';
select count(*) from vectorqual where device = 1 /* can't apply vector ops to the segmentby column */;
 count 
-------
     1
(1 row)

-- Test various combinations of arithmetic types.
create table arithmetic(ts int, a int2, b int4, c int8, d float4, e float8,
    ax int2, bx int4, cx int8, dx float4, ex float8);
select create_hypertable('arithmetic', 'ts');
NOTICE:  adding not-null constraint to column "ts"
    create_hypertable    
-------------------------
 (3,public,arithmetic,t)
(1 row)

alter table arithmetic set (timescaledb.compress);
WARNING:  there was some uncertainty picking the default segment by for the hypertable: You do not have any indexes on columns that can be used for segment_by and thus we are not using segment_by for compression. Please make sure you are not missing any indexes
NOTICE:  default segment by for hypertable "arithmetic" is set to ""
NOTICE:  default order by for hypertable "arithmetic" is set to "ts DESC"
insert into arithmetic values (100, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
    (101, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11);
select count(compress_chunk(x, true)) from show_chunks('arithmetic') x;
 count 
-------
     1
(1 row)

set timescaledb.debug_require_vector_qual to 'require';
select * from arithmetic where
        a > 1::int2 and a > 1::int4 and a > 1::int8
    and b > 1::int2 and b > 1::int4 and b > 1::int8
    and c > 1::int2 and c > 1::int4 and c > 1::int8
    and d > 1::int2 and d > 1::int4 and d > 1::int8 and d > 1::float4 and d > 1::float8
    and e > 1::int2 and e > 1::int4 and e > 1::int8 and e > 1::float4 and e > 1::float8
;
 ts  | a | b | c | d | e | ax | bx | cx | dx | ex 
-----+---+---+---+---+---+----+----+----+----+----
 101 | 2 | 3 | 4 | 5 | 6 |  7 |  8 |  9 | 10 | 11
(1 row)

-- Test columns that don't support bulk decompression.
alter table vectorqual add column tag name;
insert into vectorqual(ts, device, metric2, metric3, metric4, tag) values ('2025-01-01 00:00:00', 5, 52, 53, 54, 'tag5');
select count(compress_chunk(x, true)) from show_chunks('vectorqual') x;
NOTICE:  chunk "_hyper_1_1_chunk" is already compressed
NOTICE:  chunk "_hyper_1_3_chunk" is already compressed
NOTICE:  chunk "_hyper_1_5_chunk" is already compressed
NOTICE:  chunk "_hyper_1_7_chunk" is already compressed
 count 
-------
     5
(1 row)

set timescaledb.debug_require_vector_qual to 'require';
select tag from vectorqual where metric2 > 0;
 tag  
------
 
 
 
 
 tag5
(5 rows)

-- Can't vectorize parameterized join clauses for now.
set timescaledb.debug_require_vector_qual to 'forbid';
set enable_hashjoin to off;
set enable_mergejoin to off;
with values(x) as materialized(select distinct metric2 from vectorqual)
    select x, (select metric2 from vectorqual where metric2 = x) from values order by 1;
 x  | metric2 
----+---------
 12 |      12
 22 |      22
 32 |      32
 42 |      42
 52 |      52
(5 rows)

reset enable_hashjoin;
reset enable_mergejoin;
-- Can't vectorize initplan parameters either.
select count(*) from vectorqual where metric2
    = (select metric2 from vectorqual order by 1 limit 1);
 count 
-------
     1
(1 row)

-- Can vectorize clauses with query parameters.
set timescaledb.debug_require_vector_qual to 'require';
set plan_cache_mode to 'force_generic_plan';
prepare p as select count(*) from vectorqual where metric3 = $1;
execute p(33);
 count 
-------
     1
(1 row)

deallocate p;
-- Also try query parameter in combination with a stable function.
prepare p(int4) as select count(*) from vectorqual where metric3 = stable_abs($1);
execute p(33);
 count 
-------
     1
(1 row)

deallocate p;
reset plan_cache_mode;
-- Queries without aggregation.
set timescaledb.debug_require_vector_qual to 'require';
select * from vectorqual where ts > '2021-01-01 00:00:00' order by vectorqual;
            ts            | metric2 | device | metric3 | metric4 | tag  
--------------------------+---------+--------+---------+---------+------
 Sat Jan 01 00:00:00 2022 |      32 |      3 |      33 |         | 
 Sun Jan 01 00:00:00 2023 |      42 |      4 |      43 |      44 | 
 Wed Jan 01 00:00:00 2025 |      52 |      5 |      53 |      54 | tag5
(3 rows)

select * from vectorqual where metric4 >= 0 order by vectorqual;
            ts            | metric2 | device | metric3 | metric4 | tag  
--------------------------+---------+--------+---------+---------+------
 Sun Jan 01 00:00:00 2023 |      42 |      4 |      43 |      44 | 
 Wed Jan 01 00:00:00 2025 |      52 |      5 |      53 |      54 | tag5
(2 rows)

-- Constraints on columns not selected.
select metric4 from vectorqual where ts > '2021-01-01 00:00:00' order by 1;
 metric4 
---------
      44
      54
        
(3 rows)

-- ANDed constraints on multiple columns.
select * from vectorqual where ts > '2021-01-01 00:00:00' and metric3 > 40 order by vectorqual;
            ts            | metric2 | device | metric3 | metric4 | tag  
--------------------------+---------+--------+---------+---------+------
 Sun Jan 01 00:00:00 2023 |      42 |      4 |      43 |      44 | 
 Wed Jan 01 00:00:00 2025 |      52 |      5 |      53 |      54 | tag5
(2 rows)

-- ORed constrainst on multiple columns.
set timescaledb.debug_require_vector_qual to 'require';
-- set timescaledb.debug_require_vector_qual to 'forbid';
-- set timescaledb.enable_bulk_decompression to off;
select * from vectorqual where ts > '2021-01-01 00:00:00' or metric3 > 40 order by vectorqual;
            ts            | metric2 | device | metric3 | metric4 | tag  
--------------------------+---------+--------+---------+---------+------
 Wed Jan 01 00:00:00 2020 |      12 |      1 |     777 |         | 
 Fri Jan 01 00:00:00 2021 |      22 |      2 |     777 |         | 
 Sat Jan 01 00:00:00 2022 |      32 |      3 |      33 |         | 
 Sun Jan 01 00:00:00 2023 |      42 |      4 |      43 |      44 | 
 Wed Jan 01 00:00:00 2025 |      52 |      5 |      53 |      54 | tag5
(5 rows)

-- Some more tests for boolean operations.
select count(*) from vectorqual where ts > '2021-01-01 00:00:00';
 count 
-------
     3
(1 row)

select count(*) from vectorqual where 40 < metric3;
 count 
-------
     4
(1 row)

select count(*) from vectorqual where metric2 < 0;
 count 
-------
     0
(1 row)

select count(*) from vectorqual where ts > '2021-01-01 00:00:00' or 40 < metric3;
 count 
-------
     5
(1 row)

select count(*) from vectorqual where not (ts <= '2021-01-01 00:00:00' and 40 >= metric3);
 count 
-------
     5
(1 row)

-- early exit inside AND BoolExpr
select count(*) from vectorqual where metric2 < 0 or (metric4 < -1 and 40 >= metric3);
 count 
-------
     0
(1 row)

-- early exit after OR BoolExpr
select count(*) from vectorqual where metric2 < 0 or metric3  < -1;
 count 
-------
     0
(1 row)

-- expression evaluated to null at run time
select count(*) from vectorqual where metric3 = 777
    or metric3 > case when now() > now() - interval '1s' then null else 1 end;
 count 
-------
     2
(1 row)

reset timescaledb.enable_bulk_decompression;
-- Test with unary operator.
set timescaledb.debug_require_vector_qual to 'forbid';
create operator !! (function = 'bool', rightarg = int4);
select count(*) from vectorqual where !!metric3;
 count 
-------
     5
(1 row)

select count(*) from vectorqual where not !!metric3;
 count 
-------
     0
(1 row)

-- Custom operator on column that supports bulk decompression is not vectorized.
set timescaledb.debug_require_vector_qual to 'forbid';
create function int4eqq(int4, int4) returns bool as 'int4eq' language internal;
create operator === (function = 'int4eqq', rightarg = int4, leftarg = int4);
select count(*) from vectorqual where metric3 === 777;
 count 
-------
     2
(1 row)

select count(*) from vectorqual where metric3 === any(array[777, 888]);
 count 
-------
     2
(1 row)

select count(*) from vectorqual where not metric3 === 777;
 count 
-------
     3
(1 row)

select count(*) from vectorqual where metric3 = 777 or metric3 === 777;
 count 
-------
     2
(1 row)

-- Custom operator that can be vectorized but doesn't have a negator.
create operator !!! (function = 'int4ne', rightarg = int4, leftarg = int4);
set timescaledb.debug_require_vector_qual to 'require';
select count(*) from vectorqual where metric3 !!! 777;
 count 
-------
     3
(1 row)

select count(*) from vectorqual where metric3 !!! any(array[777, 888]);
 count 
-------
     5
(1 row)

select count(*) from vectorqual where metric3 !!! 777 or metric3 !!! 888;
 count 
-------
     5
(1 row)

select count(*) from vectorqual where metric3 !!! 666 and (metric3 !!! 777 or metric3 !!! 888);
 count 
-------
     5
(1 row)

select count(*) from vectorqual where metric3 !!! 666 and (metric3 !!! 777 or metric3 !!! stable_abs(888));
 count 
-------
     5
(1 row)

set timescaledb.debug_require_vector_qual to 'forbid';
select count(*) from vectorqual where not metric3 !!! 777;
 count 
-------
     2
(1 row)

select count(*) from vectorqual where metric3 !!! 666 or (metric3 !!! 777 and not metric3 !!! 888);
 count 
-------
     5
(1 row)

select count(*) from vectorqual where metric3 !!! 666 or not (metric3 !!! 777 and not metric3 !!! 888);
 count 
-------
     5
(1 row)

set timescaledb.debug_require_vector_qual to 'allow';
select count(*) from vectorqual where metric3 !!! 777 or not metric3 !!! 888;
 count 
-------
     3
(1 row)

select count(*) from vectorqual where metric3 !!! 777 and not metric3 !!! 888;
 count 
-------
     0
(1 row)

select count(*) from vectorqual where not(metric3 !!! 666 or not (metric3 !!! 777 and not metric3 !!! 888));
 count 
-------
     0
(1 row)

-- These operators don't have a commutator.
set timescaledb.debug_require_vector_qual to 'forbid';
select count(*) from vectorqual where 777 === metric3;
 count 
-------
     2
(1 row)

select count(*) from vectorqual where 777 !!! metric3;
 count 
-------
     3
(1 row)

-- NullTest is vectorized.
set timescaledb.debug_require_vector_qual to 'require';
select count(*) from vectorqual where metric4 is null;
 count 
-------
     3
(1 row)

select count(*) from vectorqual where metric4 is not null;
 count 
-------
     2
(1 row)

select count(*) from vectorqual where metric3 = 777 or metric4 is not null;
 count 
-------
     4
(1 row)

select count(*) from vectorqual where metric3 = stable_abs(777) or metric4 is null;
 count 
-------
     3
(1 row)

-- Can't vectorize conditions on system columns. Have to check this on a single
-- chunk, otherwise the whole-row var will be masked by ConvertRowType.
select show_chunks('vectorqual') chunk1 limit 1 \gset
set timescaledb.debug_require_vector_qual to 'forbid';
select count(*) from :chunk1 t where t is null;
 count 
-------
     0
(1 row)

select count(*) from :chunk1 t where t.* is null;
 count 
-------
     0
(1 row)

select count(*) from :chunk1 t where tableoid is null;
 count 
-------
     0
(1 row)

-- Scalar array operators are vectorized if the operator is vectorizable.
set timescaledb.debug_require_vector_qual to 'require';
select count(*) from vectorqual where metric3 = any(array[777, 888]); /* default value */
 count 
-------
     2
(1 row)

select count(*) from vectorqual where metric4 = any(array[44, 55]) /* default null */;
 count 
-------
     1
(1 row)

select count(*) from vectorqual where metric2 > any(array[-1, -2, -3]) /* any */;
 count 
-------
     5
(1 row)

select count(*) from vectorqual where metric2 > all(array[-1, -2, -3]) /* all */;
 count 
-------
     5
(1 row)

-- Also have to support null array elements, because they are impossible to
-- prevent in stable expressions.
set timescaledb.debug_require_vector_qual to 'require';
select count(*) from vectorqual where metric2 = any(array[null::int]) /* any with null element */;
 count 
-------
     0
(1 row)

select count(*) from vectorqual where metric2 = any(array[22, null]) /* any with null element */;
 count 
-------
     1
(1 row)

select count(*) from vectorqual where metric2 = any(array[null, 32]) /* any with null element */;
 count 
-------
     1
(1 row)

select count(*) from vectorqual where metric2 = any(array[22, null, 32]) /* any with null element */;
 count 
-------
     2
(1 row)

select count(*) from vectorqual where metric2 = all(array[null::int]) /* all with null element */;
 count 
-------
     0
(1 row)

select count(*) from vectorqual where metric2 = all(array[22, null]) /* all with null element */;
 count 
-------
     0
(1 row)

select count(*) from vectorqual where metric2 = all(array[null, 32]) /* all with null element */;
 count 
-------
     0
(1 row)

select count(*) from vectorqual where metric2 = all(array[22, null, 32]) /* all with null element */;
 count 
-------
     0
(1 row)

-- Check early exit.
reset timescaledb.debug_require_vector_qual;
create table singlebatch(like vectorqual);
select create_hypertable('singlebatch', 'ts');
WARNING:  column type "timestamp without time zone" used for "ts" does not follow best practices
    create_hypertable     
--------------------------
 (5,public,singlebatch,t)
(1 row)

alter table singlebatch set (timescaledb.compress);
WARNING:  there was some uncertainty picking the default segment by for the hypertable: You do not have any indexes on columns that can be used for segment_by and thus we are not using segment_by for compression. Please make sure you are not missing any indexes
NOTICE:  default segment by for hypertable "singlebatch" is set to ""
NOTICE:  default order by for hypertable "singlebatch" is set to "ts DESC"
insert into singlebatch select '2022-02-02 02:02:02', metric2, device, metric3, metric4, tag from vectorqual;
select count(compress_chunk(x, true)) from show_chunks('singlebatch') x;
 count 
-------
     1
(1 row)

set timescaledb.debug_require_vector_qual to 'require';
-- Uncomment to generate the test reference w/o the vector optimizations.
-- set timescaledb.enable_bulk_decompression to off;
-- set timescaledb.debug_require_vector_qual to 'forbid';
select count(*) from singlebatch where metric2 = any(array[0, 0, 0, 0, 22]);
 count 
-------
     1
(1 row)

select count(*) from singlebatch where metric2 = any(array[0, 22, 0, 0, 0]);
 count 
-------
     1
(1 row)

select count(*) from singlebatch where metric2 = any(array[0, 0, 0, 0, 0]);
 count 
-------
     0
(1 row)

select count(*) from singlebatch where metric2 != any(array[0, 0, 0, 0, 0]);
 count 
-------
     5
(1 row)

select count(*) from singlebatch where metric2 <= all(array[12, 12, 12, 12, 0]);
 count 
-------
     0
(1 row)

select count(*) from singlebatch where metric2 <= all(array[12, 0, 12, 12, 12]);
 count 
-------
     0
(1 row)

select count(*) from singlebatch where metric2 <= all(array[12, 12, 12, 12, 12]);
 count 
-------
     1
(1 row)

select count(*) from singlebatch where metric3 = 777 and metric2 = any(array[0, 0, 0, 0, 22]);
 count 
-------
     1
(1 row)

select count(*) from singlebatch where metric3 = 777 and metric2 = any(array[0, 22, 0, 0, 0]);
 count 
-------
     1
(1 row)

select count(*) from singlebatch where metric3 = 777 and metric2 = any(array[0, 0, 0, 0, 0]);
 count 
-------
     0
(1 row)

select count(*) from singlebatch where metric3 = 777 and metric2 != any(array[0, 0, 0, 0, 0]);
 count 
-------
     2
(1 row)

select count(*) from singlebatch where metric3 = 777 and metric2 <= all(array[12, 12, 12, 12, 0]);
 count 
-------
     0
(1 row)

select count(*) from singlebatch where metric3 = 777 and metric2 <= all(array[12, 0, 12, 12, 12]);
 count 
-------
     0
(1 row)

select count(*) from singlebatch where metric3 = 777 and metric2 <= all(array[12, 12, 12, 12, 12]);
 count 
-------
     1
(1 row)

select count(*) from singlebatch where metric2 = any(array[0, 0, 0, 0, 22]) and metric3 = 777;
 count 
-------
     1
(1 row)

select count(*) from singlebatch where metric2 = any(array[0, 22, 0, 0, 0]) and metric3 = 777;
 count 
-------
     1
(1 row)

select count(*) from singlebatch where metric2 = any(array[0, 0, 0, 0, 0]) and metric3 = 777;
 count 
-------
     0
(1 row)

select count(*) from singlebatch where metric2 != any(array[0, 0, 0, 0, 0]) and metric3 = 777;
 count 
-------
     2
(1 row)

select count(*) from singlebatch where metric2 <= all(array[12, 12, 12, 12, 0]) and metric3 = 777;
 count 
-------
     0
(1 row)

select count(*) from singlebatch where metric2 <= all(array[12, 0, 12, 12, 12]) and metric3 = 777;
 count 
-------
     0
(1 row)

select count(*) from singlebatch where metric2 <= all(array[12, 12, 12, 12, 12]) and metric3 = 777;
 count 
-------
     1
(1 row)

select count(*) from singlebatch where metric3 != 777 and metric2 = any(array[0, 0, 0, 0, 22]);
 count 
-------
     0
(1 row)

select count(*) from singlebatch where metric3 != 777 and metric2 = any(array[0, 22, 0, 0, 0]);
 count 
-------
     0
(1 row)

select count(*) from singlebatch where metric3 != 777 and metric2 = any(array[0, 0, 0, 0, 0]);
 count 
-------
     0
(1 row)

select count(*) from singlebatch where metric3 != 777 and metric2 != any(array[0, 0, 0, 0, 0]);
 count 
-------
     3
(1 row)

select count(*) from singlebatch where metric3 != 777 and metric2 <= all(array[12, 12, 12, 12, 0]);
 count 
-------
     0
(1 row)

select count(*) from singlebatch where metric3 != 777 and metric2 <= all(array[12, 0, 12, 12, 12]);
 count 
-------
     0
(1 row)

select count(*) from singlebatch where metric3 != 777 and metric2 <= all(array[12, 12, 12, 12, 12]);
 count 
-------
     0
(1 row)

select count(*) from singlebatch where metric2 = any(array[0, 0, 0, 0, 22]) and metric3 != 777;
 count 
-------
     0
(1 row)

select count(*) from singlebatch where metric2 = any(array[0, 22, 0, 0, 0]) and metric3 != 777;
 count 
-------
     0
(1 row)

select count(*) from singlebatch where metric2 = any(array[0, 0, 0, 0, 0]) and metric3 != 777;
 count 
-------
     0
(1 row)

select count(*) from singlebatch where metric2 != any(array[0, 0, 0, 0, 0]) and metric3 != 777;
 count 
-------
     3
(1 row)

select count(*) from singlebatch where metric2 <= all(array[12, 12, 12, 12, 0]) and metric3 != 777;
 count 
-------
     0
(1 row)

select count(*) from singlebatch where metric2 <= all(array[12, 0, 12, 12, 12]) and metric3 != 777;
 count 
-------
     0
(1 row)

select count(*) from singlebatch where metric2 <= all(array[12, 12, 12, 12, 12]) and metric3 != 777;
 count 
-------
     0
(1 row)

-- Also check early exit for AND/OR. Top-level clause must be OR, because top-level
-- AND is flattened into a list.
select count(*) from singlebatch where (metric2 < 20 and metric2 < 30) or metric3 = 777;
 count 
-------
     2
(1 row)

select count(*) from singlebatch where (metric2 < 30 and metric2 < 20) or metric3 = 777;
 count 
-------
     2
(1 row)

select count(*) from singlebatch where metric3 = 777 or (metric2 < 20 and metric2 < 30);
 count 
-------
     2
(1 row)

select count(*) from singlebatch where metric3 = 777 or (metric2 < 30 and metric2 < 20);
 count 
-------
     2
(1 row)

select count(*) from vectorqual where (metric2 < 20 and metric2 < 30) or metric3 = 777;
 count 
-------
     2
(1 row)

select count(*) from vectorqual where (metric2 < 30 and metric2 < 20) or metric3 = 777;
 count 
-------
     2
(1 row)

select count(*) from vectorqual where metric3 = 777 or (metric2 < 20 and metric2 < 30);
 count 
-------
     2
(1 row)

select count(*) from vectorqual where metric3 = 777 or (metric2 < 30 and metric2 < 20);
 count 
-------
     2
(1 row)

select count(*) from singlebatch where metric2 < 20 or metric3 < 50 or metric3 > 50;
 count 
-------
     5
(1 row)

select count(*) from singlebatch where metric2 < 20 or metric3 > 50 or metric3 < 50;
 count 
-------
     5
(1 row)

select count(*) from singlebatch where metric3 < 50 or metric2 < 20 or metric3 > 50;
 count 
-------
     5
(1 row)

select count(*) from singlebatch where metric3 > 50 or metric3 < 50 or metric2 < 20;
 count 
-------
     5
(1 row)

select count(*) from vectorqual where metric2 < 20 or metric3 < 50 or metric3 > 50;
 count 
-------
     5
(1 row)

select count(*) from vectorqual where metric2 < 20 or metric3 > 50 or metric3 < 50;
 count 
-------
     5
(1 row)

select count(*) from vectorqual where metric3 < 50 or metric2 < 20 or metric3 > 50;
 count 
-------
     5
(1 row)

select count(*) from vectorqual where metric3 > 50 or metric3 < 50 or metric2 < 20;
 count 
-------
     5
(1 row)

select count(*) from singlebatch where metric2 = 12 or metric3 = 888;
 count 
-------
     1
(1 row)

select count(*) from singlebatch where metric2 = 22 or metric3 = 888;
 count 
-------
     1
(1 row)

select count(*) from singlebatch where metric2 = 32 or metric3 = 888;
 count 
-------
     1
(1 row)

select count(*) from singlebatch where metric2 = 42 or metric3 = 888;
 count 
-------
     1
(1 row)

select count(*) from singlebatch where metric2 = 52 or metric3 = 888;
 count 
-------
     1
(1 row)

select count(*) from vectorqual where metric2 = 12 or metric3 = 888;
 count 
-------
     1
(1 row)

select count(*) from vectorqual where metric2 = 22 or metric3 = 888;
 count 
-------
     1
(1 row)

select count(*) from vectorqual where metric2 = 32 or metric3 = 888;
 count 
-------
     1
(1 row)

select count(*) from vectorqual where metric2 = 42 or metric3 = 888;
 count 
-------
     1
(1 row)

select count(*) from vectorqual where metric2 = 52 or metric3 = 888;
 count 
-------
     1
(1 row)

select count(*) from singlebatch where ts > '2024-01-01' or (metric3 = 777 and metric2 = 12);
 count 
-------
     1
(1 row)

select count(*) from singlebatch where ts > '2024-01-01' or (metric3 = 777 and metric2 = 666);
 count 
-------
     0
(1 row)

select count(*) from singlebatch where ts > '2024-01-01' or (metric3 = 888 and metric2 = 12);
 count 
-------
     0
(1 row)

select count(*) from singlebatch where ts > '2024-01-01' or (metric3 = 888 and metric2 = 666);
 count 
-------
     0
(1 row)

select count(*) from vectorqual where ts > '2024-01-01' or (metric3 = 777 and metric2 = 12);
 count 
-------
     2
(1 row)

select count(*) from vectorqual where ts > '2024-01-01' or (metric3 = 777 and metric2 = 666);
 count 
-------
     1
(1 row)

select count(*) from vectorqual where ts > '2024-01-01' or (metric3 = 888 and metric2 = 12);
 count 
-------
     1
(1 row)

select count(*) from vectorqual where ts > '2024-01-01' or (metric3 = 888 and metric2 = 666);
 count 
-------
     1
(1 row)

-- On versions >= 14, the Postgres planner chooses to build a hash table for
-- large arrays. We currently don't vectorize in this case.
select 1 from set_config('timescaledb.debug_require_vector_qual',
    case when current_setting('server_version_num')::int >= 140000 then 'forbid' else 'require' end,
    false);
 ?column? 
----------
        1
(1 row)

select count(*) from singlebatch where metric2 = any(array[
 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
90, 91, 92, 93, 94, 95, 96, 97, 98, 99
]::int8[]);
 count 
-------
     5
(1 row)

reset timescaledb.enable_bulk_decompression;
reset timescaledb.debug_require_vector_qual;
-- Comparison with other column not vectorized.
set timescaledb.debug_require_vector_qual to 'forbid';
select count(*) from vectorqual where metric3 = metric4;
 count 
-------
     0
(1 row)

select count(*) from vectorqual where metric3 = any(array[metric4]);
 count 
-------
     0
(1 row)

-- Vectorized filters also work if we have only stable functions on the right
-- side that can be evaluated to a constant at run time.
set timescaledb.debug_require_vector_qual to 'require';
select count(*) from vectorqual where ts > '2021-01-01 00:00:00'::timestamptz::timestamp;
 count 
-------
     3
(1 row)

select count(*) from vectorqual where ts > '2021-01-01 00:00:00'::timestamp - interval '1 day';
 count 
-------
     4
(1 row)

-- Expression that evaluates to Null.
select count(*) from vectorqual where ts > case when '2021-01-01'::timestamp < '2022-01-01'::timestamptz then null else '2021-01-01 00:00:00'::timestamp end;
 count 
-------
     0
(1 row)

select count(*) from vectorqual where ts < LOCALTIMESTAMP + '3 years'::interval;
 count 
-------
     5
(1 row)

-- These filters are not vectorizable as written, because the 'timestamp > timestamptz'
-- operator is stable, not immutable. We will try to cast the constant to the
-- same type in this case.
set timescaledb.debug_require_vector_qual to 'require';
select count(*) from vectorqual where ts > '2021-01-01 00:00:00'::timestamptz;
 count 
-------
     3
(1 row)

select count(*) from vectorqual where ts < LOCALTIMESTAMP at time zone 'UTC' + '3 years'::interval;
 count 
-------
     5
(1 row)

-- Can't vectorize comparison with a volatile function.
set timescaledb.debug_require_vector_qual to 'forbid';
select count(*) from vectorqual where metric3 > random()::int - 100;
 count 
-------
     5
(1 row)

select count(*) from vectorqual where ts > case when random() < 10 then null else '2021-01-01 00:00:00'::timestamp end;
 count 
-------
     0
(1 row)

-- Test that the vectorized quals are disabled by disabling the bulk decompression.
set timescaledb.enable_bulk_decompression to off;
set timescaledb.debug_require_vector_qual to 'forbid';
select count(*) from vectorqual where metric4 > null;
 count 
-------
     0
(1 row)

set timescaledb.enable_bulk_decompression to on;
-- Test that the debug GUC works
\set ON_ERROR_STOP 0
set timescaledb.debug_require_vector_qual to 'forbid';
select count(*) from vectorqual where metric4 > 4;
ERROR:  debug: encountered vector quals when they are disabled
set timescaledb.debug_require_vector_qual to 'require';
select count(*) from vectorqual where metric3 === 4;
ERROR:  debug: encountered non-vector quals when they are disabled
\set ON_ERROR_STOP 1
-- Date columns
create table date_table(ts date);
select create_hypertable('date_table', 'ts');
NOTICE:  adding not-null constraint to column "ts"
    create_hypertable    
-------------------------
 (7,public,date_table,t)
(1 row)

alter table date_table set (timescaledb.compress);
WARNING:  there was some uncertainty picking the default segment by for the hypertable: You do not have any indexes on columns that can be used for segment_by and thus we are not using segment_by for compression. Please make sure you are not missing any indexes
NOTICE:  default segment by for hypertable "date_table" is set to ""
NOTICE:  default order by for hypertable "date_table" is set to "ts DESC"
insert into date_table values ('2021-01-01'), ('2021-01-02'),
    ('2021-01-03');
select count(compress_chunk(x, true)) from show_chunks('date_table') x;
 count 
-------
     1
(1 row)

set timescaledb.debug_require_vector_qual to 'require';
select * from date_table where ts >  '2021-01-02';
     ts     
------------
 01-03-2021
(1 row)

select * from date_table where ts >= '2021-01-02';
     ts     
------------
 01-03-2021
 01-02-2021
(2 rows)

select * from date_table where ts =  '2021-01-02';
     ts     
------------
 01-02-2021
(1 row)

select * from date_table where ts <= '2021-01-02';
     ts     
------------
 01-02-2021
 01-01-2021
(2 rows)

select * from date_table where ts <  '2021-01-02';
     ts     
------------
 01-01-2021
(1 row)

select * from date_table where ts <  CURRENT_DATE;
     ts     
------------
 01-03-2021
 01-02-2021
 01-01-2021
(3 rows)

-- Text columns.
create table text_table(ts int, d int);
select create_hypertable('text_table', 'ts');
NOTICE:  adding not-null constraint to column "ts"
    create_hypertable    
-------------------------
 (9,public,text_table,t)
(1 row)

alter table text_table set (timescaledb.compress, timescaledb.compress_segmentby = 'd');
NOTICE:  default order by for hypertable "text_table" is set to "ts DESC"
insert into text_table select x, 0 /*, default */ from generate_series(1, 1000) x;
select count(compress_chunk(x, true)) from show_chunks('text_table') x;
 count 
-------
     1
(1 row)

alter table text_table add column a text default 'default';
insert into text_table select x, 1, '' from generate_series(1, 1000) x;
insert into text_table select x, 2, 'same' from generate_series(1, 1000) x;
insert into text_table select x, 3, 'different' || x from generate_series(1, 1000) x;
insert into text_table select x, 4, case when x % 2 = 0 then null else 'same-with-nulls' end from generate_series(1, 1000) x;
insert into text_table select x, 5, case when x % 2 = 0 then null else 'different-with-nulls' || x end from generate_series(1, 1000) x;
insert into text_table select x, 6, 'одинаковый' from generate_series(1, 1000) x;
insert into text_table select x, 7, '異なる' || x from generate_series(1, 1000) x;
-- Some text values with varying lengths in a single batch. They are all different
-- to prevent dictionary compression, because we want to test particular orders
-- here as well.
insert into text_table select x,       8, repeat(        x::text || 'a',         x) from generate_series(1, 100) x;
insert into text_table select x + 100, 8, repeat((101 - x)::text || 'b', (101 - x)) from generate_series(1, 100) x;
insert into text_table select x + 200, 8, repeat((101 - x)::text || 'c', (101 - x)) from generate_series(1, 100) x;
insert into text_table select x + 300, 8, repeat(        x::text || 'd',         x) from generate_series(1, 100) x;
-- Use uncompressed table as reference.
set timescaledb.debug_require_vector_qual to 'forbid';
select sum(length(a)) from text_table;
  sum   
--------
 118551
(1 row)

select count(distinct a) from text_table;
 count 
-------
  2905
(1 row)

select count(compress_chunk(x, true)) from show_chunks('text_table') x;
 count 
-------
     1
(1 row)

select compress_chunk(x) from show_chunks('text_table') x;
NOTICE:  chunk "_hyper_9_17_chunk" is already compressed
             compress_chunk              
-----------------------------------------
 _timescaledb_internal._hyper_9_17_chunk
(1 row)

-- Check result with decompression.
set timescaledb.enable_bulk_decompression to on;
set timescaledb.debug_require_vector_qual to 'forbid';
select sum(length(a)) from text_table;
  sum   
--------
 118551
(1 row)

select count(distinct a) from text_table;
 count 
-------
  2905
(1 row)

-- Test vectorized predicates.
set timescaledb.debug_require_vector_qual to 'require';
-- -- Uncomment to generate the test reference w/o the vector optimizations.
-- set timescaledb.enable_bulk_decompression to off;
-- set timescaledb.debug_require_vector_qual to 'forbid';
select count(*), min(ts), max(ts), min(d), max(d) from text_table where a = 'default';
 count | min | max  | min | max 
-------+-----+------+-----+-----
  1000 |   1 | 1000 |   0 |   0
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a = '';
 count | min | max  | min | max 
-------+-----+------+-----+-----
  1000 |   1 | 1000 |   1 |   1
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a = 'same';
 count | min | max  | min | max 
-------+-----+------+-----+-----
  1000 |   1 | 1000 |   2 |   2
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a != 'same';
 count | min | max  | min | max 
-------+-----+------+-----+-----
  6400 |   1 | 1000 |   0 |   8
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a = 'одинаковый';
 count | min | max  | min | max 
-------+-----+------+-----+-----
  1000 |   1 | 1000 |   6 |   6
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a = 'same-with-nulls';
 count | min | max | min | max 
-------+-----+-----+-----+-----
   500 |   1 | 999 |   4 |   4
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a = 'different1';
 count | min | max | min | max 
-------+-----+-----+-----+-----
     1 |   1 |   1 |   3 |   3
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a = '異なる1';
 count | min | max | min | max 
-------+-----+-----+-----+-----
     1 |   1 |   1 |   7 |   7
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a = 'different-with-nulls1';
 count | min | max | min | max 
-------+-----+-----+-----+-----
     1 |   1 |   1 |   5 |   5
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a = 'different1000';
 count | min  | max  | min | max 
-------+------+------+-----+-----
     1 | 1000 | 1000 |   3 |   3
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a = 'different-with-nulls999';
 count | min | max | min | max 
-------+-----+-----+-----+-----
     1 | 999 | 999 |   5 |   5
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a in ('same', 'different500');
 count | min | max  | min | max 
-------+-----+------+-----+-----
  1001 |   1 | 1000 |   2 |   3
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a in ('same-with-nulls', 'different-with-nulls499');
 count | min | max | min | max 
-------+-----+-----+-----+-----
   501 |   1 | 999 |   4 |   5
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a in ('different500', 'default');
 count | min | max  | min | max 
-------+-----+------+-----+-----
  1001 |   1 | 1000 |   0 |   3
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a = 'different500' or a = 'default';
 count | min | max  | min | max 
-------+-----+------+-----+-----
  1001 |   1 | 1000 |   0 |   3
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a is null;
 count | min | max  | min | max 
-------+-----+------+-----+-----
  1000 |   2 | 1000 |   4 |   5
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a is not null;
 count | min | max  | min | max 
-------+-----+------+-----+-----
  7400 |   1 | 1000 |   0 |   8
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like '%same%';
 count | min | max  | min | max 
-------+-----+------+-----+-----
  1500 |   1 | 1000 |   2 |   4
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like '%одинаковый%';
 count | min | max  | min | max 
-------+-----+------+-----+-----
  1000 |   1 | 1000 |   6 |   6
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like '%одилаковый%';
 count | min | max | min | max 
-------+-----+-----+-----+-----
     0 |     |     |     |    
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like '%одимаковый%';
 count | min | max | min | max 
-------+-----+-----+-----+-----
     0 |     |     |     |    
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like '%異なる%';
 count | min | max  | min | max 
-------+-----+------+-----+-----
  1000 |   1 | 1000 |   7 |   7
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like '%異オる%';
 count | min | max | min | max 
-------+-----+-----+-----+-----
     0 |     |     |     |    
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like '%異にる%';
 count | min | max | min | max 
-------+-----+-----+-----+-----
     0 |     |     |     |    
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like '異_る_';
 count | min | max | min | max 
-------+-----+-----+-----+-----
     9 |   1 |   9 |   7 |   7
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like '%';
 count | min | max  | min | max 
-------+-----+------+-----+-----
  7400 |   1 | 1000 |   0 |   8
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like '%different1%';
 count | min | max  | min | max 
-------+-----+------+-----+-----
   112 |   1 | 1000 |   3 |   3
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like '%different1';
 count | min | max | min | max 
-------+-----+-----+-----+-----
     1 |   1 |   1 |   3 |   3
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like 'different%%';
 count | min | max  | min | max 
-------+-----+------+-----+-----
  1500 |   1 | 1000 |   3 |   5
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like 'different%%1';
 count | min | max | min | max 
-------+-----+-----+-----+-----
   200 |   1 | 991 |   3 |   5
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like 'different%\1';
 count | min | max | min | max 
-------+-----+-----+-----+-----
   200 |   1 | 991 |   3 |   5
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like 'different%_';
 count | min | max  | min | max 
-------+-----+------+-----+-----
  1500 |   1 | 1000 |   3 |   5
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like 'different%__';
 count | min | max  | min | max 
-------+-----+------+-----+-----
  1491 |   1 | 1000 |   3 |   5
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like 'different%___';
 count | min | max  | min | max 
-------+-----+------+-----+-----
  1401 |   1 | 1000 |   3 |   5
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like 'different%_1';
 count | min | max | min | max 
-------+-----+-----+-----+-----
   199 |   1 | 991 |   3 |   5
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like 'different%nulls_';
 count | min | max | min | max 
-------+-----+-----+-----+-----
     5 |   1 |   9 |   5 |   5
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like 'different1%';
 count | min | max  | min | max 
-------+-----+------+-----+-----
   112 |   1 | 1000 |   3 |   3
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like 'different\%';
 count | min | max | min | max 
-------+-----+-----+-----+-----
     0 |     |     |     |    
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like 'different\1';
 count | min | max | min | max 
-------+-----+-----+-----+-----
     1 |   1 |   1 |   3 |   3
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like 'different_%1';
 count | min | max | min | max 
-------+-----+-----+-----+-----
   199 |   1 | 991 |   3 |   5
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like 'different_';
 count | min | max | min | max 
-------+-----+-----+-----+-----
     9 |   1 |   9 |   3 |   3
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like 'different_1';
 count | min | max | min | max 
-------+-----+-----+-----+-----
     9 |  11 |  91 |   3 |   3
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like 'same_';
 count | min | max | min | max 
-------+-----+-----+-----+-----
     0 |     |     |     |    
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a not like '%different1%';
 count | min | max  | min | max 
-------+-----+------+-----+-----
  7288 |   1 | 1000 |   0 |   8
(1 row)

\set ON_ERROR_STOP 0
select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like 'different\';
ERROR:  LIKE pattern must not end with escape character
select count(*), min(ts), max(ts), min(d), max(d) from text_table where a like 'different%\';
ERROR:  LIKE pattern must not end with escape character
\set ON_ERROR_STOP 1
-- We don't vectorize comparison operators with text because they are probably
-- not very useful.
set timescaledb.debug_require_vector_qual to 'forbid';
select count(*), min(ts), max(ts), min(d), max(d) from text_table where a < 'same';
 count | min | max  | min | max 
-------+-----+------+-----+-----
  3900 |   1 | 1000 |   0 |   8
(1 row)

select count(*), min(ts), max(ts), min(d), max(d) from text_table where a > 'same';
 count | min | max  | min | max 
-------+-----+------+-----+-----
  2500 |   1 | 1000 |   4 |   7
(1 row)

reset timescaledb.debug_require_vector_qual;
reset timescaledb.enable_bulk_decompression;
