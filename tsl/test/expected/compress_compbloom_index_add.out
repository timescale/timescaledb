-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
---------------------------------------------------------------------
-- Index added after partial compression
---------------------------------------------------------------------
CREATE TABLE mixed_avail_add(ts timestamptz, a int, b int, seg int);
SELECT create_hypertable('mixed_avail_add', by_range('ts', interval '1 day'));
 create_hypertable 
-------------------
 (1,t)

ALTER TABLE mixed_avail_add SET (
    timescaledb.compress,
    timescaledb.compress_segmentby = 'seg',
    timescaledb.compress_orderby = 'ts'
);
-- Insert and compress first 2 chunks (no composite bloom)
INSERT INTO mixed_avail_add
SELECT ts, (i % 10), (i % 5), 1
FROM generate_series('2024-01-01'::timestamptz, '2024-01-03', interval '1 hour') ts,
     generate_series(1, 100) i;
SELECT compress_chunk(c) FROM show_chunks('mixed_avail_add') c LIMIT 2;
             compress_chunk             
----------------------------------------
 _timescaledb_internal._hyper_1_1_chunk
 _timescaledb_internal._hyper_1_2_chunk

-- Before index add
EXPLAIN (ANALYZE, BUFFERS OFF, COSTS OFF, TIMING OFF, SUMMARY OFF)
SELECT * FROM mixed_avail_add WHERE a = 1 AND b = 2
ORDER BY 1,2,3,4;
--- QUERY PLAN ---
 Custom Scan (ChunkAppend) on mixed_avail_add (actual rows=0.00 loops=1)
   Order: mixed_avail_add.ts, mixed_avail_add.seg
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_1_1_chunk.ts, _hyper_1_1_chunk.seg
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_1_1_chunk (actual rows=0.00 loops=1)
               Vectorized Filter: ((a = 1) AND (b = 2))
               Rows Removed by Filter: 1600
               ->  Seq Scan on compress_hyper_2_4_chunk (actual rows=2.00 loops=1)
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_1_2_chunk.ts, _hyper_1_2_chunk.seg
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_1_2_chunk (actual rows=0.00 loops=1)
               Vectorized Filter: ((a = 1) AND (b = 2))
               Rows Removed by Filter: 2400
               ->  Seq Scan on compress_hyper_2_5_chunk (actual rows=3.00 loops=1)
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_1_3_chunk.ts, _hyper_1_3_chunk.seg
         Sort Method: quicksort 
         ->  Seq Scan on _hyper_1_3_chunk (actual rows=0.00 loops=1)
               Filter: ((a = 1) AND (b = 2))
               Rows Removed by Filter: 900

-- Create index
CREATE INDEX idx_ab ON mixed_avail_add (a, b);
-- Compress last chunk (will have composite bloom from new index)
SELECT compress_chunk(c) FROM show_chunks('mixed_avail_add') c OFFSET 2;
NOTICE:  chunk "_hyper_1_1_chunk" is already converted to columnstore
NOTICE:  chunk "_hyper_1_2_chunk" is already converted to columnstore
             compress_chunk             
----------------------------------------
 _timescaledb_internal._hyper_1_3_chunk

-- Query should work on all chunks
SELECT COUNT(*) FROM mixed_avail_add WHERE a = 1 AND b = 2;
 count 
-------
     0

-- After index add
EXPLAIN (ANALYZE, BUFFERS OFF, COSTS OFF, TIMING OFF, SUMMARY OFF)
SELECT * FROM mixed_avail_add WHERE a = 1 AND b = 2
ORDER BY 1,2,3,4;
--- QUERY PLAN ---
 Custom Scan (ChunkAppend) on mixed_avail_add (actual rows=0.00 loops=1)
   Order: mixed_avail_add.ts, mixed_avail_add.seg
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_1_1_chunk.ts, _hyper_1_1_chunk.seg
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_1_1_chunk (actual rows=0.00 loops=1)
               Vectorized Filter: ((a = 1) AND (b = 2))
               Rows Removed by Filter: 1600
               ->  Seq Scan on compress_hyper_2_4_chunk (actual rows=2.00 loops=1)
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_1_2_chunk.ts, _hyper_1_2_chunk.seg
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_1_2_chunk (actual rows=0.00 loops=1)
               Vectorized Filter: ((a = 1) AND (b = 2))
               Rows Removed by Filter: 2400
               ->  Seq Scan on compress_hyper_2_5_chunk (actual rows=3.00 loops=1)
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_1_3_chunk.ts, _hyper_1_3_chunk.seg
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_1_3_chunk (actual rows=0.00 loops=1)
               Vectorized Filter: ((a = 1) AND (b = 2))
               ->  Seq Scan on compress_hyper_2_6_chunk (actual rows=0.00 loops=1)
                     Filter: (_timescaledb_functions.bloom1_contains_hashes(regress-test-bloom_a_b, '{-3537141470987660334}'::bigint[]) AND _timescaledb_functions.bloom1_contains_hashes(regress-test-bloom_a, '{4717996019076358352}'::bigint[]) AND _timescaledb_functions.bloom1_contains_hashes(regress-test-bloom_b, '{2060787363917578834}'::bigint[]))
                     Rows Removed by Filter: 1

DROP TABLE IF EXISTS mixed_avail_add CASCADE;
