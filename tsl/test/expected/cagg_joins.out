-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
\set VERBOSITY default
SET timezone TO PST8PDT;
CREATE TABLE conditions(
  day TIMESTAMPTZ NOT NULL,
  city text NOT NULL,
  temperature INT NOT NULL,
  device_id int NOT NULL
);
SELECT table_name FROM create_hypertable('conditions', 'day', chunk_time_interval => INTERVAL '1 day');
 table_name 
------------
 conditions
(1 row)

INSERT INTO conditions (day, city, temperature, device_id) VALUES
  ('2021-06-14', 'Moscow', 26,1),
  ('2021-06-15', 'Berlin', 22,2),
  ('2021-06-16', 'Stockholm', 24,3),
  ('2021-06-17', 'London', 24,4),
  ('2021-06-18', 'London', 27,4),
  ('2021-06-19', 'Moscow', 28,4),
  ('2021-06-20', 'Moscow', 30,1),
  ('2021-06-21', 'Berlin', 31,1),
  ('2021-06-22', 'Stockholm', 34,1),
  ('2021-06-23', 'Stockholm', 34,2),
  ('2021-06-24', 'Moscow', 34,2),
  ('2021-06-25', 'London', 32,3),
  ('2021-06-26', 'Moscow', 32,3),
  ('2021-06-27', 'Moscow', 31,3);
CREATE TABLE conditions_dup AS SELECT * FROM conditions;
SELECT table_name FROM create_hypertable('conditions_dup', 'day', chunk_time_interval => INTERVAL '1 day', migrate_data => true);
NOTICE:  adding not-null constraint to column "day"
DETAIL:  Dimensions cannot have NULL values.
NOTICE:  migrating data to chunks
DETAIL:  Migration might take a while depending on the amount of data.
   table_name   
----------------
 conditions_dup
(1 row)

CREATE TABLE devices ( device_id int not null, name text, location text);
INSERT INTO devices values (1, 'thermo_1', 'Moscow'), (2, 'thermo_2', 'Berlin'),(3, 'thermo_3', 'London'),(4, 'thermo_4', 'Stockholm');
CREATE TABLE location (location_id INTEGER, name TEXT);
INSERT INTO location VALUES (1, 'Moscow'), (2, 'Berlin'), (3, 'London'), (4, 'Stockholm');
CREATE TABLE devices_dup AS SELECT * FROM devices;
CREATE VIEW devices_view AS SELECT * FROM devices;
-- Cagg with inner join + realtime  aggregate
CREATE MATERIALIZED VIEW cagg_realtime
WITH (timescaledb.continuous, timescaledb.materialized_only = FALSE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM conditions, devices
WHERE conditions.device_id = devices.device_id
GROUP BY name, bucket
ORDER BY bucket;
NOTICE:  refreshing continuous aggregate "cagg_realtime"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
\d+ cagg_realtime
                                 View "public.cagg_realtime"
 Column |           Type           | Collation | Nullable | Default | Storage  | Description 
--------+--------------------------+-----------+----------+---------+----------+-------------
 bucket | timestamp with time zone |           |          |         | plain    | 
 avg    | numeric                  |           |          |         | main     | 
 name   | text                     |           |          |         | extended | 
View definition:
( SELECT _materialized_hypertable_3.bucket,
    _materialized_hypertable_3.avg,
    _materialized_hypertable_3.name
   FROM _timescaledb_internal._materialized_hypertable_3
  WHERE _materialized_hypertable_3.bucket < COALESCE(_timescaledb_functions.to_timestamp(_timescaledb_functions.cagg_watermark(3)), '-infinity'::timestamp with time zone)
  ORDER BY _materialized_hypertable_3.bucket)
UNION ALL
( SELECT time_bucket('@ 1 day'::interval, conditions.day) AS bucket,
    avg(conditions.temperature) AS avg,
    devices.name
   FROM conditions,
    devices
  WHERE conditions.device_id = devices.device_id AND conditions.day >= COALESCE(_timescaledb_functions.to_timestamp(_timescaledb_functions.cagg_watermark(3)), '-infinity'::timestamp with time zone)
  GROUP BY devices.name, (time_bucket('@ 1 day'::interval, conditions.day))
  ORDER BY (time_bucket('@ 1 day'::interval, conditions.day)))
  ORDER BY 1;

SELECT * FROM cagg_realtime ORDER BY bucket, name;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000 | thermo_1
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000 | thermo_2
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000 | thermo_3
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000 | thermo_4
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000 | thermo_4
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000 | thermo_4
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000 | thermo_1
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000 | thermo_1
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000 | thermo_3
(14 rows)

INSERT INTO conditions (day, city, temperature, device_id) VALUES
  ('2021-06-30', 'Moscow', 28, 3);
SELECT * FROM cagg_realtime ORDER BY bucket, name;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000 | thermo_1
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000 | thermo_2
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000 | thermo_3
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000 | thermo_4
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000 | thermo_4
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000 | thermo_4
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000 | thermo_1
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000 | thermo_1
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000 | thermo_3
 Tue Jun 29 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
(15 rows)

-- Cagg with inner join + realtime  aggregate + JOIN clause
CREATE MATERIALIZED VIEW cagg_realtime_join
WITH (timescaledb.continuous, timescaledb.materialized_only = FALSE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM conditions JOIN devices
ON conditions.device_id = devices.device_id
GROUP BY name, bucket
ORDER BY bucket;
NOTICE:  refreshing continuous aggregate "cagg_realtime_join"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
\d+ cagg_realtime_join
                              View "public.cagg_realtime_join"
 Column |           Type           | Collation | Nullable | Default | Storage  | Description 
--------+--------------------------+-----------+----------+---------+----------+-------------
 bucket | timestamp with time zone |           |          |         | plain    | 
 avg    | numeric                  |           |          |         | main     | 
 name   | text                     |           |          |         | extended | 
View definition:
( SELECT _materialized_hypertable_4.bucket,
    _materialized_hypertable_4.avg,
    _materialized_hypertable_4.name
   FROM _timescaledb_internal._materialized_hypertable_4
  WHERE _materialized_hypertable_4.bucket < COALESCE(_timescaledb_functions.to_timestamp(_timescaledb_functions.cagg_watermark(4)), '-infinity'::timestamp with time zone)
  ORDER BY _materialized_hypertable_4.bucket)
UNION ALL
( SELECT time_bucket('@ 1 day'::interval, conditions.day) AS bucket,
    avg(conditions.temperature) AS avg,
    devices.name
   FROM conditions
     JOIN devices ON conditions.device_id = devices.device_id
  WHERE conditions.day >= COALESCE(_timescaledb_functions.to_timestamp(_timescaledb_functions.cagg_watermark(4)), '-infinity'::timestamp with time zone)
  GROUP BY devices.name, (time_bucket('@ 1 day'::interval, conditions.day))
  ORDER BY (time_bucket('@ 1 day'::interval, conditions.day)))
  ORDER BY 1;

SELECT * FROM cagg_realtime_join ORDER BY bucket, name;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000 | thermo_1
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000 | thermo_2
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000 | thermo_3
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000 | thermo_4
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000 | thermo_4
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000 | thermo_4
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000 | thermo_1
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000 | thermo_1
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000 | thermo_3
 Tue Jun 29 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
(15 rows)

INSERT INTO conditions (day, city, temperature, device_id) VALUES
  ('2021-06-30', 'Moscow', 28, 3);
SELECT * FROM cagg_realtime_join ORDER BY bucket, name;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000 | thermo_1
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000 | thermo_2
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000 | thermo_3
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000 | thermo_4
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000 | thermo_4
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000 | thermo_4
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000 | thermo_1
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000 | thermo_1
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000 | thermo_3
 Tue Jun 29 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
(15 rows)

-- Cagg with inner join + realtime  aggregate + USING clause
CREATE MATERIALIZED VIEW cagg_realtime_using
WITH (timescaledb.continuous, timescaledb.materialized_only = FALSE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM conditions JOIN devices
USING (device_id)
GROUP BY name, bucket
ORDER BY bucket;
NOTICE:  refreshing continuous aggregate "cagg_realtime_using"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
\d+ cagg_realtime_using
                              View "public.cagg_realtime_using"
 Column |           Type           | Collation | Nullable | Default | Storage  | Description 
--------+--------------------------+-----------+----------+---------+----------+-------------
 bucket | timestamp with time zone |           |          |         | plain    | 
 avg    | numeric                  |           |          |         | main     | 
 name   | text                     |           |          |         | extended | 
View definition:
( SELECT _materialized_hypertable_5.bucket,
    _materialized_hypertable_5.avg,
    _materialized_hypertable_5.name
   FROM _timescaledb_internal._materialized_hypertable_5
  WHERE _materialized_hypertable_5.bucket < COALESCE(_timescaledb_functions.to_timestamp(_timescaledb_functions.cagg_watermark(5)), '-infinity'::timestamp with time zone)
  ORDER BY _materialized_hypertable_5.bucket)
UNION ALL
( SELECT time_bucket('@ 1 day'::interval, conditions.day) AS bucket,
    avg(conditions.temperature) AS avg,
    devices.name
   FROM conditions
     JOIN devices USING (device_id)
  WHERE conditions.day >= COALESCE(_timescaledb_functions.to_timestamp(_timescaledb_functions.cagg_watermark(5)), '-infinity'::timestamp with time zone)
  GROUP BY devices.name, (time_bucket('@ 1 day'::interval, conditions.day))
  ORDER BY (time_bucket('@ 1 day'::interval, conditions.day)))
  ORDER BY 1;

SELECT * FROM cagg_realtime_using ORDER BY bucket;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000 | thermo_1
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000 | thermo_2
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000 | thermo_3
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000 | thermo_4
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000 | thermo_4
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000 | thermo_4
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000 | thermo_1
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000 | thermo_1
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000 | thermo_3
 Tue Jun 29 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
(15 rows)

INSERT INTO conditions (day, city, temperature, device_id) VALUES
  ('2021-06-30', 'Moscow', 28, 3);
SELECT * FROM cagg_realtime_using ORDER BY bucket, name;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000 | thermo_1
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000 | thermo_2
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000 | thermo_3
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000 | thermo_4
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000 | thermo_4
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000 | thermo_4
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000 | thermo_1
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000 | thermo_1
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000 | thermo_3
 Tue Jun 29 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
(15 rows)

-- Reorder tables in FROM clause
-- Cagg with inner join + realtime aggregate
CREATE MATERIALIZED VIEW cagg_realtime_reorder
WITH (timescaledb.continuous, timescaledb.materialized_only = FALSE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM devices, conditions
WHERE conditions.device_id = devices.device_id
GROUP BY name, bucket
ORDER BY bucket;
NOTICE:  refreshing continuous aggregate "cagg_realtime_reorder"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
\d+ cagg_realtime_reorder
                             View "public.cagg_realtime_reorder"
 Column |           Type           | Collation | Nullable | Default | Storage  | Description 
--------+--------------------------+-----------+----------+---------+----------+-------------
 bucket | timestamp with time zone |           |          |         | plain    | 
 avg    | numeric                  |           |          |         | main     | 
 name   | text                     |           |          |         | extended | 
View definition:
( SELECT _materialized_hypertable_6.bucket,
    _materialized_hypertable_6.avg,
    _materialized_hypertable_6.name
   FROM _timescaledb_internal._materialized_hypertable_6
  WHERE _materialized_hypertable_6.bucket < COALESCE(_timescaledb_functions.to_timestamp(_timescaledb_functions.cagg_watermark(6)), '-infinity'::timestamp with time zone)
  ORDER BY _materialized_hypertable_6.bucket)
UNION ALL
( SELECT time_bucket('@ 1 day'::interval, conditions.day) AS bucket,
    avg(conditions.temperature) AS avg,
    devices.name
   FROM devices,
    conditions
  WHERE conditions.device_id = devices.device_id AND conditions.day >= COALESCE(_timescaledb_functions.to_timestamp(_timescaledb_functions.cagg_watermark(6)), '-infinity'::timestamp with time zone)
  GROUP BY devices.name, (time_bucket('@ 1 day'::interval, conditions.day))
  ORDER BY (time_bucket('@ 1 day'::interval, conditions.day)))
  ORDER BY 1;

SELECT * FROM cagg_realtime_reorder ORDER BY bucket, name;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000 | thermo_1
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000 | thermo_2
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000 | thermo_3
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000 | thermo_4
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000 | thermo_4
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000 | thermo_4
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000 | thermo_1
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000 | thermo_1
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000 | thermo_3
 Tue Jun 29 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
(15 rows)

INSERT INTO conditions (day, city, temperature, device_id) VALUES
  ('2021-07-01', 'Moscow', 28, 3);
SELECT * FROM cagg_realtime_reorder ORDER BY bucket, name;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000 | thermo_1
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000 | thermo_2
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000 | thermo_3
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000 | thermo_4
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000 | thermo_4
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000 | thermo_4
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000 | thermo_1
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000 | thermo_1
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000 | thermo_3
 Tue Jun 29 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
 Wed Jun 30 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
(16 rows)

-- Reorder tables in FROM clause
-- Cagg with inner join + realtime  aggregate + JOIN clause
CREATE MATERIALIZED VIEW cagg_realtime_reorder_join
WITH (timescaledb.continuous, timescaledb.materialized_only = FALSE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM devices JOIN conditions
ON conditions.device_id = devices.device_id
GROUP BY name, bucket
ORDER BY bucket;
NOTICE:  refreshing continuous aggregate "cagg_realtime_reorder_join"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
\d+ cagg_realtime_reorder_join
                          View "public.cagg_realtime_reorder_join"
 Column |           Type           | Collation | Nullable | Default | Storage  | Description 
--------+--------------------------+-----------+----------+---------+----------+-------------
 bucket | timestamp with time zone |           |          |         | plain    | 
 avg    | numeric                  |           |          |         | main     | 
 name   | text                     |           |          |         | extended | 
View definition:
( SELECT _materialized_hypertable_7.bucket,
    _materialized_hypertable_7.avg,
    _materialized_hypertable_7.name
   FROM _timescaledb_internal._materialized_hypertable_7
  WHERE _materialized_hypertable_7.bucket < COALESCE(_timescaledb_functions.to_timestamp(_timescaledb_functions.cagg_watermark(7)), '-infinity'::timestamp with time zone)
  ORDER BY _materialized_hypertable_7.bucket)
UNION ALL
( SELECT time_bucket('@ 1 day'::interval, conditions.day) AS bucket,
    avg(conditions.temperature) AS avg,
    devices.name
   FROM devices
     JOIN conditions ON conditions.device_id = devices.device_id
  WHERE conditions.day >= COALESCE(_timescaledb_functions.to_timestamp(_timescaledb_functions.cagg_watermark(7)), '-infinity'::timestamp with time zone)
  GROUP BY devices.name, (time_bucket('@ 1 day'::interval, conditions.day))
  ORDER BY (time_bucket('@ 1 day'::interval, conditions.day)))
  ORDER BY 1;

SELECT * FROM cagg_realtime_reorder_join ORDER BY bucket, name;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000 | thermo_1
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000 | thermo_2
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000 | thermo_3
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000 | thermo_4
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000 | thermo_4
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000 | thermo_4
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000 | thermo_1
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000 | thermo_1
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000 | thermo_3
 Tue Jun 29 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
 Wed Jun 30 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
(16 rows)

INSERT INTO conditions (day, city, temperature, device_id) VALUES
  ('2021-07-01', 'Moscow', 28, 3);
SELECT *
FROM cagg_realtime_reorder_join;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000 | thermo_1
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000 | thermo_2
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000 | thermo_3
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000 | thermo_4
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000 | thermo_4
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000 | thermo_4
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000 | thermo_1
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000 | thermo_1
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000 | thermo_3
 Tue Jun 29 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
 Wed Jun 30 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
(16 rows)

-- Reorder tables in FROM clause
-- Cagg with inner join + realtime  aggregate + USING clause
CREATE MATERIALIZED VIEW cagg_realtime_reorder_using
WITH (timescaledb.continuous, timescaledb.materialized_only = FALSE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM devices JOIN conditions
USING (device_id)
GROUP BY name, bucket
ORDER BY bucket;
NOTICE:  refreshing continuous aggregate "cagg_realtime_reorder_using"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
\d+ cagg_realtime_reorder_using
                          View "public.cagg_realtime_reorder_using"
 Column |           Type           | Collation | Nullable | Default | Storage  | Description 
--------+--------------------------+-----------+----------+---------+----------+-------------
 bucket | timestamp with time zone |           |          |         | plain    | 
 avg    | numeric                  |           |          |         | main     | 
 name   | text                     |           |          |         | extended | 
View definition:
( SELECT _materialized_hypertable_8.bucket,
    _materialized_hypertable_8.avg,
    _materialized_hypertable_8.name
   FROM _timescaledb_internal._materialized_hypertable_8
  WHERE _materialized_hypertable_8.bucket < COALESCE(_timescaledb_functions.to_timestamp(_timescaledb_functions.cagg_watermark(8)), '-infinity'::timestamp with time zone)
  ORDER BY _materialized_hypertable_8.bucket)
UNION ALL
( SELECT time_bucket('@ 1 day'::interval, conditions.day) AS bucket,
    avg(conditions.temperature) AS avg,
    devices.name
   FROM devices
     JOIN conditions USING (device_id)
  WHERE conditions.day >= COALESCE(_timescaledb_functions.to_timestamp(_timescaledb_functions.cagg_watermark(8)), '-infinity'::timestamp with time zone)
  GROUP BY devices.name, (time_bucket('@ 1 day'::interval, conditions.day))
  ORDER BY (time_bucket('@ 1 day'::interval, conditions.day)))
  ORDER BY 1;

SELECT * FROM cagg_realtime_reorder_using ORDER BY bucket, name;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000 | thermo_1
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000 | thermo_2
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000 | thermo_3
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000 | thermo_4
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000 | thermo_4
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000 | thermo_4
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000 | thermo_1
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000 | thermo_1
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000 | thermo_3
 Tue Jun 29 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
 Wed Jun 30 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
(16 rows)

INSERT INTO conditions (day, city, temperature, device_id) VALUES
  ('2021-07-01', 'Moscow', 28, 3);
SELECT * FROM cagg_realtime_reorder_using ORDER BY bucket, name;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000 | thermo_1
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000 | thermo_2
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000 | thermo_3
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000 | thermo_4
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000 | thermo_4
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000 | thermo_4
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000 | thermo_1
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000 | thermo_1
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000 | thermo_3
 Tue Jun 29 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
 Wed Jun 30 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
(16 rows)

-- Cagg with inner joins - realtime aggregate
CREATE MATERIALIZED VIEW cagg
WITH (timescaledb.continuous, timescaledb.materialized_only = TRUE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name,
   devices.device_id AS thermo_id
FROM conditions, devices
WHERE conditions.device_id = devices.device_id
GROUP BY bucket, name, thermo_id
ORDER BY bucket;
NOTICE:  refreshing continuous aggregate "cagg"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
SELECT * FROM cagg ORDER BY bucket, name, thermo_id;
            bucket            |         avg         |   name   | thermo_id 
------------------------------+---------------------+----------+-----------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000 | thermo_1 |         1
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000 | thermo_2 |         2
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000 | thermo_3 |         3
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000 | thermo_4 |         4
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000 | thermo_4 |         4
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000 | thermo_4 |         4
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1 |         1
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000 | thermo_1 |         1
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000 | thermo_1 |         1
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2 |         2
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2 |         2
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3 |         3
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3 |         3
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000 | thermo_3 |         3
 Tue Jun 29 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3 |         3
 Wed Jun 30 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3 |         3
(16 rows)

-- Cagg with inner joins - realtime aggregate + JOIN clause
CREATE MATERIALIZED VIEW cagg_join
WITH (timescaledb.continuous, timescaledb.materialized_only = FALSE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM conditions JOIN devices ON conditions.device_id = devices.device_id
GROUP BY bucket,name
ORDER BY bucket;
NOTICE:  refreshing continuous aggregate "cagg_join"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
SELECT * FROM cagg_join ORDER BY bucket, name;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000 | thermo_1
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000 | thermo_2
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000 | thermo_3
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000 | thermo_4
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000 | thermo_4
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000 | thermo_4
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000 | thermo_1
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000 | thermo_1
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000 | thermo_3
 Tue Jun 29 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
 Wed Jun 30 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
(16 rows)

-- Cagg with inner joins - realtime aggregate + USING clause
CREATE MATERIALIZED VIEW cagg_using
WITH (timescaledb.continuous, timescaledb.materialized_only = FALSE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM conditions JOIN devices USING (device_id)
GROUP BY name, bucket
ORDER BY bucket;
NOTICE:  refreshing continuous aggregate "cagg_using"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
SELECT * FROM cagg_using;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000 | thermo_1
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000 | thermo_2
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000 | thermo_3
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000 | thermo_4
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000 | thermo_4
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000 | thermo_4
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000 | thermo_1
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000 | thermo_1
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000 | thermo_3
 Tue Jun 29 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
 Wed Jun 30 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
(16 rows)

-- Reorder tables in FROM clause
-- Cagg with inner joins - realtime aggregate
CREATE MATERIALIZED VIEW cagg_reorder
WITH (timescaledb.continuous, timescaledb.materialized_only = TRUE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM devices, conditions
WHERE conditions.device_id = devices.device_id
GROUP BY bucket, name
ORDER BY bucket;
NOTICE:  refreshing continuous aggregate "cagg_reorder"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
SELECT * FROM cagg_reorder ORDER BY bucket, name;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000 | thermo_1
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000 | thermo_2
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000 | thermo_3
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000 | thermo_4
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000 | thermo_4
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000 | thermo_4
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000 | thermo_1
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000 | thermo_1
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000 | thermo_3
 Tue Jun 29 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
 Wed Jun 30 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
(16 rows)

-- Cagg with inner joins - realtime aggregate + JOIN clause
CREATE MATERIALIZED VIEW cagg_reorder_join
WITH (timescaledb.continuous, timescaledb.materialized_only = FALSE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM devices JOIN conditions ON conditions.device_id = devices.device_id
GROUP BY name, bucket
ORDER BY bucket;
NOTICE:  refreshing continuous aggregate "cagg_reorder_join"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
SELECT * FROM cagg_reorder_join;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000 | thermo_1
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000 | thermo_2
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000 | thermo_3
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000 | thermo_4
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000 | thermo_4
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000 | thermo_4
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000 | thermo_1
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000 | thermo_1
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000 | thermo_3
 Tue Jun 29 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
 Wed Jun 30 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
(16 rows)

-- Cagg with inner joins - realtime aggregate + USING clause
CREATE MATERIALIZED VIEW cagg_reorder_using
WITH (timescaledb.continuous, timescaledb.materialized_only = FALSE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM devices JOIN conditions USING (device_id)
GROUP BY name, bucket
ORDER BY bucket;
NOTICE:  refreshing continuous aggregate "cagg_reorder_using"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
SELECT * FROM cagg_reorder_using;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000 | thermo_1
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000 | thermo_2
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000 | thermo_3
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000 | thermo_4
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000 | thermo_4
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000 | thermo_4
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000 | thermo_1
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000 | thermo_1
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000 | thermo_3
 Tue Jun 29 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
 Wed Jun 30 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
(16 rows)

-- Cagg join with another table using FROM ONLY
CREATE MATERIALIZED VIEW cagg_from_only
WITH (timescaledb.continuous, timescaledb.materialized_only = FALSE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM ONLY devices JOIN conditions USING (device_id)
GROUP BY name, bucket
ORDER BY bucket;
NOTICE:  refreshing continuous aggregate "cagg_from_only"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
SELECT * FROM cagg_from_only;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000 | thermo_1
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000 | thermo_2
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000 | thermo_3
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000 | thermo_4
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000 | thermo_4
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000 | thermo_4
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000 | thermo_1
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000 | thermo_1
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000 | thermo_3
 Tue Jun 29 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
 Wed Jun 30 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3
(16 rows)

-- Create CAgg with join and additional WHERE conditions
CREATE MATERIALIZED VIEW cagg_more_conds
WITH (timescaledb.continuous, timescaledb.materialized_only = FALSE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM conditions JOIN devices ON conditions.device_id = devices.device_id
WHERE conditions.city = devices.location AND
      conditions.temperature > 28
GROUP BY name, bucket;
NOTICE:  refreshing continuous aggregate "cagg_more_conds"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
SELECT * FROM cagg_more_conds ORDER BY bucket;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
(2 rows)

-- Cagg with more conditions and USING clause
CREATE MATERIALIZED VIEW cagg_more_conds_using
WITH (timescaledb.continuous, timescaledb.materialized_only = FALSE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM conditions JOIN devices USING (device_id)
WHERE conditions.city = devices.location AND
      conditions.temperature > 28
GROUP BY name, bucket;
NOTICE:  refreshing continuous aggregate "cagg_more_conds_using"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
SELECT * FROM cagg_more_conds_using ORDER BY bucket;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
(2 rows)

-- Hierarchical CAgg with join
CREATE MATERIALIZED VIEW cagg_on_cagg
WITH (timescaledb.continuous, timescaledb.materialized_only=true) AS
SELECT time_bucket(INTERVAL '1 day', bucket) AS bucket,
       SUM(avg) AS temperature
FROM cagg, devices
WHERE devices.device_id = cagg.thermo_id
GROUP BY 1;
NOTICE:  refreshing continuous aggregate "cagg_on_cagg"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
SELECT * FROM cagg_on_cagg;
            bucket            |     temperature     
------------------------------+---------------------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000
 Tue Jun 29 17:00:00 2021 PDT | 28.0000000000000000
 Wed Jun 30 17:00:00 2021 PDT | 28.0000000000000000
(16 rows)

DROP MATERIALIZED VIEW cagg_on_cagg CASCADE;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to table _timescaledb_internal._hyper_18_61_chunk
drop cascades to table _timescaledb_internal._hyper_18_62_chunk
-- Nested CAgg over a CAgg with JOIN clause
CREATE MATERIALIZED VIEW cagg_on_cagg_join
WITH (timescaledb.continuous, timescaledb.materialized_only=true) AS
SELECT time_bucket(INTERVAL '1 day', bucket) AS bucket,
       SUM(avg) AS temperature
FROM cagg JOIN devices
ON devices.device_id = cagg.thermo_id
GROUP BY 1;
NOTICE:  refreshing continuous aggregate "cagg_on_cagg_join"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
SELECT * FROM cagg_on_cagg_join;
            bucket            |     temperature     
------------------------------+---------------------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000
 Tue Jun 29 17:00:00 2021 PDT | 28.0000000000000000
 Wed Jun 30 17:00:00 2021 PDT | 28.0000000000000000
(16 rows)

DROP MATERIALIZED VIEW cagg_on_cagg_join CASCADE;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to table _timescaledb_internal._hyper_19_63_chunk
drop cascades to table _timescaledb_internal._hyper_19_64_chunk
-- Create CAgg with join and ORDER BY
CREATE MATERIALIZED VIEW cagg_ordered
WITH (timescaledb.continuous, timescaledb.materialized_only = FALSE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM conditions JOIN devices ON conditions.device_id = devices.device_id
WHERE conditions.city = devices.location AND
      conditions.temperature > 28
GROUP BY name, bucket
ORDER BY name;
NOTICE:  refreshing continuous aggregate "cagg_ordered"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
SELECT * FROM cagg_ordered ORDER BY bucket;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
(2 rows)

CREATE MATERIALIZED VIEW cagg_ordered_2
WITH (timescaledb.continuous, timescaledb.materialized_only = FALSE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM conditions JOIN devices ON conditions.device_id = devices.device_id
WHERE conditions.city = devices.location AND
      conditions.temperature > 28
GROUP BY name, bucket
ORDER BY name DESC;
NOTICE:  refreshing continuous aggregate "cagg_ordered_2"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
SELECT * FROM cagg_ordered_2 ORDER BY bucket;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
(2 rows)

CREATE MATERIALIZED VIEW cagg_ordered_3
WITH (timescaledb.continuous, timescaledb.materialized_only = FALSE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM conditions JOIN devices ON conditions.device_id = devices.device_id
WHERE conditions.city = devices.location AND
      conditions.temperature > 28
GROUP BY name, bucket
ORDER BY name, bucket;
NOTICE:  refreshing continuous aggregate "cagg_ordered_3"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
SELECT * FROM cagg_ordered_3 ORDER BY bucket;
            bucket            |         avg         |   name   
------------------------------+---------------------+----------
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3
(2 rows)

CREATE MATERIALIZED VIEW cagg_cagg
WITH (timescaledb.continuous, timescaledb.materialized_only = TRUE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   devices.device_id device_id,
   name
FROM conditions, devices
WHERE conditions.device_id = devices.device_id
GROUP BY name, bucket, devices.device_id;
NOTICE:  refreshing continuous aggregate "cagg_cagg"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
--Join between cagg and normal table
CREATE MATERIALIZED VIEW cagg_nested
WITH (timescaledb.continuous, timescaledb.materialized_only = TRUE) AS
SELECT time_bucket(INTERVAL '1 day', cagg.bucket) AS bucket,
   devices.name
FROM cagg_cagg cagg, devices
WHERE cagg.device_id = devices.device_id
GROUP BY 1,2;
NOTICE:  refreshing continuous aggregate "cagg_nested"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
DROP MATERIALIZED VIEW cagg_nested CASCADE;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to table _timescaledb_internal._hyper_24_73_chunk
drop cascades to table _timescaledb_internal._hyper_24_74_chunk
-- CAgg with multiple join conditions without JOIN clause
CREATE MATERIALIZED VIEW cagg_more_joins_conds
WITH (timescaledb.continuous, timescaledb.materialized_only = FALSE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   MAX(temperature),
   MIN(temperature),
   name
FROM conditions JOIN devices ON conditions.device_id = devices.device_id
AND conditions.city = devices.location AND
      conditions.temperature > 28
GROUP BY name, bucket;
NOTICE:  refreshing continuous aggregate "cagg_more_joins_conds"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
-- With LATERAL multiple tables in new format
CREATE TABLE mat_t1(a integer, b integer, c TEXT);
CREATE MATERIALIZED VIEW mat_m1 WITH (timescaledb.continuous, timescaledb.materialized_only = FALSE)
AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket, temperature, count(*) from conditions,
LATERAL (SELECT * FROM mat_t1 WHERE mat_t1.a = conditions.temperature) q
GROUP BY bucket, temperature;
NOTICE:  refreshing continuous aggregate "mat_m1"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
-- Joining a hypertable and view
CREATE MATERIALIZED VIEW cagg_view
WITH (timescaledb.continuous, timescaledb.materialized_only = TRUE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   devices_view.device_id,
   name
FROM conditions, devices_view
WHERE conditions.device_id = devices_view.device_id
GROUP BY name, bucket, devices_view.device_id;
NOTICE:  refreshing continuous aggregate "cagg_view"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
CREATE TABLE cities(name text, currency text);
INSERT INTO cities VALUES ('Berlin', 'EUR'), ('London', 'PND');
--Error out when FROM clause has sub selects
\set ON_ERROR_STOP 0
CREATE MATERIALIZED VIEW conditions_summary_subselect
WITH (timescaledb.continuous, timescaledb.materialized_only = TRUE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM conditions JOIN
(SELECT *
FROM devices
WHERE location in (
   SELECT name
   FROM cities
   WHERE currency = 'EUR')) dev ON conditions.device_id = dev.device_id
GROUP BY name, bucket;
ERROR:  invalid continuous aggregate view
DETAIL:  Sub-queries are not supported in FROM clause.
--Error out when WHERE clause has sub selects
CREATE MATERIALIZED VIEW conditions_summary_subselect
WITH (timescaledb.continuous, timescaledb.materialized_only = TRUE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM conditions, devices
WHERE conditions.city IN (
   SELECT location
   FROM devices
   WHERE location in (
      SELECT name
      FROM cities
      WHERE currency = 'EUR'))
AND conditions.device_id = devices.device_id
GROUP BY name, bucket;
ERROR:  invalid continuous aggregate query
DETAIL:  CTEs, subqueries and set-returning functions are not supported by continuous aggregates.
CREATE MATERIALIZED VIEW conditions_summary_subselect
WITH (timescaledb.continuous, timescaledb.materialized_only = TRUE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM conditions JOIN devices USING(device_id)
WHERE conditions.city IN (
   SELECT location
   FROM devices
   WHERE location in (
      SELECT name
      FROM cities
      WHERE currency = 'EUR'))
GROUP BY name, bucket;
ERROR:  invalid continuous aggregate query
DETAIL:  CTEs, subqueries and set-returning functions are not supported by continuous aggregates.
CREATE MATERIALIZED VIEW conditions_summary_subselect
WITH (timescaledb.continuous, timescaledb.materialized_only = TRUE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM conditions JOIN devices ON conditions.device_id = devices.device_id
WHERE conditions.city IN (
   SELECT location
   FROM devices
   WHERE location in (
      SELECT name
      FROM cities
      WHERE currency = 'EUR'))
GROUP BY name, bucket;
ERROR:  invalid continuous aggregate query
DETAIL:  CTEs, subqueries and set-returning functions are not supported by continuous aggregates.
DROP TABLE cities CASCADE;
--Error out when join is between two hypertables
CREATE MATERIALIZED VIEW cagg_ht
WITH (timescaledb.continuous, timescaledb.materialized_only = TRUE) AS
SELECT time_bucket(INTERVAL '1 day', conditions.day) AS bucket,
   AVG(conditions.temperature)
FROM conditions, conditions_dup
WHERE conditions.device_id = conditions_dup.device_id
GROUP BY bucket;
ERROR:  invalid continuous aggregate view
DETAIL:  Only one hypertable is allowed in continuous aggregate view.
--Error out when join is between two normal tables
CREATE MATERIALIZED VIEW cagg_nt
WITH (timescaledb.continuous, timescaledb.materialized_only = TRUE) AS
SELECT AVG(devices.device_id),
   devices.name,
   devices.location
FROM devices, devices_dup
WHERE devices.device_id = devices_dup.device_id
GROUP BY devices.name, devices.location;
ERROR:  invalid continuous aggregate view
DETAIL:  At least one hypertable should be used in the view definition.
\set ON_ERROR_STOP 1
-- JOIN with non-equality condition
CREATE MATERIALIZED VIEW cagg_unequal1
WITH (timescaledb.continuous, timescaledb.materialized_only = TRUE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM conditions, devices
WHERE conditions.device_id <> devices.device_id
GROUP BY name, bucket;
NOTICE:  refreshing continuous aggregate "cagg_unequal1"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
-- JOIN with non-equality condition
CREATE MATERIALIZED VIEW cagg_unequal2
WITH (timescaledb.continuous, timescaledb.materialized_only = TRUE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM conditions, devices
WHERE conditions.device_id = devices.device_id AND
      conditions.city like '%cow*'
GROUP BY name, bucket;
NOTICE:  refreshing continuous aggregate "cagg_unequal2"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
-- JOIN with non-equality condition
CREATE MATERIALIZED VIEW cagg_unequal3
WITH (timescaledb.continuous, timescaledb.materialized_only = TRUE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM conditions
JOIN devices ON conditions.device_id = devices.device_id OR conditions.city LIKE '%cow*'
GROUP BY name, bucket;
NOTICE:  refreshing continuous aggregate "cagg_unequal3"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
-- Error out when join type is not INNER or LEFT
\set ON_ERROR_STOP 0
CREATE MATERIALIZED VIEW cagg_outer
WITH (timescaledb.continuous, timescaledb.materialized_only = TRUE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM conditions FULL JOIN devices
ON conditions.device_id = devices.device_id
GROUP BY name, bucket;
ERROR:  only INNER or LEFT joins are supported in continuous aggregates
CREATE MATERIALIZED VIEW cagg_right
WITH (timescaledb.continuous, timescaledb.materialized_only = TRUE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM conditions RIGHT JOIN devices
ON conditions.device_id = devices.device_id
GROUP BY name, bucket;
ERROR:  only INNER or LEFT joins are supported in continuous aggregates
\set ON_ERROR_STOP 1
-- LEFT JOIN is allowed
CREATE MATERIALIZED VIEW cagg_left_join
WITH (timescaledb.continuous, timescaledb.materialized_only = TRUE) AS
SELECT time_bucket(INTERVAL '1 day', day) AS bucket,
   AVG(temperature),
   name
FROM conditions LEFT JOIN devices
ON conditions.device_id = devices.device_id
GROUP BY name, bucket;
NOTICE:  refreshing continuous aggregate "cagg_left_join"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
-- Error out for join between cagg and hypertable
\set ON_ERROR_STOP 0
CREATE MATERIALIZED VIEW cagg_nested_ht
WITH (timescaledb.continuous, timescaledb.materialized_only = TRUE) AS
SELECT time_bucket(INTERVAL '1 day', cagg.bucket) AS bucket,
   cagg.name,
   conditions.temperature
FROM cagg_cagg cagg, conditions
WHERE cagg.device_id = conditions.device_id
GROUP BY 1,2,3;
ERROR:  invalid continuous aggregate view
DETAIL:  Only one hypertable is allowed in continuous aggregate view.
\set ON_ERROR_STOP 1
-- Multiple JOINS are supported
CREATE MATERIALIZED VIEW conditions_by_day WITH (timescaledb.continuous) AS
SELECT time_bucket(INTERVAL '1 day', conditions.day) AS bucket,
   AVG(conditions.temperature),
   devices.name AS device,
   location.name AS location
FROM conditions
JOIN devices ON conditions.device_id = devices.device_id
JOIN location ON location.name = devices.location
GROUP BY bucket, devices.name, location.name;
NOTICE:  refreshing continuous aggregate "conditions_by_day"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
SELECT * FROM conditions_by_day ORDER BY bucket, device, location;
            bucket            |         avg         |  device  | location  
------------------------------+---------------------+----------+-----------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000 | thermo_1 | Moscow
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000 | thermo_2 | Berlin
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000 | thermo_3 | London
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000 | thermo_4 | Stockholm
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000 | thermo_4 | Stockholm
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000 | thermo_4 | Stockholm
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1 | Moscow
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000 | thermo_1 | Moscow
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000 | thermo_1 | Moscow
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2 | Berlin
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2 | Berlin
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3 | London
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3 | London
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000 | thermo_3 | London
 Tue Jun 29 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3 | London
 Wed Jun 30 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3 | London
(16 rows)

ALTER MATERIALIZED VIEW conditions_by_day SET (timescaledb.materialized_only = FALSE);
-- Insert one more row on conditions and check the result (should have one more row)
INSERT INTO conditions (day, city, temperature, device_id) VALUES
  ('2024-07-01', 'Moscow', 28, 3);
SELECT * FROM conditions_by_day ORDER BY bucket, device, location;
            bucket            |         avg         |  device  | location  
------------------------------+---------------------+----------+-----------
 Sun Jun 13 17:00:00 2021 PDT | 26.0000000000000000 | thermo_1 | Moscow
 Mon Jun 14 17:00:00 2021 PDT | 22.0000000000000000 | thermo_2 | Berlin
 Tue Jun 15 17:00:00 2021 PDT | 24.0000000000000000 | thermo_3 | London
 Wed Jun 16 17:00:00 2021 PDT | 24.0000000000000000 | thermo_4 | Stockholm
 Thu Jun 17 17:00:00 2021 PDT | 27.0000000000000000 | thermo_4 | Stockholm
 Fri Jun 18 17:00:00 2021 PDT | 28.0000000000000000 | thermo_4 | Stockholm
 Sat Jun 19 17:00:00 2021 PDT | 30.0000000000000000 | thermo_1 | Moscow
 Sun Jun 20 17:00:00 2021 PDT | 31.0000000000000000 | thermo_1 | Moscow
 Mon Jun 21 17:00:00 2021 PDT | 34.0000000000000000 | thermo_1 | Moscow
 Tue Jun 22 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2 | Berlin
 Wed Jun 23 17:00:00 2021 PDT | 34.0000000000000000 | thermo_2 | Berlin
 Thu Jun 24 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3 | London
 Fri Jun 25 17:00:00 2021 PDT | 32.0000000000000000 | thermo_3 | London
 Sat Jun 26 17:00:00 2021 PDT | 31.0000000000000000 | thermo_3 | London
 Tue Jun 29 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3 | London
 Wed Jun 30 17:00:00 2021 PDT | 28.0000000000000000 | thermo_3 | London
 Sun Jun 30 17:00:00 2024 PDT | 28.0000000000000000 | thermo_3 | London
(17 rows)

-- JOIN with a foreign table
\c :TEST_DBNAME :ROLE_SUPERUSER
SELECT current_setting('port') AS "PGPORT", current_database() AS "PGDATABASE" \gset
CREATE EXTENSION postgres_fdw;
CREATE SERVER loopback
   FOREIGN DATA WRAPPER postgres_fdw
   OPTIONS (host 'localhost', dbname :'PGDATABASE', port :'PGPORT');
CREATE USER MAPPING FOR :ROLE_DEFAULT_PERM_USER
   SERVER loopback
   OPTIONS (user :'ROLE_DEFAULT_PERM_USER', password 'nopassword');
ALTER USER MAPPING FOR :ROLE_DEFAULT_PERM_USER
   SERVER loopback
   OPTIONS (ADD password_required 'false');
GRANT USAGE ON FOREIGN SERVER loopback TO :ROLE_DEFAULT_PERM_USER;
\c :TEST_DBNAME :ROLE_DEFAULT_PERM_USER;
SET timezone TO PST8PDT;
CREATE FOREIGN TABLE devices_fdw (
   device_id int not null,
   name text,
   location text
) SERVER loopback OPTIONS (table_name 'devices');
CREATE MATERIALIZED VIEW conditions_fdw WITH (timescaledb.continuous) AS
SELECT time_bucket(INTERVAL '1 day', conditions.day) AS bucket,
   AVG(conditions.temperature),
   devices.name AS device
FROM conditions
JOIN devices_fdw AS devices ON conditions.device_id = devices.device_id
GROUP BY bucket, devices.name;
NOTICE:  refreshing continuous aggregate "conditions_fdw"
HINT:  Use WITH NO DATA if you do not want to refresh the continuous aggregate on creation.
\set VERBOSITY terse
SET client_min_messages TO WARNING;
DROP TABLE conditions CASCADE;
DROP TABLE devices CASCADE;
DROP TABLE conditions_dup CASCADE;
DROP TABLE devices_dup CASCADE;
RESET client_min_messages;
\set VERBOSITY default
-- SDC #1859
CREATE TABLE conditions(
  time TIMESTAMPTZ NOT NULL,
  value FLOAT8 NOT NULL,
  device_id int NOT NULL
);
SELECT table_name FROM create_hypertable('conditions', 'time', chunk_time_interval => INTERVAL '1 day');
 table_name 
------------
 conditions
(1 row)

INSERT INTO conditions (time, value, device_id)
SELECT t, 1, 1 FROM generate_series('2024-01-01 00:00:00-00'::timestamptz, '2024-12-31 00:00:00-00'::timestamptz, '1 hour'::interval) AS t;
CREATE TABLE devices (device_id int not null, name text, location text);
INSERT INTO devices values (1, 'thermo_1', 'Moscow'), (2, 'thermo_2', 'Berlin'),(3, 'thermo_3', 'London'),(4, 'thermo_4', 'Stockholm');
CREATE MATERIALIZED VIEW cagg_realtime
WITH (timescaledb.continuous, timescaledb.materialized_only = FALSE) AS
SELECT time_bucket(INTERVAL '1 day', time) AS bucket,
   MAX(value),
   MIN(value),
   AVG(value),
   devices.name,
   devices.location
FROM conditions
JOIN devices ON conditions.device_id = devices.device_id
GROUP BY name, location, bucket
WITH NO DATA;
\c :TEST_DBNAME :ROLE_CLUSTER_SUPERUSER
VACUUM ANALYZE;
\c :TEST_DBNAME :ROLE_DEFAULT_PERM_USER
SELECT a.* FROM cagg_realtime a WHERE a.location = 'Moscow' ORDER BY bucket LIMIT 2;
            bucket            | max | min | avg |   name   | location 
------------------------------+-----+-----+-----+----------+----------
 Sun Dec 31 16:00:00 2023 PST |   1 |   1 |   1 | thermo_1 | Moscow
 Mon Jan 01 16:00:00 2024 PST |   1 |   1 |   1 | thermo_1 | Moscow
(2 rows)

\set VERBOSITY terse
SET client_min_messages TO WARNING;
DROP TABLE conditions CASCADE;
DROP TABLE devices CASCADE;
RESET client_min_messages;
