-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
\ir include/setup_hyperstore.sql
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
\set hypertable readings
\ir hyperstore_helpers.sql
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- Function to run an explain analyze with and do replacements on the
-- emitted plan. This is intended to be used when the structure of the
-- plan is important, but not the specific chunks scanned nor the
-- number of heap fetches, rows, loops, etc.
create function explain_anonymize(text) returns setof text
language plpgsql as
$$
declare
    ln text;
begin
    for ln in
        execute format('explain (analyze, costs off, summary off, timing off, decompress_cache_stats) %s', $1)
    loop
        ln := regexp_replace(ln, 'Arrays read from cache: \d+', 'Arrays read from cache: N');
        ln := regexp_replace(ln, 'Heap Fetches: \d+', 'Heap Fetches: N');
        ln := regexp_replace(ln, 'Workers Launched: \d+', 'Workers Launched: N');
        ln := regexp_replace(ln, 'actual rows=\d+ loops=\d+', 'actual rows=N loops=N');
	ln := regexp_replace(ln, '_hyper_\d+_\d+_chunk', '_hyper_I_N_chunk');
        return next ln;
    end loop;
end;
$$;
create table :hypertable(
       metric_id serial,
       created_at timestamptz not null unique,
       location_id int,		--segmentby attribute with index
       owner_id int,		--segmentby attribute without index
       device_id int,		--non-segmentby attribute
       temp float,
       humidity float
);
create index hypertable_location_id_idx on :hypertable (location_id);
create index hypertable_device_id_idx on :hypertable (device_id);
select create_hypertable(:'hypertable', by_range('created_at'));
 create_hypertable 
-------------------
 (1,t)
(1 row)

-- Disable incremental sort to make tests stable
set enable_incremental_sort = false;
select setseed(1);
 setseed 
---------
 
(1 row)

-- Insert rows into the tables.
--
-- The timestamps for the original rows will have timestamps every 10
-- seconds. Any other timestamps are inserted as part of the test.
insert into :hypertable (created_at, location_id, device_id, owner_id, temp, humidity)
select t, ceil(random()*10), ceil(random()*30), ceil(random() * 5), random()*40, random()*100
from generate_series('2022-06-01'::timestamptz, '2022-07-01', '10s') t;
alter table :hypertable set (
	  timescaledb.compress,
	  timescaledb.compress_orderby = 'created_at',
	  timescaledb.compress_segmentby = 'location_id, owner_id'
);
-- Get some test chunks as global variables (first and last chunk here)
select format('%I.%I', chunk_schema, chunk_name)::regclass as chunk1
  from timescaledb_information.chunks
 where format('%I.%I', hypertable_schema, hypertable_name)::regclass = :'hypertable'::regclass
 order by chunk1 asc
 limit 1 \gset
select format('%I.%I', chunk_schema, chunk_name)::regclass as chunk2
  from timescaledb_information.chunks
 where format('%I.%I', hypertable_schema, hypertable_name)::regclass = :'hypertable'::regclass
 order by chunk2 asc
 limit 1 offset 1 \gset
-- To generate plans consistently.
set max_parallel_workers_per_gather to 0;
-- Create a function that uses a cursor to scan the the Hyperstore
-- table. This should work equivalent to a query on the same table.
create function location_humidity_for(
       in p_owner integer,
       out p_location integer,
       out p_humidity float)
returns setof record as
$$
declare
    location_record record;
    location_cursor cursor for
      select location_id,
      	     avg(humidity) as avg_humidity
      from readings
      where owner_id = p_owner
      group by location_id;
begin
    open location_cursor;

    loop
        fetch next from location_cursor into location_record;
        exit when not found;

        p_location = location_record.location_id;
        p_humidity = location_record.avg_humidity;
        return next;
    end loop;

    close location_cursor;
end;
$$
language plpgsql;
select compress_chunk(show_chunks(:'hypertable'), compress_using => 'hyperstore');
             compress_chunk             
----------------------------------------
 _timescaledb_internal._hyper_1_1_chunk
 _timescaledb_internal._hyper_1_2_chunk
 _timescaledb_internal._hyper_1_3_chunk
 _timescaledb_internal._hyper_1_4_chunk
 _timescaledb_internal._hyper_1_5_chunk
 _timescaledb_internal._hyper_1_6_chunk
(6 rows)

-- Compare executing the function with a cursor with a query fetching
-- the same data directly from the hypertable.
select p_location, lhs.p_humidity, rhs.p_humidity
  from (select * from location_humidity_for(1)) lhs
  join (select location_id as p_location,
               avg(humidity) as p_humidity
          from :hypertable
         where owner_id = 1
        group by location_id) rhs
  using (p_location)
 where lhs.p_humidity != rhs.p_humidity
order by p_location;
 p_location | p_humidity | p_humidity 
------------+------------+------------
(0 rows)

-- Create a function that will use a cursor to iterate through a table
-- and update the humidity for a location using a cursor.
create function update_location_humidity(
       in p_location integer,
       in p_humidity float)
returns setof record as
$$
declare
    location_record record;
    location_cursor cursor for
      select location_id, humidity from readings where location_id = p_location;
begin
    open location_cursor;

    loop
        move next in location_cursor;
        exit when not found;
	update readings set humidity = p_humidity where current of location_cursor;
    end loop;

    close location_cursor;
end;
$$
language plpgsql;
set timescaledb.max_tuples_decompressed_per_dml_transaction to 0;
create table saved as select * from :hypertable;
-- These two should generate the same result
update saved set humidity = 100.0 where location_id = 10;
select update_location_humidity(10, 100.0);
 update_location_humidity 
--------------------------
(0 rows)

-- This should show no rows, but if there are differences we limit
-- this to 10 rows to not waste electrons.
--
-- Note that update of compressed tables through a cursor does not
-- work for all compressed tables right now because of the way the
-- local ExecModifyTable is implemented, so this will show rows.
select metric_id, lhs.humidity, rhs.humidity
  from saved lhs full join :hypertable rhs using (metric_id)
 where lhs.humidity != rhs.humidity
order by metric_id limit 10;
 metric_id | humidity |     humidity     
-----------+----------+------------------
        15 |      100 | 96.6754916333354
        16 |      100 | 62.7184052021097
        23 |      100 | 1.22822010608126
        30 |      100 | 73.4354630814633
        31 |      100 | 84.7107104874427
        79 |      100 | 72.8738038027601
        82 |      100 | 60.9365492825638
       101 |      100 | 42.5580770226228
       111 |      100 | 93.1650958521521
       113 |      100 | 1.58061462803281
(10 rows)

drop function location_humidity_for;
drop function update_location_humidity;
