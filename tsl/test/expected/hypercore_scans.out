-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- Avoid chunkwise aggregation to make the test stable
set timescaledb.enable_chunkwise_aggregation to off;
-- Hypercore TAM uses alternative sparse index predicate pushdown code which
-- lacks the support for the bloom1 sparse index at the moment.
set timescaledb.enable_sparse_index_bloom to off;
create table readings(time timestamptz,
       location text,
       device int,
       temp float,
       humidity float,
       unique (device, location, time)
);
create index on readings(location);
create index on readings(device);
select create_hypertable('readings', 'time');
NOTICE:  adding not-null constraint to column "time"
   create_hypertable   
-----------------------
 (1,public,readings,t)
(1 row)

select setseed(1);
 setseed 
---------
 
(1 row)

insert into readings (time, location, device, temp, humidity)
select t, ceil(random()*3), ceil(random()*30), random()*40, random()*100
from generate_series('2022-06-01'::timestamptz, '2022-07-01', '5m') t;
alter table readings set (
      timescaledb.compress,
      timescaledb.compress_orderby = 'time',
      timescaledb.compress_segmentby = 'device'
);
WARNING:  column "location" should be used for segmenting or ordering
select format('%I.%I', chunk_schema, chunk_name)::regclass as chunk
  from timescaledb_information.chunks
 where format('%I.%I', hypertable_schema, hypertable_name)::regclass = 'readings'::regclass
 limit 1 \gset
alter table :chunk set access method hypercore;
--
-- Check that TID scan works for both compressed and non-compressed
-- rows.
--
set timescaledb.enable_transparent_decompression to false;
-- Select any row and try to fetch it using CTID. We do not select the
-- first one just to also try to scan a few rows and make sure the
-- implementation works.
select ctid from :chunk limit 1 offset 10 \gset
explain (analyze, costs off, timing off, summary off, decompress_cache_stats)
select * from :chunk where ctid = :'ctid';
                      QUERY PLAN                      
------------------------------------------------------
 Tid Scan on _hyper_1_1_chunk (actual rows=1 loops=1)
   TID Cond: (ctid = '(2147483650,1)'::tid)
(2 rows)

select * from :chunk where ctid = :'ctid';
             time             | location | device |       temp       |     humidity     
------------------------------+----------+--------+------------------+------------------
 Wed Jun 01 02:50:00 2022 PDT | 2        |      2 | 3.41795491467339 | 79.4169433908854
(1 row)

-- Insert a new row, which will then be non-compressed, and fetch it.
insert into :chunk values ('Wed May 25 17:34:56 2022 PDT', 1, 2, 3.14, 2.14);
select ctid from :chunk where time = 'Wed May 25 17:34:56 2022 PDT' \gset
explain (analyze, costs off, timing off, summary off, decompress_cache_stats)
select * from :chunk where ctid = :'ctid';
                      QUERY PLAN                      
------------------------------------------------------
 Tid Scan on _hyper_1_1_chunk (actual rows=1 loops=1)
   TID Cond: (ctid = '(0,1)'::tid)
(2 rows)

select * from :chunk where ctid = :'ctid';
             time             | location | device | temp | humidity 
------------------------------+----------+--------+------+----------
 Wed May 25 17:34:56 2022 PDT | 1        |      2 | 3.14 |     2.14
(1 row)

-- Check that a bad option name generates an error.
\set ON_ERROR_STOP 0
explain (analyze, costs off, timing off, summary off, decopress_cache_stats)
select * from :chunk where device between 5 and 10;
ERROR:  unrecognized EXPLAIN option "decopress_cache_stats" at character 55
\set ON_ERROR_STOP 1
explain (analyze, costs off, timing off, summary off, decompress_cache_stats)
select time, temp + humidity from readings where device between 5 and 10 and humidity > 5;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Result (actual rows=1624 loops=1)
   ->  Append (actual rows=1624 loops=1)
         ->  Index Scan using _hyper_1_1_chunk_readings_device_idx on _hyper_1_1_chunk (actual rows=34 loops=1)
               Index Cond: ((device >= 5) AND (device <= 10))
               Filter: (humidity > '5'::double precision)
               Rows Removed by Filter: 1
         ->  Index Scan using _hyper_1_2_chunk_readings_device_idx on _hyper_1_2_chunk (actual rows=404 loops=1)
               Index Cond: ((device >= 5) AND (device <= 10))
               Filter: (humidity > '5'::double precision)
               Rows Removed by Filter: 17
         ->  Index Scan using _hyper_1_3_chunk_readings_device_idx on _hyper_1_3_chunk (actual rows=380 loops=1)
               Index Cond: ((device >= 5) AND (device <= 10))
               Filter: (humidity > '5'::double precision)
               Rows Removed by Filter: 23
         ->  Index Scan using _hyper_1_4_chunk_readings_device_idx on _hyper_1_4_chunk (actual rows=359 loops=1)
               Index Cond: ((device >= 5) AND (device <= 10))
               Filter: (humidity > '5'::double precision)
               Rows Removed by Filter: 18
         ->  Index Scan using _hyper_1_5_chunk_readings_device_idx on _hyper_1_5_chunk (actual rows=379 loops=1)
               Index Cond: ((device >= 5) AND (device <= 10))
               Filter: (humidity > '5'::double precision)
               Rows Removed by Filter: 16
         ->  Index Scan using _hyper_1_6_chunk_readings_device_idx on _hyper_1_6_chunk (actual rows=68 loops=1)
               Index Cond: ((device >= 5) AND (device <= 10))
               Filter: (humidity > '5'::double precision)
               Rows Removed by Filter: 6
 Array: cache misses=6, decompress count=18 calls=105
(27 rows)

-- Testing JSON format to make sure it works and to get coverage for
-- those parts of the code.
explain (analyze, costs off, timing off, summary off, decompress_cache_stats, format json)
select time, temp + humidity from readings where device between 5 and 10 and humidity > 5;
                             QUERY PLAN                              
---------------------------------------------------------------------
 [                                                                  +
   {                                                                +
     "Plan": {                                                      +
       "Node Type": "Result",                                       +
       "Parallel Aware": false,                                     +
       "Async Capable": false,                                      +
       "Actual Rows": 1624,                                         +
       "Actual Loops": 1,                                           +
       "Plans": [                                                   +
         {                                                          +
           "Node Type": "Append",                                   +
           "Parent Relationship": "Outer",                          +
           "Parallel Aware": false,                                 +
           "Async Capable": false,                                  +
           "Actual Rows": 1624,                                     +
           "Actual Loops": 1,                                       +
           "Subplans Removed": 0,                                   +
           "Plans": [                                               +
             {                                                      +
               "Node Type": "Index Scan",                           +
               "Parent Relationship": "Member",                     +
               "Parallel Aware": false,                             +
               "Async Capable": false,                              +
               "Scan Direction": "Forward",                         +
               "Index Name": "_hyper_1_1_chunk_readings_device_idx",+
               "Relation Name": "_hyper_1_1_chunk",                 +
               "Alias": "_hyper_1_1_chunk",                         +
               "Actual Rows": 34,                                   +
               "Actual Loops": 1,                                   +
               "Index Cond": "((device >= 5) AND (device <= 10))",  +
               "Rows Removed by Index Recheck": 0,                  +
               "Filter": "(humidity > '5'::double precision)",      +
               "Rows Removed by Filter": 1                          +
             },                                                     +
             {                                                      +
               "Node Type": "Index Scan",                           +
               "Parent Relationship": "Member",                     +
               "Parallel Aware": false,                             +
               "Async Capable": false,                              +
               "Scan Direction": "Forward",                         +
               "Index Name": "_hyper_1_2_chunk_readings_device_idx",+
               "Relation Name": "_hyper_1_2_chunk",                 +
               "Alias": "_hyper_1_2_chunk",                         +
               "Actual Rows": 404,                                  +
               "Actual Loops": 1,                                   +
               "Index Cond": "((device >= 5) AND (device <= 10))",  +
               "Rows Removed by Index Recheck": 0,                  +
               "Filter": "(humidity > '5'::double precision)",      +
               "Rows Removed by Filter": 17                         +
             },                                                     +
             {                                                      +
               "Node Type": "Index Scan",                           +
               "Parent Relationship": "Member",                     +
               "Parallel Aware": false,                             +
               "Async Capable": false,                              +
               "Scan Direction": "Forward",                         +
               "Index Name": "_hyper_1_3_chunk_readings_device_idx",+
               "Relation Name": "_hyper_1_3_chunk",                 +
               "Alias": "_hyper_1_3_chunk",                         +
               "Actual Rows": 380,                                  +
               "Actual Loops": 1,                                   +
               "Index Cond": "((device >= 5) AND (device <= 10))",  +
               "Rows Removed by Index Recheck": 0,                  +
               "Filter": "(humidity > '5'::double precision)",      +
               "Rows Removed by Filter": 23                         +
             },                                                     +
             {                                                      +
               "Node Type": "Index Scan",                           +
               "Parent Relationship": "Member",                     +
               "Parallel Aware": false,                             +
               "Async Capable": false,                              +
               "Scan Direction": "Forward",                         +
               "Index Name": "_hyper_1_4_chunk_readings_device_idx",+
               "Relation Name": "_hyper_1_4_chunk",                 +
               "Alias": "_hyper_1_4_chunk",                         +
               "Actual Rows": 359,                                  +
               "Actual Loops": 1,                                   +
               "Index Cond": "((device >= 5) AND (device <= 10))",  +
               "Rows Removed by Index Recheck": 0,                  +
               "Filter": "(humidity > '5'::double precision)",      +
               "Rows Removed by Filter": 18                         +
             },                                                     +
             {                                                      +
               "Node Type": "Index Scan",                           +
               "Parent Relationship": "Member",                     +
               "Parallel Aware": false,                             +
               "Async Capable": false,                              +
               "Scan Direction": "Forward",                         +
               "Index Name": "_hyper_1_5_chunk_readings_device_idx",+
               "Relation Name": "_hyper_1_5_chunk",                 +
               "Alias": "_hyper_1_5_chunk",                         +
               "Actual Rows": 379,                                  +
               "Actual Loops": 1,                                   +
               "Index Cond": "((device >= 5) AND (device <= 10))",  +
               "Rows Removed by Index Recheck": 0,                  +
               "Filter": "(humidity > '5'::double precision)",      +
               "Rows Removed by Filter": 16                         +
             },                                                     +
             {                                                      +
               "Node Type": "Index Scan",                           +
               "Parent Relationship": "Member",                     +
               "Parallel Aware": false,                             +
               "Async Capable": false,                              +
               "Scan Direction": "Forward",                         +
               "Index Name": "_hyper_1_6_chunk_readings_device_idx",+
               "Relation Name": "_hyper_1_6_chunk",                 +
               "Alias": "_hyper_1_6_chunk",                         +
               "Actual Rows": 68,                                   +
               "Actual Loops": 1,                                   +
               "Index Cond": "((device >= 5) AND (device <= 10))",  +
               "Rows Removed by Index Recheck": 0,                  +
               "Filter": "(humidity > '5'::double precision)",      +
               "Rows Removed by Filter": 6                          +
             }                                                      +
           ]                                                        +
         }                                                          +
       ]                                                            +
     },                                                             +
     "Triggers": [                                                  +
     ]                                                              +
   },                                                               +
   "Arrow Array Cache": {                                           +
     "hits": 0,                                                     +
     "misses": 6,                                                   +
     "evictions": 0                                                 +
   },                                                               +
   "Arrow Array Decompress": {                                      +
     "count": 18,                                                   +
     "calls": 105                                                   +
   }                                                                +
 ]
(1 row)

-- Check the explain cache information output.
--
-- Query 1 and 3 should show the same explain plan, and the plan in
-- the middle should not include decompress stats:
explain (analyze, costs off, timing off, summary off, decompress_cache_stats)
select time, temp + humidity from readings where device between 5 and 10 and humidity > 5;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Result (actual rows=1624 loops=1)
   ->  Append (actual rows=1624 loops=1)
         ->  Index Scan using _hyper_1_1_chunk_readings_device_idx on _hyper_1_1_chunk (actual rows=34 loops=1)
               Index Cond: ((device >= 5) AND (device <= 10))
               Filter: (humidity > '5'::double precision)
               Rows Removed by Filter: 1
         ->  Index Scan using _hyper_1_2_chunk_readings_device_idx on _hyper_1_2_chunk (actual rows=404 loops=1)
               Index Cond: ((device >= 5) AND (device <= 10))
               Filter: (humidity > '5'::double precision)
               Rows Removed by Filter: 17
         ->  Index Scan using _hyper_1_3_chunk_readings_device_idx on _hyper_1_3_chunk (actual rows=380 loops=1)
               Index Cond: ((device >= 5) AND (device <= 10))
               Filter: (humidity > '5'::double precision)
               Rows Removed by Filter: 23
         ->  Index Scan using _hyper_1_4_chunk_readings_device_idx on _hyper_1_4_chunk (actual rows=359 loops=1)
               Index Cond: ((device >= 5) AND (device <= 10))
               Filter: (humidity > '5'::double precision)
               Rows Removed by Filter: 18
         ->  Index Scan using _hyper_1_5_chunk_readings_device_idx on _hyper_1_5_chunk (actual rows=379 loops=1)
               Index Cond: ((device >= 5) AND (device <= 10))
               Filter: (humidity > '5'::double precision)
               Rows Removed by Filter: 16
         ->  Index Scan using _hyper_1_6_chunk_readings_device_idx on _hyper_1_6_chunk (actual rows=68 loops=1)
               Index Cond: ((device >= 5) AND (device <= 10))
               Filter: (humidity > '5'::double precision)
               Rows Removed by Filter: 6
 Array: cache misses=6, decompress count=18 calls=105
(27 rows)

-- Check the explain cache information output. Query 1 and 3 should
-- show the same explain plan, and the plan in the middle should not
-- include decompress stats:
explain (analyze, costs off, timing off, summary off, decompress_cache_stats)
select * from :chunk where device between 5 and 10;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Index Scan using _hyper_1_1_chunk_readings_device_idx on _hyper_1_1_chunk (actual rows=35 loops=1)
   Index Cond: ((device >= 5) AND (device <= 10))
(2 rows)

explain (analyze, costs off, timing off, summary off, decompress_cache_stats)
select * from :chunk where device between 5 and 10;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Index Scan using _hyper_1_1_chunk_readings_device_idx on _hyper_1_1_chunk (actual rows=35 loops=1)
   Index Cond: ((device >= 5) AND (device <= 10))
(2 rows)

-- Queries that will select just a few columns
set max_parallel_workers_per_gather to 0;
explain (analyze, costs off, timing off, summary off, decompress_cache_stats)
select device, humidity from readings where device between 5 and 10;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Append (actual rows=1705 loops=1)
   ->  Index Scan using _hyper_1_1_chunk_readings_device_idx on _hyper_1_1_chunk (actual rows=35 loops=1)
         Index Cond: ((device >= 5) AND (device <= 10))
   ->  Index Scan using _hyper_1_2_chunk_readings_device_idx on _hyper_1_2_chunk (actual rows=421 loops=1)
         Index Cond: ((device >= 5) AND (device <= 10))
   ->  Index Scan using _hyper_1_3_chunk_readings_device_idx on _hyper_1_3_chunk (actual rows=403 loops=1)
         Index Cond: ((device >= 5) AND (device <= 10))
   ->  Index Scan using _hyper_1_4_chunk_readings_device_idx on _hyper_1_4_chunk (actual rows=377 loops=1)
         Index Cond: ((device >= 5) AND (device <= 10))
   ->  Index Scan using _hyper_1_5_chunk_readings_device_idx on _hyper_1_5_chunk (actual rows=395 loops=1)
         Index Cond: ((device >= 5) AND (device <= 10))
   ->  Index Scan using _hyper_1_6_chunk_readings_device_idx on _hyper_1_6_chunk (actual rows=74 loops=1)
         Index Cond: ((device >= 5) AND (device <= 10))
 Array: cache misses=6, decompress count=6 calls=35
(14 rows)

explain (analyze, costs off, timing off, summary off, decompress_cache_stats)
select device, avg(humidity) from readings where device between 5 and 10
group by device;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 HashAggregate (actual rows=6 loops=1)
   Group Key: _hyper_1_1_chunk.device
   Batches: 1 
   ->  Append (actual rows=1705 loops=1)
         ->  Index Scan using _hyper_1_1_chunk_readings_device_idx on _hyper_1_1_chunk (actual rows=35 loops=1)
               Index Cond: ((device >= 5) AND (device <= 10))
         ->  Index Scan using _hyper_1_2_chunk_readings_device_idx on _hyper_1_2_chunk (actual rows=421 loops=1)
               Index Cond: ((device >= 5) AND (device <= 10))
         ->  Index Scan using _hyper_1_3_chunk_readings_device_idx on _hyper_1_3_chunk (actual rows=403 loops=1)
               Index Cond: ((device >= 5) AND (device <= 10))
         ->  Index Scan using _hyper_1_4_chunk_readings_device_idx on _hyper_1_4_chunk (actual rows=377 loops=1)
               Index Cond: ((device >= 5) AND (device <= 10))
         ->  Index Scan using _hyper_1_5_chunk_readings_device_idx on _hyper_1_5_chunk (actual rows=395 loops=1)
               Index Cond: ((device >= 5) AND (device <= 10))
         ->  Index Scan using _hyper_1_6_chunk_readings_device_idx on _hyper_1_6_chunk (actual rows=74 loops=1)
               Index Cond: ((device >= 5) AND (device <= 10))
 Array: cache misses=6, decompress count=6 calls=35
(17 rows)

-- Test on conflict: insert the same data as before, but throw away
-- the updates.
explain (analyze, costs off, timing off, summary off, decompress_cache_stats)
insert into readings (time, location, device, temp, humidity)
select t, ceil(random()*10), ceil(random()*30), random()*40, random()*100
from generate_series('2022-06-01'::timestamptz, '2022-07-01', '5m') t
on conflict (location, device, time) do nothing;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Custom Scan (ModifyHypertable) (actual rows=0 loops=1)
   ->  Insert on readings (actual rows=0 loops=1)
         Conflict Resolution: NOTHING
         Conflict Arbiter Indexes: readings_device_location_time_key
         Tuples Inserted: 8608
         Conflicting Tuples: 33
         ->  Custom Scan (ChunkDispatch) (actual rows=8641 loops=1)
               ->  Subquery Scan on "*SELECT*" (actual rows=8641 loops=1)
                     ->  Function Scan on generate_series t (actual rows=8641 loops=1)
(9 rows)

-- This should show values for all columns
explain (analyze, costs off, timing off, summary off, decompress_cache_stats)
select time, temp + humidity from readings where device between 5 and 10 and humidity > 5 limit 5;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=5 loops=1)
   ->  Result (actual rows=5 loops=1)
         ->  Append (actual rows=5 loops=1)
               ->  Index Scan using _hyper_1_1_chunk_readings_device_idx on _hyper_1_1_chunk (actual rows=5 loops=1)
                     Index Cond: ((device >= 5) AND (device <= 10))
                     Filter: (humidity > '5'::double precision)
                     Rows Removed by Filter: 1
               ->  Index Scan using _hyper_1_2_chunk_readings_device_idx on _hyper_1_2_chunk (never executed)
                     Index Cond: ((device >= 5) AND (device <= 10))
                     Filter: (humidity > '5'::double precision)
               ->  Index Scan using _hyper_1_3_chunk_readings_device_idx on _hyper_1_3_chunk (never executed)
                     Index Cond: ((device >= 5) AND (device <= 10))
                     Filter: (humidity > '5'::double precision)
               ->  Index Scan using _hyper_1_4_chunk_readings_device_idx on _hyper_1_4_chunk (never executed)
                     Index Cond: ((device >= 5) AND (device <= 10))
                     Filter: (humidity > '5'::double precision)
               ->  Index Scan using _hyper_1_5_chunk_readings_device_idx on _hyper_1_5_chunk (never executed)
                     Index Cond: ((device >= 5) AND (device <= 10))
                     Filter: (humidity > '5'::double precision)
               ->  Index Scan using _hyper_1_6_chunk_readings_device_idx on _hyper_1_6_chunk (never executed)
                     Index Cond: ((device >= 5) AND (device <= 10))
                     Filter: (humidity > '5'::double precision)
(22 rows)

select time, temp + humidity from readings where device between 5 and 10 and humidity > 5 limit 5;
             time             |     ?column?     
------------------------------+------------------
 Wed Jun 01 04:30:00 2022 PDT | 100.201246910669
 Wed Jun 01 07:30:00 2022 PDT | 92.3407555735537
 Wed Jun 01 11:00:00 2022 PDT | 82.8938507105022
 Wed Jun 01 11:35:00 2022 PDT | 70.1222724677943
 Wed Jun 01 14:10:00 2022 PDT | 15.8070593822794
(5 rows)

-- Get the compressed chunk
select format('%I.%I', c2.schema_name, c2.table_name)::regclass as cchunk
from _timescaledb_catalog.chunk c1
join _timescaledb_catalog.chunk c2
on (c1.compressed_chunk_id = c2.id)
where format('%I.%I', c1.schema_name, c1.table_name)::regclass = :'chunk'::regclass \gset
-- Show that location is using dictionary encoding
select (_timescaledb_functions.compressed_data_info(location)).* from :cchunk limit 1;
 algorithm  | has_nulls 
------------+-----------
 DICTIONARY | f
(1 row)

-- Test that vectorized filtering on text column works
set enable_indexscan=off;
explain (analyze, costs off, timing off, summary off, decompress_cache_stats)
select time, location, temp from :chunk
where location = 1::text
order by time desc;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Sort (actual rows=88 loops=1)
   Sort Key: "time" DESC
   Sort Method: quicksort 
   ->  Custom Scan (ColumnarScan) on _hyper_1_1_chunk (actual rows=88 loops=1)
         Scankey: (location = '1'::text)
         Vectorized Filter: (location = '1'::text)
         Rows Removed by Filter: 113
(7 rows)

--  Save the data for comparison with seqscan
create temp table chunk_saved as
select time, location, temp from :chunk
where location = 1::text
order by time desc;
-- Show same query with seqscan and compare output
set timescaledb.enable_columnarscan=off;
explain (analyze, costs off, timing off, summary off)
select time, location, temp from :chunk
where location = 1::text
order by time desc;
                         QUERY PLAN                          
-------------------------------------------------------------
 Sort (actual rows=88 loops=1)
   Sort Key: "time" DESC
   Sort Method: quicksort 
   ->  Seq Scan on _hyper_1_1_chunk (actual rows=88 loops=1)
         Filter: (location = '1'::text)
         Rows Removed by Filter: 319
(6 rows)

-- If output is the same, this query should return nothing
(select time, location, temp from :chunk
where location = 1::text
order by time desc)
except
select * from chunk_saved;
 time | location | temp 
------+----------+------
(0 rows)

-- Insert some non-compressed values to see that vectorized filtering
-- works on those non-compressed text columns.
insert into :chunk values ('2022-06-01 15:30'::timestamptz, 1, 2, 3.14, 2.14), ('2022-06-01 15:30'::timestamptz, 2, 2, 3.14, 2.14);
-- Query should only return the one non-compressed row that has location=1
(select time, location, temp from :chunk
where location = 1::text
order by time desc)
except
select * from chunk_saved;
             time             | location | temp 
------------------------------+----------+------
 Wed Jun 01 15:30:00 2022 PDT | 1        | 3.14
(1 row)

-- Test that a ColumnarScan doesn't decompress anything if there are
-- no referenced columns, or the referenced column is a segmentby
-- column
set timescaledb.enable_columnarscan=true;
explain (analyze, costs off, timing off, summary off, decompress_cache_stats)
select count(*) from :chunk where device = 1;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (ColumnarScan) on _hyper_1_1_chunk (actual rows=17 loops=1)
         Scankey: (device = 1)
(3 rows)

explain (analyze, costs off, timing off, summary off, decompress_cache_stats)
select device from :chunk where device = 1;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Custom Scan (ColumnarScan) on _hyper_1_1_chunk (actual rows=17 loops=1)
   Scankey: (device = 1)
(2 rows)

-- Using a non-segmentby column will decompress that column
explain (analyze, costs off, timing off, summary off, decompress_cache_stats)
select count(*) from :chunk where location = 1::text;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Custom Scan (ColumnarScan) on _hyper_1_1_chunk (actual rows=89 loops=1)
         Scankey: (location = '1'::text)
         Vectorized Filter: (location = '1'::text)
         Rows Removed by Filter: 113
(5 rows)

-- Testing same thing with SeqScan. It still decompresses in the
-- count(*) case, although it shouldn't have to. So, probably an
-- opportunity to optimize.
set timescaledb.enable_columnarscan=false;
explain (analyze, costs off, timing off, summary off, decompress_cache_stats)
select count(*) from :chunk where device = 1;
                         QUERY PLAN                          
-------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Seq Scan on _hyper_1_1_chunk (actual rows=17 loops=1)
         Filter: (device = 1)
         Rows Removed by Filter: 392
(4 rows)

explain (analyze, costs off, timing off, summary off, decompress_cache_stats)
select device from :chunk where device = 1;
                      QUERY PLAN                       
-------------------------------------------------------
 Seq Scan on _hyper_1_1_chunk (actual rows=17 loops=1)
   Filter: (device = 1)
   Rows Removed by Filter: 392
(3 rows)

explain (analyze, costs off, timing off, summary off, decompress_cache_stats)
select count(*) from :chunk where location = 1::text;
                         QUERY PLAN                          
-------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Seq Scan on _hyper_1_1_chunk (actual rows=89 loops=1)
         Filter: (location = '1'::text)
         Rows Removed by Filter: 320
(4 rows)

-- ColumnarScan declares itself as projection capable. This query
-- would add a Result node on top if ColumnarScan couldn't project.
set timescaledb.enable_columnarscan=true;
explain (costs off)
select time, device+device as device_x2 from :chunk limit 1;
                      QUERY PLAN                      
------------------------------------------------------
 Limit
   ->  Custom Scan (ColumnarScan) on _hyper_1_1_chunk
(2 rows)

select time, device+device as device_x2 from :chunk limit 1;
             time             | device_x2 
------------------------------+-----------
 Wed Jun 01 00:55:00 2022 PDT |         2
(1 row)

-- Test sort using Bump memory context on PG17. This didn't use to
-- work on PG17 because it introduced a Bump memory context for
-- per-tuple processing on which compressed data was detoasted. This
-- doesn't work because Bump doesn't support pfree(), which is needed
-- by detoasting.
--
-- Need to convert all chunks to Hypercore TAM.
select compress_chunk(ch, hypercore_use_access_method=>true) from show_chunks('readings') ch;
             compress_chunk             
----------------------------------------
 _timescaledb_internal._hyper_1_1_chunk
 _timescaledb_internal._hyper_1_2_chunk
 _timescaledb_internal._hyper_1_3_chunk
 _timescaledb_internal._hyper_1_4_chunk
 _timescaledb_internal._hyper_1_5_chunk
 _timescaledb_internal._hyper_1_6_chunk
(6 rows)

-- Just test that this query doesn't fail with an error about Bump
-- allocator not supporting pfree. Redirect output to a temporary
-- table.
create temp table test_bump as
select * from readings order by time, device;
----------------------------------------------------------------------
--
-- Test scankey push-downs on orderby column. Vectorized filters (or
-- normal qual filters) should remain on all orderby columns, but not
-- segmentby columns.
--
----------------------------------------------------------------------
--
-- Test BETWEEN on time and equality on segmentby
--
explain (costs off)
select * from readings
where time between '2022-06-03' and '2022-06-05' and device = 1;
                                                                                 QUERY PLAN                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ColumnarScan) on _hyper_1_2_chunk
   Scankey: (("time" >= 'Fri Jun 03 00:00:00 2022 PDT'::timestamp with time zone) AND ("time" <= 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone) AND (device = 1))
   Vectorized Filter: (("time" >= 'Fri Jun 03 00:00:00 2022 PDT'::timestamp with time zone) AND ("time" <= 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone))
(3 rows)

select sum(humidity) from readings
where time between '2022-06-03' and '2022-06-05' and device = 1;
       sum        
------------------
 1979.06637167468
(1 row)

set timescaledb.enable_hypercore_scankey_pushdown=false;
explain (costs off)
select * from readings
where time between '2022-06-03' and '2022-06-05' and device = 1;
                                                                              QUERY PLAN                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ColumnarScan) on _hyper_1_2_chunk
   Filter: (device = 1)
   Vectorized Filter: (("time" >= 'Fri Jun 03 00:00:00 2022 PDT'::timestamp with time zone) AND ("time" <= 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone))
(3 rows)

select sum(humidity) from readings
where time between '2022-06-03' and '2022-06-05' and device = 1;
       sum        
------------------
 1979.06637167468
(1 row)

set timescaledb.enable_hypercore_scankey_pushdown=true;
--
-- Test < (LT) on time and > (GT) on segmentby
--
explain (costs off)
select * from readings
where time < '2022-06-05' and device > 5;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Append
   ->  Custom Scan (ColumnarScan) on _hyper_1_1_chunk
         Scankey: (("time" < 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone) AND (device > 5))
         Vectorized Filter: ("time" < 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone)
   ->  Custom Scan (ColumnarScan) on _hyper_1_2_chunk
         Scankey: (("time" < 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone) AND (device > 5))
         Vectorized Filter: ("time" < 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone)
(7 rows)

select sum(humidity) from readings
where time < '2022-06-05' and device > 5;
       sum        
------------------
 97096.6439132039
(1 row)

set timescaledb.enable_hypercore_scankey_pushdown=false;
explain (costs off)
select * from readings
where time < '2022-06-05' and device > 5;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Append
   ->  Custom Scan (ColumnarScan) on _hyper_1_1_chunk
         Filter: (device > 5)
         Vectorized Filter: ("time" < 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone)
   ->  Custom Scan (ColumnarScan) on _hyper_1_2_chunk
         Filter: (device > 5)
         Vectorized Filter: ("time" < 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone)
(7 rows)

select sum(humidity) from readings
where time < '2022-06-05' and device > 5;
       sum        
------------------
 97096.6439132039
(1 row)

set timescaledb.enable_hypercore_scankey_pushdown=true;
--
-- Test >= (GE) on time
--
explain (costs off)
select * from readings
where time >= '2022-06-05' and device > 5;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Append
   ->  Custom Scan (ColumnarScan) on _hyper_1_2_chunk
         Scankey: (("time" >= 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone) AND (device > 5))
         Vectorized Filter: ("time" >= 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone)
   ->  Custom Scan (ColumnarScan) on _hyper_1_3_chunk
         Scankey: (("time" >= 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone) AND (device > 5))
         Vectorized Filter: ("time" >= 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone)
   ->  Custom Scan (ColumnarScan) on _hyper_1_4_chunk
         Scankey: (("time" >= 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone) AND (device > 5))
         Vectorized Filter: ("time" >= 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone)
   ->  Custom Scan (ColumnarScan) on _hyper_1_5_chunk
         Scankey: (("time" >= 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone) AND (device > 5))
         Vectorized Filter: ("time" >= 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone)
   ->  Custom Scan (ColumnarScan) on _hyper_1_6_chunk
         Scankey: (("time" >= 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone) AND (device > 5))
         Vectorized Filter: ("time" >= 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone)
(16 rows)

select sum(humidity) from readings
where time >= '2022-06-05' and device > 5;
       sum       
-----------------
 619887.78450012
(1 row)

set timescaledb.enable_hypercore_scankey_pushdown=false;
explain (costs off)
select * from readings
where time >= '2022-06-05' and device > 5;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Append
   ->  Custom Scan (ColumnarScan) on _hyper_1_2_chunk
         Filter: (device > 5)
         Vectorized Filter: ("time" >= 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone)
   ->  Custom Scan (ColumnarScan) on _hyper_1_3_chunk
         Filter: (device > 5)
         Vectorized Filter: ("time" >= 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone)
   ->  Custom Scan (ColumnarScan) on _hyper_1_4_chunk
         Filter: (device > 5)
         Vectorized Filter: ("time" >= 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone)
   ->  Custom Scan (ColumnarScan) on _hyper_1_5_chunk
         Filter: (device > 5)
         Vectorized Filter: ("time" >= 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone)
   ->  Custom Scan (ColumnarScan) on _hyper_1_6_chunk
         Filter: (device > 5)
         Vectorized Filter: ("time" >= 'Sun Jun 05 00:00:00 2022 PDT'::timestamp with time zone)
(16 rows)

select sum(humidity) from readings
where time >= '2022-06-05' and device > 5;
       sum       
-----------------
 619887.78450012
(1 row)

set timescaledb.enable_hypercore_scankey_pushdown=true;
--
-- Test = (equality) on time
--
explain (costs off)
select * from readings
where time = '2022-06-01' and 5 < device;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Custom Scan (ColumnarScan) on _hyper_1_1_chunk
   Scankey: ((5 < device) AND ("time" = 'Wed Jun 01 00:00:00 2022 PDT'::timestamp with time zone))
   Vectorized Filter: ("time" = 'Wed Jun 01 00:00:00 2022 PDT'::timestamp with time zone)
(3 rows)

select sum(humidity) from readings
where time = '2022-06-01' and 5 < device;
 sum 
-----
    
(1 row)

set timescaledb.enable_hypercore_scankey_pushdown=false;
explain (costs off)
select * from readings
where time = '2022-06-01' and 5 < device;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Custom Scan (ColumnarScan) on _hyper_1_1_chunk
   Filter: (5 < device)
   Vectorized Filter: ("time" = 'Wed Jun 01 00:00:00 2022 PDT'::timestamp with time zone)
(3 rows)

select sum(humidity) from readings
where time = '2022-06-01' and 4 < device;
       sum        
------------------
 115.397092269175
(1 row)

set timescaledb.enable_hypercore_scankey_pushdown=true;
--
-- Test scankey push down on non-orderby min/max column
--
explain (costs off)
select * from readings
where time = '2022-06-01' and '5' = location;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Custom Scan (ColumnarScan) on _hyper_1_1_chunk
   Scankey: (("time" = 'Wed Jun 01 00:00:00 2022 PDT'::timestamp with time zone) AND ('5'::text = location))
   Vectorized Filter: (("time" = 'Wed Jun 01 00:00:00 2022 PDT'::timestamp with time zone) AND (location = '5'::text))
(3 rows)

select sum(humidity) from readings
where time = '2022-06-01' and '5' = location;
 sum 
-----
    
(1 row)

set timescaledb.enable_hypercore_scankey_pushdown=false;
explain (costs off)
select * from readings
where time = '2022-06-01' and '5' = location;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Custom Scan (ColumnarScan) on _hyper_1_1_chunk
   Vectorized Filter: (("time" = 'Wed Jun 01 00:00:00 2022 PDT'::timestamp with time zone) AND (location = '5'::text))
(2 rows)

select sum(humidity) from readings
where time = '2022-06-01' and '4' = location;
 sum 
-----
    
(1 row)

set timescaledb.enable_hypercore_scankey_pushdown=true;
--
-- Test non-btree operator on segmentby column and compare with btree
-- operators.
--
explain (costs off)
select sum(humidity) from readings
where time <= '2022-06-02' and device <> 1;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Append
         ->  Custom Scan (ColumnarScan) on _hyper_1_1_chunk
               Filter: (device <> 1)
               Scankey: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
               Vectorized Filter: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
         ->  Custom Scan (ColumnarScan) on _hyper_1_2_chunk
               Filter: (device <> 1)
               Scankey: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
               Vectorized Filter: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
(10 rows)

select sum(humidity) from readings
where time <= '2022-06-02' and device <> 1;
       sum        
------------------
 29162.2138479675
(1 row)

explain (costs off)
select sum(humidity) from readings
where time <= '2022-06-02' and device != 1;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Append
         ->  Custom Scan (ColumnarScan) on _hyper_1_1_chunk
               Filter: (device <> 1)
               Scankey: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
               Vectorized Filter: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
         ->  Custom Scan (ColumnarScan) on _hyper_1_2_chunk
               Filter: (device <> 1)
               Scankey: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
               Vectorized Filter: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
(10 rows)

select sum(humidity) from readings
where time <= '2022-06-02' and device != 1;
       sum        
------------------
 29162.2138479675
(1 row)

set timescaledb.enable_hypercore_scankey_pushdown=false;
explain (costs off)
select sum(humidity) from readings
where time <= '2022-06-02' and device <> 1;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Append
         ->  Custom Scan (ColumnarScan) on _hyper_1_1_chunk
               Filter: (device <> 1)
               Vectorized Filter: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
         ->  Custom Scan (ColumnarScan) on _hyper_1_2_chunk
               Filter: (device <> 1)
               Vectorized Filter: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
(8 rows)

select sum(humidity) from readings
where time <= '2022-06-02' and device <> 1;
       sum        
------------------
 29162.2138479675
(1 row)

set timescaledb.enable_hypercore_scankey_pushdown=true;
--
-- Test non-btree operator on non-segmentby column and compare with
-- btree operators.
--
explain (costs off)
select sum(humidity) from readings
where time <= '2022-06-02' and temp <> 1;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Append
         ->  Custom Scan (ColumnarScan) on _hyper_1_1_chunk
               Scankey: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
               Vectorized Filter: (("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone) AND (temp <> '1'::double precision))
         ->  Custom Scan (ColumnarScan) on _hyper_1_2_chunk
               Scankey: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
               Vectorized Filter: (("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone) AND (temp <> '1'::double precision))
(8 rows)

select sum(humidity) from readings
where time <= '2022-06-02' and temp <> 1;
       sum        
------------------
 30543.8523547207
(1 row)

explain (costs off)
select sum(humidity) from readings
where time <= '2022-06-02' and temp != 1;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Append
         ->  Custom Scan (ColumnarScan) on _hyper_1_1_chunk
               Scankey: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
               Vectorized Filter: (("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone) AND (temp <> '1'::double precision))
         ->  Custom Scan (ColumnarScan) on _hyper_1_2_chunk
               Scankey: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
               Vectorized Filter: (("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone) AND (temp <> '1'::double precision))
(8 rows)

select sum(humidity) from readings
where time <= '2022-06-02' and temp != 1;
       sum        
------------------
 30543.8523547207
(1 row)

set timescaledb.enable_hypercore_scankey_pushdown=false;
explain (costs off)
select sum(humidity) from readings
where time <= '2022-06-02' and temp <> 1;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Append
         ->  Custom Scan (ColumnarScan) on _hyper_1_1_chunk
               Vectorized Filter: (("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone) AND (temp <> '1'::double precision))
         ->  Custom Scan (ColumnarScan) on _hyper_1_2_chunk
               Vectorized Filter: (("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone) AND (temp <> '1'::double precision))
(6 rows)

select sum(humidity) from readings
where time <= '2022-06-02' and temp <> 1;
       sum        
------------------
 30543.8523547207
(1 row)

set timescaledb.enable_hypercore_scankey_pushdown=true;
--
-- Test "foo IN (1, 2)" (ScalarArrayOpExpr)
--
-- This is currently not transformed to scan keys because only index
-- scans support such keys.
--
explain (costs off)
select * from readings
where time <= '2022-06-02' and device in (1, 4);
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Append
   ->  Custom Scan (ColumnarScan) on _hyper_1_1_chunk
         Filter: (device = ANY ('{1,4}'::integer[]))
         Scankey: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
         Vectorized Filter: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
   ->  Custom Scan (ColumnarScan) on _hyper_1_2_chunk
         Filter: (device = ANY ('{1,4}'::integer[]))
         Scankey: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
         Vectorized Filter: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
(9 rows)

select sum(humidity) from readings
where time <= '2022-06-02' and device in (1, 4);
       sum        
------------------
 2113.95150227923
(1 row)

set timescaledb.enable_hypercore_scankey_pushdown=false;
explain (costs off)
select * from readings
where time <= '2022-06-02' and device in (1, 4);
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Append
   ->  Custom Scan (ColumnarScan) on _hyper_1_1_chunk
         Filter: (device = ANY ('{1,4}'::integer[]))
         Vectorized Filter: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
   ->  Custom Scan (ColumnarScan) on _hyper_1_2_chunk
         Filter: (device = ANY ('{1,4}'::integer[]))
         Vectorized Filter: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
(7 rows)

select sum(humidity) from readings
where time <= '2022-06-02' and device in (1, 4);
       sum        
------------------
 2113.95150227923
(1 row)

set timescaledb.enable_hypercore_scankey_pushdown=true;
-- ScalarArrayOpExpr "foo IN (1, 2)" are pushed down to compressed
-- chunk with transparent decompression. As noted above, with TAM,
-- such expressions are not pushed down as scan keys because only
-- index scans support such keys.
set timescaledb.enable_transparent_decompression='hypercore';
explain (costs off)
select * from readings
where time <= '2022-06-02' and device in (1, 4);
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Append
   ->  Custom Scan (DecompressChunk) on _hyper_1_1_chunk
         Vectorized Filter: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
         ->  Seq Scan on compress_hyper_2_7_chunk
               Filter: ((_ts_meta_min_1 <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone) AND (device = ANY ('{1,4}'::integer[])))
   ->  Custom Scan (DecompressChunk) on _hyper_1_2_chunk
         Vectorized Filter: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
         ->  Seq Scan on compress_hyper_2_8_chunk
               Filter: ((_ts_meta_min_1 <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone) AND (device = ANY ('{1,4}'::integer[])))
(9 rows)

select sum(humidity) from readings
where time <= '2022-06-02' and device in (1, 4);
       sum        
------------------
 2113.95150227923
(1 row)

set timescaledb.enable_transparent_decompression=true;
--
-- Test filter that doesn't reference a column.
--
select setseed(0.1);
 setseed 
---------
 
(1 row)

explain (costs off)
select * from readings
where time <= '2022-06-02' and ceil(random()*6)::int = 2;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Custom Scan (ChunkAppend) on readings
   Chunks excluded during startup: 0
   ->  Custom Scan (ColumnarScan) on _hyper_1_1_chunk
         Filter: ((ceil((random() * '6'::double precision)))::integer = 2)
         Scankey: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
         Vectorized Filter: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
   ->  Custom Scan (ColumnarScan) on _hyper_1_2_chunk
         Filter: ((ceil((random() * '6'::double precision)))::integer = 2)
         Scankey: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
         Vectorized Filter: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
(10 rows)

select sum(humidity) from readings
where time <= '2022-06-02' and ceil(random()*6)::int = 2;
       sum        
------------------
 4617.95296817946
(1 row)

--
-- Test filter that doesn't have a Const on left or right side.
--
explain (costs off)
select * from readings
where time <= '2022-06-02' and location::int = device;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Append
   ->  Custom Scan (ColumnarScan) on _hyper_1_1_chunk
         Filter: ((location)::integer = device)
         Scankey: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
         Vectorized Filter: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
   ->  Custom Scan (ColumnarScan) on _hyper_1_2_chunk
         Filter: ((location)::integer = device)
         Scankey: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
         Vectorized Filter: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
(9 rows)

select sum(humidity) from readings
where time <= '2022-06-02' and location::int = device;
       sum       
-----------------
 1587.5766975512
(1 row)

--
-- Test filter that does coercing (CoerceViaIO) type. Not pushed down
-- as scankey.
--
explain (costs off)
select * from readings
where time <= '2022-06-02' and '1' = device::text;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Append
   ->  Custom Scan (ColumnarScan) on _hyper_1_1_chunk
         Filter: ('1'::text = (device)::text)
         Scankey: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
         Vectorized Filter: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
   ->  Custom Scan (ColumnarScan) on _hyper_1_2_chunk
         Filter: ('1'::text = (device)::text)
         Scankey: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
         Vectorized Filter: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
(9 rows)

select sum(humidity) from readings
where time <= '2022-06-02' and '1' = device::text;
       sum        
------------------
 1381.63850675326
(1 row)

--
-- Test filter that does relabeling (RelabelType) for binary
-- compatible types, both left and right side of expression.
--
explain (costs off)
select * from readings
where time <= '2022-06-02' and '1'::oid = device;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Append
   ->  Custom Scan (ColumnarScan) on _hyper_1_1_chunk
         Scankey: (("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone) AND ('1'::oid = (device)::oid))
         Vectorized Filter: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
   ->  Custom Scan (ColumnarScan) on _hyper_1_2_chunk
         Scankey: (("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone) AND ('1'::oid = (device)::oid))
         Vectorized Filter: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
(7 rows)

select sum(humidity) from readings
where time <= '2022-06-02' and '1'::oid = device;
       sum        
------------------
 1381.63850675326
(1 row)

explain (costs off)
select sum(humidity) from readings
where time <= '2022-06-02' and device = '1'::oid;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Append
         ->  Custom Scan (ColumnarScan) on _hyper_1_1_chunk
               Scankey: (("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone) AND ((device)::oid = '1'::oid))
               Vectorized Filter: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
         ->  Custom Scan (ColumnarScan) on _hyper_1_2_chunk
               Scankey: (("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone) AND ((device)::oid = '1'::oid))
               Vectorized Filter: ("time" <= 'Thu Jun 02 00:00:00 2022 PDT'::timestamp with time zone)
(8 rows)

select sum(humidity) from readings
where time <= '2022-06-02' and device = '1'::oid;
       sum        
------------------
 1381.63850675326
(1 row)

--
-- Test backwards scan with segmentby and vector quals
--
select count(*)-4 as myoffset from readings
where time <= '2022-06-02' and device in (1, 2)
\gset
-- Get the last four values to compare with cursor fetch backward from
-- the end
select * from readings
where time <= '2022-06-02' and device in (1, 2)
offset :myoffset;
             time             | location | device |       temp       |     humidity     
------------------------------+----------+--------+------------------+------------------
 Wed Jun 01 19:10:00 2022 PDT | 3        |      2 | 25.6339083021175 | 85.7531443688847
 Wed Jun 01 20:30:00 2022 PDT | 2        |      2 | 6.02098537951642 | 56.3153986241908
 Wed Jun 01 23:15:00 2022 PDT | 2        |      2 | 35.7529756426646 | 86.0243391529811
 Wed Jun 01 23:40:00 2022 PDT | 3        |      2 | 3.94232546784524 |  55.454709690509
(4 rows)

begin;
declare cur1 scroll cursor for
select * from readings
where time <= '2022-06-02' and device in (1, 2);
move last cur1;
-- move one step beyond last
fetch forward 1 from cur1;
 time | location | device | temp | humidity 
------+----------+--------+------+----------
(0 rows)

-- fetch the last 4 values with two fetches
fetch backward 2 from cur1;
             time             | location | device |       temp       |     humidity     
------------------------------+----------+--------+------------------+------------------
 Wed Jun 01 23:40:00 2022 PDT | 3        |      2 | 3.94232546784524 |  55.454709690509
 Wed Jun 01 23:15:00 2022 PDT | 2        |      2 | 35.7529756426646 | 86.0243391529811
(2 rows)

fetch backward 2 from cur1;
             time             | location | device |       temp       |     humidity     
------------------------------+----------+--------+------------------+------------------
 Wed Jun 01 20:30:00 2022 PDT | 2        |      2 | 6.02098537951642 | 56.3153986241908
 Wed Jun 01 19:10:00 2022 PDT | 3        |      2 | 25.6339083021175 | 85.7531443688847
(2 rows)

close cur1;
commit;
reset timescaledb.enable_chunkwise_aggregation;
reset timescaledb.enable_sparse_index_bloom;
