-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
\set ECHO queries
create or replace function twist_chunk(chunk regclass) returns regclass language plpgsql
as $$
begin
    execute format('alter table %s set access method hyperstore', chunk);
    return chunk;
end
$$;
create or replace function untwist_chunk(chunk regclass) returns regclass language plpgsql
as $$
begin
    execute format('alter table %s set access method heap', chunk);
    return chunk;
end
$$;
create function explain_anonymize(text) returns setof text
language plpgsql as
$$
declare
    ln text;
begin
    for ln in
        execute format('explain (analyze, costs off, summary off, timing off, decompress_cache_stats) %s', $1)
    loop
        ln := regexp_replace(ln, 'Arrays read from cache: \d+', 'Arrays read from cache: N');
        ln := regexp_replace(ln, 'Heap Fetches: \d+', 'Heap Fetches: N');
        ln := regexp_replace(ln, 'Workers Launched: \d+', 'Workers Launched: N');
        ln := regexp_replace(ln, 'actual rows=\d+ loops=\d+', 'actual rows=N loops=N');
	ln := regexp_replace(ln, '_hyper_\d+_\d+_chunk', '_hyper_I_N_chunk');
        return next ln;
    end loop;
end;
$$;
create table readings(
       metric_id serial,
       created_at timestamptz not null unique,
       location_id int,		--segmentby attribute with index
       owner_id int,		--segmentby attribute without index
       device_id int,		--non-segmentby attribute
       temp float,
       humidity float
);
create index hypertable_location_id_idx on readings (location_id);
create index hypertable_device_id_idx on readings (device_id);
select create_hypertable('readings', by_range('created_at'));
 create_hypertable 
-------------------
 (1,t)
(1 row)

set enable_incremental_sort = false;
select setseed(1);
 setseed 
---------
 
(1 row)

insert into readings (created_at, location_id, device_id, owner_id, temp, humidity)
select t, ceil(random()*10), ceil(random()*30), ceil(random() * 5), random()*40, random()*100
from generate_series('2022-06-01'::timestamptz, '2022-07-01', '10s') t;
alter table readings set (
	  timescaledb.compress,
	  timescaledb.compress_orderby = 'created_at',
	  timescaledb.compress_segmentby = 'location_id, owner_id'
);
select format('%I.%I', chunk_schema, chunk_name)::regclass as chunk1
  from timescaledb_information.chunks
 where format('%I.%I', hypertable_schema, hypertable_name)::regclass = 'readings'::regclass
 order by chunk1 asc
 limit 1 
select format('%I.%I', chunk_schema, chunk_name)::regclass as chunk2
  from timescaledb_information.chunks
 where format('%I.%I', hypertable_schema, hypertable_name)::regclass = 'readings'::regclass
 order by chunk2 asc
 limit 1 offset 1 
set timescaledb.enable_columnarscan to false;
set enable_memoize to false;
create table the_hyperstore (
       updated_at timestamptz not null unique,
       device_id int,
       height float
);
create index on the_hyperstore (device_id);
select from create_hypertable('the_hyperstore', 'updated_at');
--
(1 row)

insert into the_hyperstore
select t, ceil(random()*5), random()*40
from generate_series('2022-06-01'::timestamptz, '2022-06-10', '1 hour') t;
select * into expected_inner from _timescaledb_internal._hyper_1_1_chunk join the_hyperstore using (device_id);
select created_at, updated_at, o.device_id, i.humidity, o.height
  into expected_left
  from _timescaledb_internal._hyper_1_1_chunk i left join the_hyperstore o
    on i.created_at = o.updated_at and i.device_id = o.device_id;
alter table the_hyperstore set (
      timescaledb.compress,
      timescaledb.compress_segmentby = '',
      timescaledb.compress_orderby = 'updated_at desc'
);
select twist_chunk(show_chunks('the_hyperstore'));
              twist_chunk               
----------------------------------------
 _timescaledb_internal._hyper_3_7_chunk
 _timescaledb_internal._hyper_3_8_chunk
 _timescaledb_internal._hyper_3_9_chunk
(3 rows)

vacuum analyze the_hyperstore;
set enable_mergejoin to true;
set enable_hashjoin to false;
set enable_nestloop to false;
select explain_anonymize(format($$
    select * from %s join the_hyperstore using (device_id)
$$, '_timescaledb_internal._hyper_1_1_chunk'));
                                                      explain_anonymize                                                       
------------------------------------------------------------------------------------------------------------------------------
 Merge Join (actual rows=N loops=N)
   Merge Cond: (_hyper_I_N_chunk.device_id = _hyper_3_7_chunk.device_id)
   ->  Index Scan using _hyper_I_N_chunk_hypertable_device_id_idx on _hyper_1_1_chunk (actual rows=N loops=N)
   ->  Materialize (actual rows=N loops=N)
         ->  Merge Append (actual rows=N loops=N)
               Sort Key: _hyper_I_N_chunk.device_id
               ->  Index Scan using _hyper_I_N_chunk_the_hyperstore_device_id_idx on _hyper_3_7_chunk (actual rows=N loops=N)
               ->  Index Scan using _hyper_I_N_chunk_the_hyperstore_device_id_idx on _hyper_3_8_chunk (actual rows=N loops=N)
               ->  Index Scan using _hyper_I_N_chunk_the_hyperstore_device_id_idx on _hyper_3_9_chunk (actual rows=N loops=N)
 Arrays read from cache: N
 Arrays decompressed: 9
(11 rows)

select * into merge_join from _timescaledb_internal._hyper_1_1_chunk join the_hyperstore using (device_id);
select * from merge_join r full join expected_inner e on row(r) = row(e)
where r.device_id is null or e.device_id is null;
(0 rows)

select explain_anonymize(format($$
select created_at, updated_at, o.device_id, i.humidity, o.height
  from :chunk1 i left join the_hyperstore o
    on i.created_at = o.updated_at and i.device_id = o.device_id;

select created_at, updated_at, o.device_id, i.humidity, o.height
  into :outer
  from :chunk1 i left join the_hyperstore o
    on i.created_at = o.updated_at and i.device_id = o.device_id;
$$, '_timescaledb_internal._hyper_1_1_chunk'));
psql:include/hyperstore_join_test.sql:31: ERROR:  syntax error at or near ":" at character 152
