-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
\ir include/hyperstore_helpers.sql
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- Alternative function to compress_chunk that uses the table access
-- method to compress a chunk.
create or replace function twist_chunk(chunk regclass) returns regclass language plpgsql
as $$
begin
    execute format('alter table %s set access method hyperstore', chunk);
    return chunk;
end
$$;
create or replace function untwist_chunk(chunk regclass) returns regclass language plpgsql
as $$
begin
    execute format('alter table %s set access method heap', chunk);
    return chunk;
end
$$;
-- Function to run an explain analyze with and do replacements on the
-- emitted plan. This is intended to be used when the structure of the
-- plan is important, but not the specific chunks scanned nor the
-- number of heap fetches, rows, loops, etc.
create function explain_anonymize(text) returns setof text
language plpgsql as
$$
declare
    ln text;
begin
    for ln in
        execute format('explain (analyze, costs off, summary off, timing off, decompress_cache_stats) %s', $1)
    loop
        ln := regexp_replace(ln, 'Arrays read from cache: \d+', 'Arrays read from cache: N');
        ln := regexp_replace(ln, 'Heap Fetches: \d+', 'Heap Fetches: N');
        ln := regexp_replace(ln, 'Workers Launched: \d+', 'Workers Launched: N');
        ln := regexp_replace(ln, 'actual rows=\d+ loops=\d+', 'actual rows=N loops=N');
	ln := regexp_replace(ln, '_hyper_\d+_\d+_chunk', '_hyper_I_N_chunk');
        return next ln;
    end loop;
end;
$$;
select setseed(0.3);
 setseed 
---------
 
(1 row)

-- Testing the basic API for creating a hyperstore
CREATE TABLE test2(
	   created_at timestamptz not null,
	   location_id int,
	   device_id int,
	   temp float,
	   humidity float
);
create index on test2(device_id, created_at);
\set ON_ERROR_STOP 0
alter table test2 set access method hyperstore;
ERROR:  hyperstore access method not supported on "test2"
\set ON_ERROR_STOP 1
select create_hypertable('test2', 'created_at');
 create_hypertable  
--------------------
 (1,public,test2,t)
(1 row)

\set ON_ERROR_STOP 0
-- Should show error since there is no namespace.
alter table test2
	  set access method hyperstore,
	  set (compress_segmentby = 'location_id');
WARNING:  there was some uncertainty picking the default segment by for the hypertable: Please make sure device_id is not a unique column and appropriate for a segment by
NOTICE:  default segment by for hypertable "test2" is set to "device_id"
NOTICE:  default order by for hypertable "test2" is set to "created_at DESC"
ERROR:  unrecognized parameter "compress_segmentby"
\set ON_ERROR_STOP 1
alter table test2
	  set access method hyperstore,
	  set (timescaledb.compress_segmentby = 'location_id');
NOTICE:  default order by for hypertable "test2" is set to "created_at DESC, device_id"
-- Test altering hypertable to hyperstore again. It should be allowed
-- and be a no-op.
alter table test2 set access method hyperstore;
\set ON_ERROR_STOP 0
-- This shows an error but the error is weird, we should probably get
-- a better one.
alter table test2
	  set access method hyperstore,
	  set (compress_segmentby = 'location_id');
ERROR:  unrecognized parameter "compress_segmentby"
\set ON_ERROR_STOP 1
-- Create view for hyperstore rels
create view amrels as
select cl.oid::regclass as rel, am.amname, inh.inhparent::regclass as relparent
  from pg_class cl
  inner join pg_am am on (cl.relam = am.oid)
  left join pg_inherits inh on (inh.inhrelid = cl.oid);
-- Show that test2 is a hyperstore
select rel, amname
from amrels
where rel='test2'::regclass;
  rel  |   amname   
-------+------------
 test2 | hyperstore
(1 row)

-- This will create new chunks for the hypertable
insert into test2 (created_at, location_id, device_id, temp, humidity)
select t, ceil(random()*10), ceil(random()*30), random()*40, random()*100
from generate_series('2022-06-01'::timestamptz, '2022-07-01', '5s') t;
-- All chunks should use the hyperstore access method
select * from amrels
where relparent='test2'::regclass;
                   rel                   |   amname   | relparent 
-----------------------------------------+------------+-----------
 _timescaledb_internal._hyper_1_1_chunk  | hyperstore | test2
 _timescaledb_internal._hyper_1_3_chunk  | hyperstore | test2
 _timescaledb_internal._hyper_1_5_chunk  | hyperstore | test2
 _timescaledb_internal._hyper_1_7_chunk  | hyperstore | test2
 _timescaledb_internal._hyper_1_9_chunk  | hyperstore | test2
 _timescaledb_internal._hyper_1_11_chunk | hyperstore | test2
(6 rows)

-- Show compression settings for hyperstore across catalog and views
select * from _timescaledb_catalog.compression_settings;
                      relid                      |   segmentby   |        orderby         | orderby_desc | orderby_nullsfirst 
-------------------------------------------------+---------------+------------------------+--------------+--------------------
 test2                                           | {location_id} | {created_at,device_id} | {t,f}        | {t,f}
 _timescaledb_internal.compress_hyper_3_2_chunk  | {location_id} | {created_at,device_id} | {t,f}        | {t,f}
 _timescaledb_internal.compress_hyper_3_4_chunk  | {location_id} | {created_at,device_id} | {t,f}        | {t,f}
 _timescaledb_internal.compress_hyper_3_6_chunk  | {location_id} | {created_at,device_id} | {t,f}        | {t,f}
 _timescaledb_internal.compress_hyper_3_8_chunk  | {location_id} | {created_at,device_id} | {t,f}        | {t,f}
 _timescaledb_internal.compress_hyper_3_10_chunk | {location_id} | {created_at,device_id} | {t,f}        | {t,f}
 _timescaledb_internal.compress_hyper_3_12_chunk | {location_id} | {created_at,device_id} | {t,f}        | {t,f}
(7 rows)

select * from timescaledb_information.compression_settings;
 hypertable_schema | hypertable_name |   attname   | segmentby_column_index | orderby_column_index | orderby_asc | orderby_nullsfirst 
-------------------+-----------------+-------------+------------------------+----------------------+-------------+--------------------
 public            | test2           | location_id |                      1 |                      |             | 
 public            | test2           | created_at  |                        |                    1 | f           | t
 public            | test2           | device_id   |                        |                    2 | t           | f
(3 rows)

select * from timescaledb_information.chunk_compression_settings;
 hypertable |                  chunk                  |  segmentby  |          orderby          
------------+-----------------------------------------+-------------+---------------------------
 test2      | _timescaledb_internal._hyper_1_1_chunk  | location_id | created_at DESC,device_id
 test2      | _timescaledb_internal._hyper_1_3_chunk  | location_id | created_at DESC,device_id
 test2      | _timescaledb_internal._hyper_1_5_chunk  | location_id | created_at DESC,device_id
 test2      | _timescaledb_internal._hyper_1_7_chunk  | location_id | created_at DESC,device_id
 test2      | _timescaledb_internal._hyper_1_9_chunk  | location_id | created_at DESC,device_id
 test2      | _timescaledb_internal._hyper_1_11_chunk | location_id | created_at DESC,device_id
(6 rows)

--------------------------
-- Test alter on chunks --
--------------------------
create table test3 (time timestamptz not null, device int, temp float);
select create_hypertable('test3', 'time');
 create_hypertable  
--------------------
 (4,public,test3,t)
(1 row)

-- create one chunk
insert into test3 values ('2022-06-01', 1, 1.0);
-- save chunk as variable
select ch as chunk from show_chunks('test3') ch limit 1 \gset
-- Check that chunk is NOT using hyperstore
select rel, amname
from amrels
where relparent='test3'::regclass;
                   rel                   | amname 
-----------------------------------------+--------
 _timescaledb_internal._hyper_4_13_chunk | heap
(1 row)

\set ON_ERROR_STOP 0
alter table :chunk set access method hyperstore;
ERROR:  hypertable "test3" is missing compression settings
\set ON_ERROR_STOP 1
-- Add compression settings
alter table test3 set (timescaledb.compress_segmentby = 'device');
NOTICE:  default order by for hypertable "test3" is set to ""time" DESC"
alter table :chunk set access method hyperstore;
-- Check that chunk is using hyperstore
select * from amrels where rel=:'chunk'::regclass;
                   rel                   |   amname   | relparent 
-----------------------------------------+------------+-----------
 _timescaledb_internal._hyper_4_13_chunk | hyperstore | test3
(1 row)

-- Test setting same access method again
alter table :chunk set access method hyperstore;
-- Create a second chunk
insert into test3 values ('2022-08-01', 1, 1.0);
-- The second chunk should not be a hyperstore chunk
select * from amrels where relparent='test3'::regclass;
                   rel                   |   amname   | relparent 
-----------------------------------------+------------+-----------
 _timescaledb_internal._hyper_4_13_chunk | hyperstore | test3
 _timescaledb_internal._hyper_4_15_chunk | heap       | test3
(2 rows)

-- Set hyperstore on hypertable
alter table test3 set access method hyperstore;
-- Create a third chunk
insert into test3 values ('2022-10-01', 1, 1.0);
-- The third chunk should be a hyperstore chunk
select * from amrels where relparent='test3'::regclass;
                   rel                   |   amname   | relparent 
-----------------------------------------+------------+-----------
 _timescaledb_internal._hyper_4_13_chunk | hyperstore | test3
 _timescaledb_internal._hyper_4_15_chunk | heap       | test3
 _timescaledb_internal._hyper_4_16_chunk | hyperstore | test3
(3 rows)

-- Create view to see compression stats. Left join chunks with stats
-- to detect missing stats. Only show row counts because size stats
-- seem to vary in tests
create view compressed_rel_size_stats as
select
	cl.oid::regclass as rel,
	am.amname,
	inh.inhparent::regclass as relparent,
	numrows_pre_compression,
	numrows_post_compression,
	numrows_frozen_immediately
from  _timescaledb_catalog.chunk c
left join _timescaledb_catalog.compression_chunk_size ccs
	  on (c.id = ccs.chunk_id)
inner join pg_class cl
	  on (cl.oid = format('%I.%I', c.schema_name, c.table_name)::regclass)
inner join pg_am am
	  on (am.oid = cl.relam)
inner join pg_inherits inh
	  on (inh.inhrelid = cl.oid)
where c.compressed_chunk_id is not null;
-- There should be no hyperstore chunks that lack compression size stats
select count(*) as num_stats_missing from compressed_rel_size_stats
where amname = 'hyperstore' and numrows_pre_compression is null;
 num_stats_missing 
-------------------
                 0
(1 row)

-- Show stats for hyperstore chunks. Note that many stats are 0 since
-- chunks were created as a result of inserts and not really
-- compressed
select * from compressed_rel_size_stats order by rel;
                   rel                   |   amname   | relparent | numrows_pre_compression | numrows_post_compression | numrows_frozen_immediately 
-----------------------------------------+------------+-----------+-------------------------+--------------------------+----------------------------
 _timescaledb_internal._hyper_1_1_chunk  | hyperstore | test2     |                       0 |                        0 |                          0
 _timescaledb_internal._hyper_1_3_chunk  | hyperstore | test2     |                       0 |                        0 |                          0
 _timescaledb_internal._hyper_1_5_chunk  | hyperstore | test2     |                       0 |                        0 |                          0
 _timescaledb_internal._hyper_1_7_chunk  | hyperstore | test2     |                       0 |                        0 |                          0
 _timescaledb_internal._hyper_1_9_chunk  | hyperstore | test2     |                       0 |                        0 |                          0
 _timescaledb_internal._hyper_1_11_chunk | hyperstore | test2     |                       0 |                        0 |                          0
 _timescaledb_internal._hyper_4_13_chunk | hyperstore | test3     |                       1 |                        1 |                          1
 _timescaledb_internal._hyper_4_16_chunk | hyperstore | test3     |                       0 |                        0 |                          0
(8 rows)

-- Decompress hyperstores to check that stats are removed
select untwist_chunk(rel)
  from compressed_rel_size_stats
  where amname = 'hyperstore';
              untwist_chunk              
-----------------------------------------
 _timescaledb_internal._hyper_1_1_chunk
 _timescaledb_internal._hyper_1_3_chunk
 _timescaledb_internal._hyper_1_5_chunk
 _timescaledb_internal._hyper_1_7_chunk
 _timescaledb_internal._hyper_1_9_chunk
 _timescaledb_internal._hyper_1_11_chunk
 _timescaledb_internal._hyper_4_13_chunk
 _timescaledb_internal._hyper_4_16_chunk
(8 rows)

-- All stats should be removed
select count(*) as orphaned_stats
from compressed_rel_size_stats;
 orphaned_stats 
----------------
              0
(1 row)

-- Create hyperstores again and check that compression size stats are
-- updated showing compressed data
select twist_chunk(ch)
from show_chunks('test2') ch;
               twist_chunk               
-----------------------------------------
 _timescaledb_internal._hyper_1_1_chunk
 _timescaledb_internal._hyper_1_3_chunk
 _timescaledb_internal._hyper_1_5_chunk
 _timescaledb_internal._hyper_1_7_chunk
 _timescaledb_internal._hyper_1_9_chunk
 _timescaledb_internal._hyper_1_11_chunk
(6 rows)

select twist_chunk(ch)
from show_chunks('test3') ch;
               twist_chunk               
-----------------------------------------
 _timescaledb_internal._hyper_4_13_chunk
 _timescaledb_internal._hyper_4_15_chunk
 _timescaledb_internal._hyper_4_16_chunk
(3 rows)

-- Save the stats for later comparison. Exclude the amname column
-- since it will differ.
create table saved_stats as
select
	rel,
	relparent,
	numrows_pre_compression,
	numrows_post_compression,
	numrows_frozen_immediately
from compressed_rel_size_stats;
select * from compressed_rel_size_stats order by rel;
                   rel                   |   amname   | relparent | numrows_pre_compression | numrows_post_compression | numrows_frozen_immediately 
-----------------------------------------+------------+-----------+-------------------------+--------------------------+----------------------------
 _timescaledb_internal._hyper_1_1_chunk  | hyperstore | test2     |                   12240 |                       20 |                         20
 _timescaledb_internal._hyper_1_3_chunk  | hyperstore | test2     |                  120960 |                      128 |                        128
 _timescaledb_internal._hyper_1_5_chunk  | hyperstore | test2     |                  120960 |                      127 |                        127
 _timescaledb_internal._hyper_1_7_chunk  | hyperstore | test2     |                  120960 |                      129 |                        129
 _timescaledb_internal._hyper_1_9_chunk  | hyperstore | test2     |                  120960 |                      127 |                        127
 _timescaledb_internal._hyper_1_11_chunk | hyperstore | test2     |                   22321 |                       30 |                         30
 _timescaledb_internal._hyper_4_13_chunk | hyperstore | test3     |                       1 |                        1 |                          1
 _timescaledb_internal._hyper_4_15_chunk | hyperstore | test3     |                       1 |                        1 |                          1
 _timescaledb_internal._hyper_4_16_chunk | hyperstore | test3     |                       1 |                        1 |                          1
(9 rows)

-- Convert back to heap and compress the old way to compare
-- compression size stats
select compress_chunk(untwist_chunk(ch))
from show_chunks('test2') ch;
             compress_chunk              
-----------------------------------------
 _timescaledb_internal._hyper_1_1_chunk
 _timescaledb_internal._hyper_1_3_chunk
 _timescaledb_internal._hyper_1_5_chunk
 _timescaledb_internal._hyper_1_7_chunk
 _timescaledb_internal._hyper_1_9_chunk
 _timescaledb_internal._hyper_1_11_chunk
(6 rows)

select compress_chunk(untwist_chunk(ch))
from show_chunks('test3') ch;
             compress_chunk              
-----------------------------------------
 _timescaledb_internal._hyper_4_13_chunk
 _timescaledb_internal._hyper_4_15_chunk
 _timescaledb_internal._hyper_4_16_chunk
(3 rows)

select * from compressed_rel_size_stats order by rel;
                   rel                   | amname | relparent | numrows_pre_compression | numrows_post_compression | numrows_frozen_immediately 
-----------------------------------------+--------+-----------+-------------------------+--------------------------+----------------------------
 _timescaledb_internal._hyper_1_1_chunk  | heap   | test2     |                   12240 |                       20 |                         20
 _timescaledb_internal._hyper_1_3_chunk  | heap   | test2     |                  120960 |                      128 |                        128
 _timescaledb_internal._hyper_1_5_chunk  | heap   | test2     |                  120960 |                      127 |                        127
 _timescaledb_internal._hyper_1_7_chunk  | heap   | test2     |                  120960 |                      129 |                        129
 _timescaledb_internal._hyper_1_9_chunk  | heap   | test2     |                  120960 |                      127 |                        127
 _timescaledb_internal._hyper_1_11_chunk | heap   | test2     |                   22321 |                       30 |                         30
 _timescaledb_internal._hyper_4_13_chunk | heap   | test3     |                       1 |                        1 |                          1
 _timescaledb_internal._hyper_4_15_chunk | heap   | test3     |                       1 |                        1 |                          1
 _timescaledb_internal._hyper_4_16_chunk | heap   | test3     |                       1 |                        1 |                          1
(9 rows)

-- Check that stats are the same for hyperstore and now with
-- compression. Should return zero rows if they are the same.
select
	rel,
	relparent,
	numrows_pre_compression,
	numrows_post_compression,
	numrows_frozen_immediately
from compressed_rel_size_stats
except
select * from saved_stats;
 rel | relparent | numrows_pre_compression | numrows_post_compression | numrows_frozen_immediately 
-----+-----------+-------------------------+--------------------------+----------------------------
(0 rows)

