-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
\c :TEST_DBNAME :ROLE_SUPERUSER
CREATE VIEW settings AS SELECT * FROM _timescaledb_catalog.compression_settings ORDER BY upper(relid::text) COLLATE "C";
CREATE VIEW metacols AS select relname,attname,count(*) from pg_attribute a, pg_class c where c.oid=a.attrelid and attname like '%_ts_meta%' and relname like '%chunk' GROUP BY 1,2 ORDER BY relname::text COLLATE "C", attname::text COLLATE "C";
CREATE VIEW compressedcols AS select relname,attname,c.oid as reloid,attnum from pg_attribute a, pg_class c where c.oid=a.attrelid and relname like '%compress_hyper_%' order by c.oid asc, a.attnum asc;
create table sparse(
    ts int,
    o bigint,
    value float,
    boo bigint,
    big1 bigint,
    big2 bigint,
    sby bigint,
    small1 smallint,
    small2 int2,
    num numeric,
    nowts timestamptz,
    hello bytea);
select create_hypertable('sparse', 'ts', create_default_indexes=>false);
  create_hypertable  
---------------------
 (1,public,sparse,t)

insert into sparse select x, x, x, x, x, x, x, x%4, x%4, x::numeric, now()::timestamptz, md5(x::text)::bytea from generate_series(1, 10000) x;
alter table sparse set (
    timescaledb.compress,
    timescaledb.order_by='o',
    timescaledb.segment_by='sby',
    timescaledb.compress_index = 'bloom(big1),bloom(big2),bloom(value),bloom(value,big1,big2),bloom(o,big2),bloom(big1,big2),bloom(boo,big1),bloom(small1,small2),bloom(num,nowts),bloom(num,hello)');
select count(compress_chunk(x)) from show_chunks('sparse') x;
 count 
-------
     1

vacuum analyze sparse;
-- smoke tests
select min(big1), max(big2) from sparse where value < 100 and value > 10;
 min | max 
-----+-----
  11 |  99

select relname,attname from metacols order by 1,2;
         relname          |              attname               
--------------------------+------------------------------------
 compress_hyper_2_2_chunk | _ts_meta_count
 compress_hyper_2_2_chunk | _ts_meta_max_1
 compress_hyper_2_2_chunk | _ts_meta_max_2
 compress_hyper_2_2_chunk | _ts_meta_min_1
 compress_hyper_2_2_chunk | _ts_meta_min_2
 compress_hyper_2_2_chunk | regress-test-bloom_big1
 compress_hyper_2_2_chunk | regress-test-bloom_big1_big2
 compress_hyper_2_2_chunk | regress-test-bloom_big2
 compress_hyper_2_2_chunk | regress-test-bloom_boo_big1
 compress_hyper_2_2_chunk | regress-test-bloom_num_hello
 compress_hyper_2_2_chunk | regress-test-bloom_num_nowts
 compress_hyper_2_2_chunk | regress-test-bloom_o_big2
 compress_hyper_2_2_chunk | regress-test-bloom_small1_small2
 compress_hyper_2_2_chunk | regress-test-bloom_value
 compress_hyper_2_2_chunk | regress-test-bloom_value_big1_big2

select index from settings where relid = (select oid from pg_class where relname = 'sparse') and index is not null group by 1 order by 1;
                                                                                                                                                                                                                                                                                                                                                                                            index                                                                                                                                                                                                                                                                                                                                                                                            
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 [{"type": "bloom", "column": "big1", "source": "config"}, {"type": "bloom", "column": "big2", "source": "config"}, {"type": "bloom", "column": "value", "source": "config"}, {"type": "bloom", "column": ["value", "big1", "big2"], "source": "config"}, {"type": "bloom", "column": ["o", "big2"], "source": "config"}, {"type": "bloom", "column": ["big1", "big2"], "source": "config"}, {"type": "bloom", "column": ["boo", "big1"], "source": "config"}, {"type": "bloom", "column": ["small1", "small2"], "source": "config"}, {"type": "bloom", "column": ["num", "nowts"], "source": "config"}, {"type": "bloom", "column": ["num", "hello"], "source": "config"}, {"type": "minmax", "column": "o", "source": "orderby"}, {"type": "minmax", "column": "ts", "source": "orderby"}]

select distinct(attname) from compressedcols where relname = 'sparse' order by 1 asc;
 attname 
---------

-- show plan
explain (buffers off, costs off) select * from sparse where value = 1;
--- QUERY PLAN ---
 Custom Scan (ColumnarScan) on _hyper_1_1_chunk
   Vectorized Filter: (value = '1'::double precision)
   ->  Seq Scan on compress_hyper_2_2_chunk
         Filter: _timescaledb_functions.bloom1_contains(regress-test-bloom_value, '1'::double precision)

explain (buffers off, costs off) select * from sparse where o = 1 and big2 = 1;
--- QUERY PLAN ---
 Custom Scan (ColumnarScan) on _hyper_1_1_chunk
   Vectorized Filter: ((o = 1) AND (big2 = 1))
   ->  Index Scan using compress_hyper_2_2_chunk_sby__ts_meta_min_1__ts_meta_max_1__idx on compress_hyper_2_2_chunk
         Index Cond: ((_ts_meta_min_1 <= 1) AND (_ts_meta_max_1 >= 1))
         Filter: (_timescaledb_functions.bloom1_contains(regress-test-bloom_big2, 1) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_o_big2, ROW(1, 1)))

explain (buffers off, costs off) select * from sparse where num = 1 and hello = md5('1')::bytea;
--- QUERY PLAN ---
 Custom Scan (ColumnarScan) on _hyper_1_1_chunk
   Filter: ((num = '1'::numeric) AND (hello = '\x6334636134323338613062393233383230646363353039613666373538343962'::bytea))
   ->  Seq Scan on compress_hyper_2_2_chunk
         Filter: _timescaledb_functions.bloom1_contains(regress-test-bloom_num_hello, ROW('1'::numeric, '\x6334636134323338613062393233383230646363353039613666373538343962'::bytea))

explain (buffers off, costs off) select * from sparse where small1 = 1 and small2 = 1;
--- QUERY PLAN ---
 Custom Scan (ColumnarScan) on _hyper_1_1_chunk
   Vectorized Filter: ((small1 = 1) AND (small2 = 1))
   ->  Seq Scan on compress_hyper_2_2_chunk
         Filter: _timescaledb_functions.bloom1_contains(regress-test-bloom_small1_small2, ROW(1, 1))

explain (buffers off, costs off) select * from sparse where num = 1 and nowts = now()::timestamptz;
--- QUERY PLAN ---
 Custom Scan (ChunkAppend) on sparse
   Chunks excluded during startup: 0
   ->  Custom Scan (ColumnarScan) on _hyper_1_1_chunk
         Filter: (num = '1'::numeric)
         Vectorized Filter: (nowts = now())
         ->  Seq Scan on compress_hyper_2_2_chunk
               Filter: _timescaledb_functions.bloom1_contains(regress-test-bloom_num_nowts, ROW('1'::numeric, now()))

explain (buffers off, costs off) select * from sparse where o in (1,2) and big2 = 1;
--- QUERY PLAN ---
 Custom Scan (ColumnarScan) on _hyper_1_1_chunk
   Vectorized Filter: ((o = ANY ('{1,2}'::bigint[])) AND (big2 = 1))
   ->  Seq Scan on compress_hyper_2_2_chunk
         Filter: _timescaledb_functions.bloom1_contains(regress-test-bloom_big2, 1)

explain (buffers off, costs off) select * from sparse where o = 1 and big2 in (1,2);
--- QUERY PLAN ---
 Custom Scan (ColumnarScan) on _hyper_1_1_chunk
   Vectorized Filter: ((big2 = ANY ('{1,2}'::bigint[])) AND (o = 1))
   ->  Index Scan using compress_hyper_2_2_chunk_sby__ts_meta_min_1__ts_meta_max_1__idx on compress_hyper_2_2_chunk
         Index Cond: ((_ts_meta_min_1 <= 1) AND (_ts_meta_max_1 >= 1))
         Filter: _timescaledb_functions.bloom1_contains_any(regress-test-bloom_big2, '{1,2}'::bigint[])

explain (buffers off, costs off) select * from sparse where o in (1,2) and big2 in (1,2);
--- QUERY PLAN ---
 Custom Scan (ColumnarScan) on _hyper_1_1_chunk
   Vectorized Filter: ((o = ANY ('{1,2}'::bigint[])) AND (big2 = ANY ('{1,2}'::bigint[])))
   ->  Seq Scan on compress_hyper_2_2_chunk
         Filter: _timescaledb_functions.bloom1_contains_any(regress-test-bloom_big2, '{1,2}'::bigint[])

-- segmentby = bloom
explain (buffers off, costs off) select * from sparse where big1 = sby and value = 1;
--- QUERY PLAN ---
 Custom Scan (ColumnarScan) on _hyper_1_1_chunk
   Filter: (big1 = sby)
   Vectorized Filter: (value = '1'::double precision)
   ->  Seq Scan on compress_hyper_2_2_chunk
         Filter: (_timescaledb_functions.bloom1_contains(regress-test-bloom_big1, sby) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_value, '1'::double precision))

explain (buffers off, costs off) select * from sparse where o = sby and big2 = sby;
--- QUERY PLAN ---
 Custom Scan (ColumnarScan) on _hyper_1_1_chunk
   Filter: ((o = sby) AND (sby = big2))
   ->  Seq Scan on compress_hyper_2_2_chunk
         Filter: ((_ts_meta_min_1 <= sby) AND (_ts_meta_max_1 >= sby) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_big2, sby) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_o_big2, ROW(sby, sby)))

explain (buffers off, costs off) select * from sparse where o = 1 and big2 = sby;
--- QUERY PLAN ---
 Custom Scan (ColumnarScan) on _hyper_1_1_chunk
   Filter: (big2 = sby)
   Vectorized Filter: (o = 1)
   ->  Index Scan using compress_hyper_2_2_chunk_sby__ts_meta_min_1__ts_meta_max_1__idx on compress_hyper_2_2_chunk
         Index Cond: ((_ts_meta_min_1 <= 1) AND (_ts_meta_max_1 >= 1))
         Filter: (_timescaledb_functions.bloom1_contains(regress-test-bloom_big2, sby) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_o_big2, ROW(1, sby)))

explain (buffers off, costs off) select * from sparse where o = sby and big2 = 1;
--- QUERY PLAN ---
 Custom Scan (ColumnarScan) on _hyper_1_1_chunk
   Filter: (o = sby)
   Vectorized Filter: (big2 = 1)
   ->  Seq Scan on compress_hyper_2_2_chunk
         Filter: ((_ts_meta_min_1 <= sby) AND (_ts_meta_max_1 >= sby) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_big2, 1) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_o_big2, ROW(sby, 1)))

-- create a sister table where the same composite blooms should be auto created
create table sparse_sister as select * from sparse where ts < -1;
select create_hypertable('sparse_sister', 'ts', create_default_indexes=>false);
     create_hypertable      
----------------------------
 (3,public,sparse_sister,t)

alter table sparse_sister set (
    timescaledb.compress,
    timescaledb.order_by='o',
    timescaledb.segment_by='sby');
insert into sparse_sister select * from sparse;
create index on sparse_sister(value,big1,big2);
create index on sparse_sister(o,big2);
create index on sparse_sister(big1,big2);
create index on sparse_sister(boo,big1);
create index on sparse_sister(small1,small2);
create index on sparse_sister(num,nowts);
create index on sparse_sister(num,hello);
select count(compress_chunk(x)) from show_chunks('sparse_sister') x;
 count 
-------
     1

vacuum analyze sparse_sister;
-- smoke tests
select min(big1), max(big2) from sparse_sister where value < 100 and value > 10;
 min | max 
-----+-----
  11 |  99

select relname,attname from metacols order by 1,2;
         relname          |              attname               
--------------------------+------------------------------------
 compress_hyper_2_2_chunk | _ts_meta_count
 compress_hyper_2_2_chunk | _ts_meta_max_1
 compress_hyper_2_2_chunk | _ts_meta_max_2
 compress_hyper_2_2_chunk | _ts_meta_min_1
 compress_hyper_2_2_chunk | _ts_meta_min_2
 compress_hyper_2_2_chunk | regress-test-bloom_big1
 compress_hyper_2_2_chunk | regress-test-bloom_big1_big2
 compress_hyper_2_2_chunk | regress-test-bloom_big2
 compress_hyper_2_2_chunk | regress-test-bloom_boo_big1
 compress_hyper_2_2_chunk | regress-test-bloom_num_hello
 compress_hyper_2_2_chunk | regress-test-bloom_num_nowts
 compress_hyper_2_2_chunk | regress-test-bloom_o_big2
 compress_hyper_2_2_chunk | regress-test-bloom_small1_small2
 compress_hyper_2_2_chunk | regress-test-bloom_value
 compress_hyper_2_2_chunk | regress-test-bloom_value_big1_big2
 compress_hyper_4_4_chunk | _ts_meta_count
 compress_hyper_4_4_chunk | _ts_meta_max_1
 compress_hyper_4_4_chunk | _ts_meta_max_2
 compress_hyper_4_4_chunk | _ts_meta_min_1
 compress_hyper_4_4_chunk | _ts_meta_min_2
 compress_hyper_4_4_chunk | regress-test-bloom_big1
 compress_hyper_4_4_chunk | regress-test-bloom_big1_big2
 compress_hyper_4_4_chunk | regress-test-bloom_big2
 compress_hyper_4_4_chunk | regress-test-bloom_boo
 compress_hyper_4_4_chunk | regress-test-bloom_boo_big1
 compress_hyper_4_4_chunk | regress-test-bloom_hello
 compress_hyper_4_4_chunk | regress-test-bloom_num_hello
 compress_hyper_4_4_chunk | regress-test-bloom_num_nowts
 compress_hyper_4_4_chunk | regress-test-bloom_o_big2
 compress_hyper_4_4_chunk | regress-test-bloom_small1_small2
 compress_hyper_4_4_chunk | _ts_meta_v2_max_nowts
 compress_hyper_4_4_chunk | _ts_meta_v2_max_num
 compress_hyper_4_4_chunk | _ts_meta_v2_max_small1
 compress_hyper_4_4_chunk | _ts_meta_v2_max_small2
 compress_hyper_4_4_chunk | _ts_meta_v2_max_value
 compress_hyper_4_4_chunk | _ts_meta_v2_min_nowts
 compress_hyper_4_4_chunk | _ts_meta_v2_min_num
 compress_hyper_4_4_chunk | _ts_meta_v2_min_small1
 compress_hyper_4_4_chunk | _ts_meta_v2_min_small2
 compress_hyper_4_4_chunk | _ts_meta_v2_min_value

select index from settings where relid = (select oid from pg_class where relname = 'sparse_sister') and index is not null group by 1 order by 1;
 index 
-------

select distinct(attname) from compressedcols where relname = 'sparse_sister' order by 1 asc;
 attname 
---------

-- show plan
explain (buffers off, costs off) select * from sparse_sister where value = 1;
--- QUERY PLAN ---
 Custom Scan (ColumnarScan) on _hyper_3_3_chunk
   Vectorized Filter: (value = '1'::double precision)
   ->  Seq Scan on compress_hyper_4_4_chunk
         Filter: ((_ts_meta_v2_min_value <= '1'::double precision) AND (_ts_meta_v2_max_value >= '1'::double precision))

explain (buffers off, costs off) select * from sparse_sister where o = 1 and big2 = 1;
--- QUERY PLAN ---
 Custom Scan (ColumnarScan) on _hyper_3_3_chunk
   Vectorized Filter: ((o = 1) AND (big2 = 1))
   ->  Index Scan using compress_hyper_4_4_chunk_sby__ts_meta_min_1__ts_meta_max_1__idx on compress_hyper_4_4_chunk
         Index Cond: ((_ts_meta_min_1 <= 1) AND (_ts_meta_max_1 >= 1))
         Filter: (_timescaledb_functions.bloom1_contains(regress-test-bloom_big2, 1) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_o_big2, ROW(1, 1)))

explain (buffers off, costs off) select * from sparse_sister where num = 1 and hello = md5('1')::bytea;
--- QUERY PLAN ---
 Custom Scan (ColumnarScan) on _hyper_3_3_chunk
   Filter: ((num = '1'::numeric) AND (hello = '\x6334636134323338613062393233383230646363353039613666373538343962'::bytea))
   ->  Seq Scan on compress_hyper_4_4_chunk
         Filter: ((_ts_meta_v2_min_num <= '1'::numeric) AND (_ts_meta_v2_max_num >= '1'::numeric) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_hello, '\x6334636134323338613062393233383230646363353039613666373538343962'::bytea) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_num_hello, ROW('1'::numeric, '\x6334636134323338613062393233383230646363353039613666373538343962'::bytea)))

explain (buffers off, costs off) select * from sparse_sister where small1 = 1 and small2 = 1;
--- QUERY PLAN ---
 Custom Scan (ColumnarScan) on _hyper_3_3_chunk
   Vectorized Filter: ((small1 = 1) AND (small2 = 1))
   ->  Seq Scan on compress_hyper_4_4_chunk
         Filter: ((_ts_meta_v2_min_small1 <= 1) AND (_ts_meta_v2_max_small1 >= 1) AND (_ts_meta_v2_min_small2 <= 1) AND (_ts_meta_v2_max_small2 >= 1) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_small1_small2, ROW(1, 1)))

explain (buffers off, costs off) select * from sparse_sister where num = 1 and nowts = now()::timestamptz;
--- QUERY PLAN ---
 Custom Scan (ChunkAppend) on sparse_sister
   Chunks excluded during startup: 0
   ->  Custom Scan (ColumnarScan) on _hyper_3_3_chunk
         Filter: (num = '1'::numeric)
         Vectorized Filter: (nowts = now())
         ->  Seq Scan on compress_hyper_4_4_chunk
               Filter: ((_ts_meta_v2_min_num <= '1'::numeric) AND (_ts_meta_v2_max_num >= '1'::numeric) AND (_ts_meta_v2_min_nowts <= now()) AND (_ts_meta_v2_max_nowts >= now()) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_num_nowts, ROW('1'::numeric, now())))

-- segmentby = bloom
explain (buffers off, costs off) select * from sparse_sister where big1 = sby and value = 1;
--- QUERY PLAN ---
 Custom Scan (ColumnarScan) on _hyper_3_3_chunk
   Filter: (big1 = sby)
   Vectorized Filter: (value = '1'::double precision)
   ->  Seq Scan on compress_hyper_4_4_chunk
         Filter: (_timescaledb_functions.bloom1_contains(regress-test-bloom_big1, sby) AND (_ts_meta_v2_min_value <= '1'::double precision) AND (_ts_meta_v2_max_value >= '1'::double precision))

explain (buffers off, costs off) select * from sparse_sister where o = sby and big2 = sby;
--- QUERY PLAN ---
 Custom Scan (ColumnarScan) on _hyper_3_3_chunk
   Filter: ((o = sby) AND (sby = big2))
   ->  Seq Scan on compress_hyper_4_4_chunk
         Filter: ((_ts_meta_min_1 <= sby) AND (_ts_meta_max_1 >= sby) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_big2, sby) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_o_big2, ROW(sby, sby)))

explain (buffers off, costs off) select * from sparse_sister where o = 1 and big2 = sby;
--- QUERY PLAN ---
 Custom Scan (ColumnarScan) on _hyper_3_3_chunk
   Filter: (big2 = sby)
   Vectorized Filter: (o = 1)
   ->  Index Scan using compress_hyper_4_4_chunk_sby__ts_meta_min_1__ts_meta_max_1__idx on compress_hyper_4_4_chunk
         Index Cond: ((_ts_meta_min_1 <= 1) AND (_ts_meta_max_1 >= 1))
         Filter: (_timescaledb_functions.bloom1_contains(regress-test-bloom_big2, sby) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_o_big2, ROW(1, sby)))

explain (buffers off, costs off) select * from sparse_sister where o = sby and big2 = 1;
--- QUERY PLAN ---
 Custom Scan (ColumnarScan) on _hyper_3_3_chunk
   Filter: (o = sby)
   Vectorized Filter: (big2 = 1)
   ->  Seq Scan on compress_hyper_4_4_chunk
         Filter: ((_ts_meta_min_1 <= sby) AND (_ts_meta_max_1 >= sby) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_big2, 1) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_o_big2, ROW(sby, 1)))

-- renaming a column that participates in a composite bloom filter
alter table sparse rename big2 to xxl;
select relname,attname from metacols order by 1,2;
         relname          |              attname              
--------------------------+-----------------------------------
 compress_hyper_2_2_chunk | _ts_meta_count
 compress_hyper_2_2_chunk | _ts_meta_max_1
 compress_hyper_2_2_chunk | _ts_meta_max_2
 compress_hyper_2_2_chunk | _ts_meta_min_1
 compress_hyper_2_2_chunk | _ts_meta_min_2
 compress_hyper_2_2_chunk | regress-test-bloom_big1
 compress_hyper_2_2_chunk | regress-test-bloom_big1_xxl
 compress_hyper_2_2_chunk | regress-test-bloom_boo_big1
 compress_hyper_2_2_chunk | regress-test-bloom_num_hello
 compress_hyper_2_2_chunk | regress-test-bloom_num_nowts
 compress_hyper_2_2_chunk | regress-test-bloom_o_xxl
 compress_hyper_2_2_chunk | regress-test-bloom_small1_small2
 compress_hyper_2_2_chunk | regress-test-bloom_value
 compress_hyper_2_2_chunk | regress-test-bloom_value_big1_xxl
 compress_hyper_2_2_chunk | regress-test-bloom_xxl
 compress_hyper_4_4_chunk | _ts_meta_count
 compress_hyper_4_4_chunk | _ts_meta_max_1
 compress_hyper_4_4_chunk | _ts_meta_max_2
 compress_hyper_4_4_chunk | _ts_meta_min_1
 compress_hyper_4_4_chunk | _ts_meta_min_2
 compress_hyper_4_4_chunk | regress-test-bloom_big1
 compress_hyper_4_4_chunk | regress-test-bloom_big1_big2
 compress_hyper_4_4_chunk | regress-test-bloom_big2
 compress_hyper_4_4_chunk | regress-test-bloom_boo
 compress_hyper_4_4_chunk | regress-test-bloom_boo_big1
 compress_hyper_4_4_chunk | regress-test-bloom_hello
 compress_hyper_4_4_chunk | regress-test-bloom_num_hello
 compress_hyper_4_4_chunk | regress-test-bloom_num_nowts
 compress_hyper_4_4_chunk | regress-test-bloom_o_big2
 compress_hyper_4_4_chunk | regress-test-bloom_small1_small2
 compress_hyper_4_4_chunk | _ts_meta_v2_max_nowts
 compress_hyper_4_4_chunk | _ts_meta_v2_max_num
 compress_hyper_4_4_chunk | _ts_meta_v2_max_small1
 compress_hyper_4_4_chunk | _ts_meta_v2_max_small2
 compress_hyper_4_4_chunk | _ts_meta_v2_max_value
 compress_hyper_4_4_chunk | _ts_meta_v2_min_nowts
 compress_hyper_4_4_chunk | _ts_meta_v2_min_num
 compress_hyper_4_4_chunk | _ts_meta_v2_min_small1
 compress_hyper_4_4_chunk | _ts_meta_v2_min_small2
 compress_hyper_4_4_chunk | _ts_meta_v2_min_value

select index from settings where relid = (select oid from pg_class where relname = 'sparse') and index is not null group by 1 order by 1;
                                                                                                                                                                                                                                                                                                                                                                                          index                                                                                                                                                                                                                                                                                                                                                                                          
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 [{"type": "bloom", "column": "big1", "source": "config"}, {"type": "bloom", "column": "xxl", "source": "config"}, {"type": "bloom", "column": "value", "source": "config"}, {"type": "bloom", "column": ["value", "big1", "xxl"], "source": "config"}, {"type": "bloom", "column": ["o", "xxl"], "source": "config"}, {"type": "bloom", "column": ["big1", "xxl"], "source": "config"}, {"type": "bloom", "column": ["boo", "big1"], "source": "config"}, {"type": "bloom", "column": ["small1", "small2"], "source": "config"}, {"type": "bloom", "column": ["num", "nowts"], "source": "config"}, {"type": "bloom", "column": ["num", "hello"], "source": "config"}, {"type": "minmax", "column": "o", "source": "orderby"}, {"type": "minmax", "column": "ts", "source": "orderby"}]

select distinct(attname) from compressedcols where relname = 'sparse' order by 1 asc;
 attname 
---------

-- dropping a column that participates in a composite bloom filter
alter table sparse drop column xxl;
select relname,attname from metacols order by 1,2;
         relname          |             attname              
--------------------------+----------------------------------
 compress_hyper_2_2_chunk | _ts_meta_count
 compress_hyper_2_2_chunk | _ts_meta_max_1
 compress_hyper_2_2_chunk | _ts_meta_max_2
 compress_hyper_2_2_chunk | _ts_meta_min_1
 compress_hyper_2_2_chunk | _ts_meta_min_2
 compress_hyper_2_2_chunk | regress-test-bloom_big1
 compress_hyper_2_2_chunk | regress-test-bloom_boo_big1
 compress_hyper_2_2_chunk | regress-test-bloom_num_hello
 compress_hyper_2_2_chunk | regress-test-bloom_num_nowts
 compress_hyper_2_2_chunk | regress-test-bloom_small1_small2
 compress_hyper_2_2_chunk | regress-test-bloom_value
 compress_hyper_4_4_chunk | _ts_meta_count
 compress_hyper_4_4_chunk | _ts_meta_max_1
 compress_hyper_4_4_chunk | _ts_meta_max_2
 compress_hyper_4_4_chunk | _ts_meta_min_1
 compress_hyper_4_4_chunk | _ts_meta_min_2
 compress_hyper_4_4_chunk | regress-test-bloom_big1
 compress_hyper_4_4_chunk | regress-test-bloom_big1_big2
 compress_hyper_4_4_chunk | regress-test-bloom_big2
 compress_hyper_4_4_chunk | regress-test-bloom_boo
 compress_hyper_4_4_chunk | regress-test-bloom_boo_big1
 compress_hyper_4_4_chunk | regress-test-bloom_hello
 compress_hyper_4_4_chunk | regress-test-bloom_num_hello
 compress_hyper_4_4_chunk | regress-test-bloom_num_nowts
 compress_hyper_4_4_chunk | regress-test-bloom_o_big2
 compress_hyper_4_4_chunk | regress-test-bloom_small1_small2
 compress_hyper_4_4_chunk | _ts_meta_v2_max_nowts
 compress_hyper_4_4_chunk | _ts_meta_v2_max_num
 compress_hyper_4_4_chunk | _ts_meta_v2_max_small1
 compress_hyper_4_4_chunk | _ts_meta_v2_max_small2
 compress_hyper_4_4_chunk | _ts_meta_v2_max_value
 compress_hyper_4_4_chunk | _ts_meta_v2_min_nowts
 compress_hyper_4_4_chunk | _ts_meta_v2_min_num
 compress_hyper_4_4_chunk | _ts_meta_v2_min_small1
 compress_hyper_4_4_chunk | _ts_meta_v2_min_small2
 compress_hyper_4_4_chunk | _ts_meta_v2_min_value

select index from settings where relid = (select oid from pg_class where relname = 'sparse') and index is not null group by 1 order by 1;
                                                                                                                                                                                                                                                        index                                                                                                                                                                                                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 [{"type": "bloom", "column": "big1", "source": "config"}, {"type": "bloom", "column": "value", "source": "config"}, {"type": "bloom", "column": ["boo", "big1"], "source": "config"}, {"type": "bloom", "column": ["small1", "small2"], "source": "config"}, {"type": "bloom", "column": ["num", "nowts"], "source": "config"}, {"type": "bloom", "column": ["num", "hello"], "source": "config"}, {"type": "minmax", "column": "o", "source": "orderby"}, {"type": "minmax", "column": "ts", "source": "orderby"}]

select distinct(attname) from compressedcols where relname = 'sparse' order by 1 asc;
 attname 
---------

-- droppping an orderby column should fail
\set ON_ERROR_STOP 0
alter table sparse drop column o;
ERROR:  cannot drop orderby or segmentby column from a hypertable with columnstore enabled
-- a segmentby column cannot be part of composite key
alter table sparse set (
    timescaledb.compress,
    timescaledb.order_by='o',
    timescaledb.segment_by='sby',
    timescaledb.compress_index = 'bloom(big1),bloom(value),bloom(boo,big1),bloom(sby,value)');
ERROR:  the segmentby column "sby" can not have sparse indexes
-- a segmentby column cannot be part of single col bloom filter
alter table sparse set (
    timescaledb.compress,
    timescaledb.order_by='o',
    timescaledb.segment_by='sby',
    timescaledb.compress_index = 'bloom(big1),bloom(value),bloom(boo,big1),bloom(sby)');
ERROR:  the segmentby column "sby" can not have sparse indexes
-- an orderby column cannot be part of a single col bloom filter
alter table sparse set (
    timescaledb.compress,
    timescaledb.order_by='o',
    timescaledb.segment_by='sby',
    timescaledb.compress_index = 'bloom(big1),bloom(value),bloom(boo,big1),bloom(o)');
ERROR:  the orderby column "o" cannot have a bloom sparse index 
-- an orderby column cannot be part of a single col bloom filter
alter table sparse set (
    timescaledb.compress,
    timescaledb.order_by='o',
    timescaledb.segment_by='sby',
    timescaledb.compress_index = 'bloom(big1),bloom(value),bloom(boo,big1),bloom(boo,o),bloom(o)');
ERROR:  the orderby column "o" cannot have a bloom sparse index 
-- an orderby column cannot be part of a single col bloom filter
alter table sparse set (
    timescaledb.compress,
    timescaledb.order_by='o',
    timescaledb.segment_by='sby',
    timescaledb.compress_index = 'bloom(big1),bloom(value),bloom(boo,big1),bloom(o),bloom(o,boo)');
ERROR:  the orderby column "o" cannot have a bloom sparse index 
\set ON_ERROR_STOP 1
-- an orderby column _can_ be part of a composite bloom filter
alter table sparse set (
    timescaledb.compress,
    timescaledb.order_by='o',
    timescaledb.segment_by='sby',
    timescaledb.compress_index = 'bloom(big1),bloom(value),bloom(boo,big1),bloom(o,boo)');
DROP TABLE IF EXISTS sparse CASCADE;
DROP TABLE IF EXISTS sparse_sister CASCADE;
---------------------------------------------------------------------
-- Some chunks don't have a composite bloom index after index change
---------------------------------------------------------------------
CREATE TABLE mixed_avail_drop(ts timestamptz, a int, b int, seg int);
SELECT create_hypertable('mixed_avail_drop', by_range('ts', interval '1 day'));
 create_hypertable 
-------------------
 (5,t)

-- Create index
CREATE INDEX idx_ab ON mixed_avail_drop (a, b);
ALTER TABLE mixed_avail_drop SET (
    timescaledb.compress,
    timescaledb.compress_segmentby = 'seg',
    timescaledb.compress_orderby = 'ts'
);
-- Insert data for 3 days (3 chunks)
INSERT INTO mixed_avail_drop
SELECT ts, (i % 10), (i % 5), 1
FROM generate_series('2024-01-01'::timestamptz, '2024-01-03', interval '1 hour') ts,
     generate_series(1, 100) i;
-- Compress first 2 chunks (will have composite bloom from index)
SELECT compress_chunk(c) FROM show_chunks('mixed_avail_drop') c LIMIT 2;
             compress_chunk             
----------------------------------------
 _timescaledb_internal._hyper_5_5_chunk
 _timescaledb_internal._hyper_5_6_chunk

-- Before index drop
EXPLAIN (ANALYZE, BUFFERS OFF, COSTS OFF, TIMING OFF, SUMMARY OFF)
SELECT * FROM mixed_avail_drop WHERE a = 1 AND b = 2
ORDER BY 1,2,3,4;
--- QUERY PLAN ---
 Custom Scan (ChunkAppend) on mixed_avail_drop (actual rows=0.00 loops=1)
   Order: mixed_avail_drop.ts, mixed_avail_drop.seg
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_5_5_chunk.ts, _hyper_5_5_chunk.seg
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_5_5_chunk (actual rows=0.00 loops=1)
               Vectorized Filter: ((a = 1) AND (b = 2))
               ->  Seq Scan on compress_hyper_6_8_chunk (actual rows=0.00 loops=1)
                     Filter: (_timescaledb_functions.bloom1_contains(regress-test-bloom_a, 1) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_b, 2) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_a_b, ROW(1, 2)))
                     Rows Removed by Filter: 2
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_5_6_chunk.ts, _hyper_5_6_chunk.seg
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_5_6_chunk (actual rows=0.00 loops=1)
               Vectorized Filter: ((a = 1) AND (b = 2))
               ->  Seq Scan on compress_hyper_6_9_chunk (actual rows=0.00 loops=1)
                     Filter: (_timescaledb_functions.bloom1_contains(regress-test-bloom_a, 1) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_b, 2) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_a_b, ROW(1, 2)))
                     Rows Removed by Filter: 3
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_5_7_chunk.ts, _hyper_5_7_chunk.seg
         Sort Method: quicksort 
         ->  Index Scan using _hyper_5_7_chunk_idx_ab on _hyper_5_7_chunk (actual rows=0.00 loops=1)
               Index Cond: ((a = 1) AND (b = 2))

-- Drop index
DROP INDEX idx_ab;
-- Compress last chunk (no composite bloom, index is gone)
SELECT compress_chunk(c) FROM show_chunks('mixed_avail_drop') c OFFSET 2;
NOTICE:  chunk "_hyper_5_5_chunk" is already converted to columnstore
NOTICE:  chunk "_hyper_5_6_chunk" is already converted to columnstore
             compress_chunk             
----------------------------------------
 _timescaledb_internal._hyper_5_7_chunk

-- Query should work on all chunks
SELECT COUNT(*) FROM mixed_avail_drop WHERE a = 1 AND b = 2;
 count 
-------
     0

-- After index drop
EXPLAIN (ANALYZE, BUFFERS OFF, COSTS OFF, TIMING OFF, SUMMARY OFF)
SELECT * FROM mixed_avail_drop WHERE a = 1 AND b = 2
ORDER BY 1,2,3,4;
--- QUERY PLAN ---
 Custom Scan (ChunkAppend) on mixed_avail_drop (actual rows=0.00 loops=1)
   Order: mixed_avail_drop.ts, mixed_avail_drop.seg
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_5_5_chunk.ts, _hyper_5_5_chunk.seg
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_5_5_chunk (actual rows=0.00 loops=1)
               Vectorized Filter: ((a = 1) AND (b = 2))
               ->  Seq Scan on compress_hyper_6_8_chunk (actual rows=0.00 loops=1)
                     Filter: (_timescaledb_functions.bloom1_contains(regress-test-bloom_a, 1) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_b, 2) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_a_b, ROW(1, 2)))
                     Rows Removed by Filter: 2
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_5_6_chunk.ts, _hyper_5_6_chunk.seg
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_5_6_chunk (actual rows=0.00 loops=1)
               Vectorized Filter: ((a = 1) AND (b = 2))
               ->  Seq Scan on compress_hyper_6_9_chunk (actual rows=0.00 loops=1)
                     Filter: (_timescaledb_functions.bloom1_contains(regress-test-bloom_a, 1) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_b, 2) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_a_b, ROW(1, 2)))
                     Rows Removed by Filter: 3
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_5_7_chunk.ts, _hyper_5_7_chunk.seg
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_5_7_chunk (actual rows=0.00 loops=1)
               Vectorized Filter: ((a = 1) AND (b = 2))
               Rows Removed by Filter: 900
               ->  Seq Scan on compress_hyper_6_10_chunk (actual rows=1.00 loops=1)

DROP TABLE IF EXISTS mixed_avail_drop CASCADE;
---------------------------------------------------------------------
-- Index added after partial compression
---------------------------------------------------------------------
CREATE TABLE mixed_avail_add(ts timestamptz, a int, b int, seg int);
SELECT create_hypertable('mixed_avail_add', by_range('ts', interval '1 day'));
 create_hypertable 
-------------------
 (7,t)

ALTER TABLE mixed_avail_add SET (
    timescaledb.compress,
    timescaledb.compress_segmentby = 'seg',
    timescaledb.compress_orderby = 'ts'
);
-- Insert and compress first 2 chunks (no composite bloom)
INSERT INTO mixed_avail_add
SELECT ts, (i % 10), (i % 5), 1
FROM generate_series('2024-01-01'::timestamptz, '2024-01-03', interval '1 hour') ts,
     generate_series(1, 100) i;
SELECT compress_chunk(c) FROM show_chunks('mixed_avail_add') c LIMIT 2;
             compress_chunk              
-----------------------------------------
 _timescaledb_internal._hyper_7_11_chunk
 _timescaledb_internal._hyper_7_12_chunk

-- Before index add
EXPLAIN (ANALYZE, BUFFERS OFF, COSTS OFF, TIMING OFF, SUMMARY OFF)
SELECT * FROM mixed_avail_add WHERE a = 1 AND b = 2
ORDER BY 1,2,3,4;
--- QUERY PLAN ---
 Custom Scan (ChunkAppend) on mixed_avail_add (actual rows=0.00 loops=1)
   Order: mixed_avail_add.ts, mixed_avail_add.seg
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_7_11_chunk.ts, _hyper_7_11_chunk.seg
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_7_11_chunk (actual rows=0.00 loops=1)
               Vectorized Filter: ((a = 1) AND (b = 2))
               Rows Removed by Filter: 1600
               ->  Seq Scan on compress_hyper_8_14_chunk (actual rows=2.00 loops=1)
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_7_12_chunk.ts, _hyper_7_12_chunk.seg
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_7_12_chunk (actual rows=0.00 loops=1)
               Vectorized Filter: ((a = 1) AND (b = 2))
               Rows Removed by Filter: 2400
               ->  Seq Scan on compress_hyper_8_15_chunk (actual rows=3.00 loops=1)
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_7_13_chunk.ts, _hyper_7_13_chunk.seg
         Sort Method: quicksort 
         ->  Seq Scan on _hyper_7_13_chunk (actual rows=0.00 loops=1)
               Filter: ((a = 1) AND (b = 2))
               Rows Removed by Filter: 900

-- Create index
CREATE INDEX idx_ab ON mixed_avail_add (a, b);
-- Compress last chunk (will have composite bloom from new index)
SELECT compress_chunk(c) FROM show_chunks('mixed_avail_add') c OFFSET 2;
NOTICE:  chunk "_hyper_7_11_chunk" is already converted to columnstore
NOTICE:  chunk "_hyper_7_12_chunk" is already converted to columnstore
             compress_chunk              
-----------------------------------------
 _timescaledb_internal._hyper_7_13_chunk

-- Query should work on all chunks
SELECT COUNT(*) FROM mixed_avail_add WHERE a = 1 AND b = 2;
 count 
-------
     0

-- After index add
EXPLAIN (ANALYZE, BUFFERS OFF, COSTS OFF, TIMING OFF, SUMMARY OFF)
SELECT * FROM mixed_avail_add WHERE a = 1 AND b = 2
ORDER BY 1,2,3,4;
--- QUERY PLAN ---
 Custom Scan (ChunkAppend) on mixed_avail_add (actual rows=0.00 loops=1)
   Order: mixed_avail_add.ts, mixed_avail_add.seg
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_7_11_chunk.ts, _hyper_7_11_chunk.seg
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_7_11_chunk (actual rows=0.00 loops=1)
               Vectorized Filter: ((a = 1) AND (b = 2))
               Rows Removed by Filter: 1600
               ->  Seq Scan on compress_hyper_8_14_chunk (actual rows=2.00 loops=1)
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_7_12_chunk.ts, _hyper_7_12_chunk.seg
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_7_12_chunk (actual rows=0.00 loops=1)
               Vectorized Filter: ((a = 1) AND (b = 2))
               Rows Removed by Filter: 2400
               ->  Seq Scan on compress_hyper_8_15_chunk (actual rows=3.00 loops=1)
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_7_13_chunk.ts, _hyper_7_13_chunk.seg
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_7_13_chunk (actual rows=0.00 loops=1)
               Vectorized Filter: ((a = 1) AND (b = 2))
               ->  Seq Scan on compress_hyper_8_16_chunk (actual rows=0.00 loops=1)
                     Filter: (_timescaledb_functions.bloom1_contains(regress-test-bloom_a, 1) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_b, 2) AND _timescaledb_functions.bloom1_contains(regress-test-bloom_a_b, ROW(1, 2)))
                     Rows Removed by Filter: 1

DROP TABLE IF EXISTS mixed_avail_add CASCADE;
---------------------------------------------------------------------
-- Manual config change between chunk compressions
---------------------------------------------------------------------
CREATE TABLE mixed_avail_manual(ts timestamptz, a int, b int, c int, seg int);
SELECT create_hypertable('mixed_avail_manual', by_range('ts', interval '1 day'));
 create_hypertable 
-------------------
 (9,t)

-- Initial config: bloom(a,b)
ALTER TABLE mixed_avail_manual SET (
    timescaledb.compress,
    timescaledb.compress_segmentby = 'seg',
    timescaledb.compress_orderby = 'ts',
    timescaledb.compress_index = 'bloom(a,b)'
);
INSERT INTO mixed_avail_manual
SELECT ts, (i % 10), (i % 5), (i % 3), 1
FROM generate_series('2024-01-01'::timestamptz, '2024-01-03', interval '1 hour') ts,
     generate_series(1, 100) i;
-- Compress first chunk with bloom(a,b)
SELECT compress_chunk(c) FROM show_chunks('mixed_avail_manual') c LIMIT 1;
             compress_chunk              
-----------------------------------------
 _timescaledb_internal._hyper_9_17_chunk

SELECT COUNT(*) FROM mixed_avail_manual WHERE a = 1 AND b = 2;
 count 
-------
     0

SELECT COUNT(*) FROM mixed_avail_manual WHERE a = 1 AND c = 2;
 count 
-------
   147

SELECT COUNT(*) FROM mixed_avail_manual WHERE b = 1 AND c = 2;
 count 
-------
   294

-- Before config changes
EXPLAIN (ANALYZE, BUFFERS OFF, COSTS OFF, TIMING OFF, SUMMARY OFF)
SELECT * FROM mixed_avail_manual WHERE a = 1 AND b = 2
ORDER BY 1,2,3,4;
--- QUERY PLAN ---
 Custom Scan (ChunkAppend) on mixed_avail_manual (actual rows=0.00 loops=1)
   Order: mixed_avail_manual.ts, mixed_avail_manual.c
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_9_17_chunk.ts, _hyper_9_17_chunk.c
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_9_17_chunk (actual rows=0.00 loops=1)
               Vectorized Filter: ((a = 1) AND (b = 2))
               ->  Seq Scan on compress_hyper_10_20_chunk (actual rows=0.00 loops=1)
                     Filter: _timescaledb_functions.bloom1_contains(regress-test-bloom_a_b, ROW(1, 2))
                     Rows Removed by Filter: 2
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_9_18_chunk.ts, _hyper_9_18_chunk.c
         Sort Method: quicksort 
         ->  Seq Scan on _hyper_9_18_chunk (actual rows=0.00 loops=1)
               Filter: ((a = 1) AND (b = 2))
               Rows Removed by Filter: 2400
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_9_19_chunk.ts, _hyper_9_19_chunk.c
         Sort Method: quicksort 
         ->  Seq Scan on _hyper_9_19_chunk (actual rows=0.00 loops=1)
               Filter: ((a = 1) AND (b = 2))
               Rows Removed by Filter: 900

EXPLAIN (ANALYZE, BUFFERS OFF, COSTS OFF, TIMING OFF, SUMMARY OFF)
SELECT * FROM mixed_avail_manual WHERE a = 1 AND c = 2
ORDER BY 1,2,3,4;
--- QUERY PLAN ---
 Custom Scan (ChunkAppend) on mixed_avail_manual (actual rows=147.00 loops=1)
   Order: mixed_avail_manual.ts, mixed_avail_manual.b
   ->  Sort (actual rows=48.00 loops=1)
         Sort Key: _hyper_9_17_chunk.ts, _hyper_9_17_chunk.b
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_9_17_chunk (actual rows=48.00 loops=1)
               Vectorized Filter: ((a = 1) AND (c = 2))
               Rows Removed by Filter: 1552
               ->  Seq Scan on compress_hyper_10_20_chunk (actual rows=2.00 loops=1)
   ->  Sort (actual rows=72.00 loops=1)
         Sort Key: _hyper_9_18_chunk.ts, _hyper_9_18_chunk.b
         Sort Method: quicksort 
         ->  Seq Scan on _hyper_9_18_chunk (actual rows=72.00 loops=1)
               Filter: ((a = 1) AND (c = 2))
               Rows Removed by Filter: 2328
   ->  Sort (actual rows=27.00 loops=1)
         Sort Key: _hyper_9_19_chunk.ts, _hyper_9_19_chunk.b
         Sort Method: quicksort 
         ->  Seq Scan on _hyper_9_19_chunk (actual rows=27.00 loops=1)
               Filter: ((a = 1) AND (c = 2))
               Rows Removed by Filter: 873

EXPLAIN (ANALYZE, BUFFERS OFF, COSTS OFF, TIMING OFF, SUMMARY OFF)
SELECT * FROM mixed_avail_manual WHERE b = 1 AND c = 2
ORDER BY 1,2,3,4;
--- QUERY PLAN ---
 Custom Scan (ChunkAppend) on mixed_avail_manual (actual rows=294.00 loops=1)
   Order: mixed_avail_manual.ts, mixed_avail_manual.a
   ->  Sort (actual rows=96.00 loops=1)
         Sort Key: _hyper_9_17_chunk.ts, _hyper_9_17_chunk.a
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_9_17_chunk (actual rows=96.00 loops=1)
               Vectorized Filter: ((b = 1) AND (c = 2))
               Rows Removed by Filter: 1504
               ->  Seq Scan on compress_hyper_10_20_chunk (actual rows=2.00 loops=1)
   ->  Sort (actual rows=144.00 loops=1)
         Sort Key: _hyper_9_18_chunk.ts, _hyper_9_18_chunk.a
         Sort Method: quicksort 
         ->  Seq Scan on _hyper_9_18_chunk (actual rows=144.00 loops=1)
               Filter: ((b = 1) AND (c = 2))
               Rows Removed by Filter: 2256
   ->  Sort (actual rows=54.00 loops=1)
         Sort Key: _hyper_9_19_chunk.ts, _hyper_9_19_chunk.a
         Sort Method: quicksort 
         ->  Seq Scan on _hyper_9_19_chunk (actual rows=54.00 loops=1)
               Filter: ((b = 1) AND (c = 2))
               Rows Removed by Filter: 846

-- Change config: bloom(a,c)
ALTER TABLE mixed_avail_manual SET (
    timescaledb.compress_index = 'bloom(a,c)'
);
-- Compress second chunk with bloom(a,c)
SELECT compress_chunk(c) FROM show_chunks('mixed_avail_manual') c OFFSET 1 LIMIT 1;
NOTICE:  chunk "_hyper_9_17_chunk" is already converted to columnstore
             compress_chunk              
-----------------------------------------
 _timescaledb_internal._hyper_9_18_chunk

-- Change config: bloom(b,c)
ALTER TABLE mixed_avail_manual SET (
    timescaledb.compress_index = 'bloom(b,c)'
);
-- Compress third chunk with bloom(b,c)
SELECT compress_chunk(c) FROM show_chunks('mixed_avail_manual') c OFFSET 2;
NOTICE:  chunk "_hyper_9_17_chunk" is already converted to columnstore
NOTICE:  chunk "_hyper_9_18_chunk" is already converted to columnstore
             compress_chunk              
-----------------------------------------
 _timescaledb_internal._hyper_9_19_chunk

SELECT COUNT(*) FROM mixed_avail_manual WHERE a = 1 AND b = 2;
 count 
-------
     0

SELECT COUNT(*) FROM mixed_avail_manual WHERE a = 1 AND c = 2;
 count 
-------
   147

SELECT COUNT(*) FROM mixed_avail_manual WHERE b = 1 AND c = 2;
 count 
-------
   294

-- After config changes
EXPLAIN (ANALYZE, BUFFERS OFF, COSTS OFF, TIMING OFF, SUMMARY OFF)
SELECT * FROM mixed_avail_manual WHERE a = 1 AND b = 2
ORDER BY 1,2,3,4;
--- QUERY PLAN ---
 Custom Scan (ChunkAppend) on mixed_avail_manual (actual rows=0.00 loops=1)
   Order: mixed_avail_manual.ts, mixed_avail_manual.c
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_9_17_chunk.ts, _hyper_9_17_chunk.c
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_9_17_chunk (actual rows=0.00 loops=1)
               Vectorized Filter: ((a = 1) AND (b = 2))
               ->  Seq Scan on compress_hyper_10_20_chunk (actual rows=0.00 loops=1)
                     Filter: _timescaledb_functions.bloom1_contains(regress-test-bloom_a_b, ROW(1, 2))
                     Rows Removed by Filter: 2
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_9_18_chunk.ts, _hyper_9_18_chunk.c
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_9_18_chunk (actual rows=0.00 loops=1)
               Vectorized Filter: ((a = 1) AND (b = 2))
               Rows Removed by Filter: 2400
               ->  Seq Scan on compress_hyper_10_21_chunk (actual rows=3.00 loops=1)
   ->  Sort (actual rows=0.00 loops=1)
         Sort Key: _hyper_9_19_chunk.ts, _hyper_9_19_chunk.c
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_9_19_chunk (actual rows=0.00 loops=1)
               Vectorized Filter: ((a = 1) AND (b = 2))
               Rows Removed by Filter: 900
               ->  Seq Scan on compress_hyper_10_22_chunk (actual rows=1.00 loops=1)

EXPLAIN (ANALYZE, BUFFERS OFF, COSTS OFF, TIMING OFF, SUMMARY OFF)
SELECT * FROM mixed_avail_manual WHERE a = 1 AND c = 2
ORDER BY 1,2,3,4;
--- QUERY PLAN ---
 Custom Scan (ChunkAppend) on mixed_avail_manual (actual rows=147.00 loops=1)
   Order: mixed_avail_manual.ts, mixed_avail_manual.b
   ->  Sort (actual rows=48.00 loops=1)
         Sort Key: _hyper_9_17_chunk.ts, _hyper_9_17_chunk.b
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_9_17_chunk (actual rows=48.00 loops=1)
               Vectorized Filter: ((a = 1) AND (c = 2))
               Rows Removed by Filter: 1552
               ->  Seq Scan on compress_hyper_10_20_chunk (actual rows=2.00 loops=1)
   ->  Sort (actual rows=72.00 loops=1)
         Sort Key: _hyper_9_18_chunk.ts, _hyper_9_18_chunk.b
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_9_18_chunk (actual rows=72.00 loops=1)
               Vectorized Filter: ((a = 1) AND (c = 2))
               Rows Removed by Filter: 2328
               ->  Seq Scan on compress_hyper_10_21_chunk (actual rows=3.00 loops=1)
                     Filter: _timescaledb_functions.bloom1_contains(regress-test-bloom_a_c, ROW(1, 2))
   ->  Sort (actual rows=27.00 loops=1)
         Sort Key: _hyper_9_19_chunk.ts, _hyper_9_19_chunk.b
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_9_19_chunk (actual rows=27.00 loops=1)
               Vectorized Filter: ((a = 1) AND (c = 2))
               Rows Removed by Filter: 873
               ->  Seq Scan on compress_hyper_10_22_chunk (actual rows=1.00 loops=1)

EXPLAIN (ANALYZE, BUFFERS OFF, COSTS OFF, TIMING OFF, SUMMARY OFF)
SELECT * FROM mixed_avail_manual WHERE b = 1 AND c = 2
ORDER BY 1,2,3,4;
--- QUERY PLAN ---
 Custom Scan (ChunkAppend) on mixed_avail_manual (actual rows=294.00 loops=1)
   Order: mixed_avail_manual.ts, mixed_avail_manual.a
   ->  Sort (actual rows=96.00 loops=1)
         Sort Key: _hyper_9_17_chunk.ts, _hyper_9_17_chunk.a
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_9_17_chunk (actual rows=96.00 loops=1)
               Vectorized Filter: ((b = 1) AND (c = 2))
               Rows Removed by Filter: 1504
               ->  Seq Scan on compress_hyper_10_20_chunk (actual rows=2.00 loops=1)
   ->  Sort (actual rows=144.00 loops=1)
         Sort Key: _hyper_9_18_chunk.ts, _hyper_9_18_chunk.a
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_9_18_chunk (actual rows=144.00 loops=1)
               Vectorized Filter: ((b = 1) AND (c = 2))
               Rows Removed by Filter: 2256
               ->  Seq Scan on compress_hyper_10_21_chunk (actual rows=3.00 loops=1)
   ->  Sort (actual rows=54.00 loops=1)
         Sort Key: _hyper_9_19_chunk.ts, _hyper_9_19_chunk.a
         Sort Method: quicksort 
         ->  Custom Scan (ColumnarScan) on _hyper_9_19_chunk (actual rows=54.00 loops=1)
               Vectorized Filter: ((b = 1) AND (c = 2))
               Rows Removed by Filter: 846
               ->  Seq Scan on compress_hyper_10_22_chunk (actual rows=1.00 loops=1)
                     Filter: _timescaledb_functions.bloom1_contains(regress-test-bloom_b_c, ROW(1, 2))

DROP TABLE IF EXISTS mixed_avail_manual CASCADE;
-------------------------------------------------------------------
-- Upsert tests
-------------------------------------------------------------------
-- Explain test
CREATE TABLE explain_test(ts timestamptz, device_id int, metric text, value float);
SELECT create_hypertable('explain_test', by_range('ts'));
 create_hypertable 
-------------------
 (11,t)

CREATE UNIQUE INDEX idx_explain ON explain_test(device_id, metric, ts);
ALTER TABLE explain_test SET (timescaledb.compress, timescaledb.compress_segmentby ='');
INSERT INTO explain_test
SELECT '2024-01-01'::timestamptz + (i || ' minutes')::interval, i % 10, 'temp', i
FROM generate_series(1, 5000) i;
SELECT count(compress_chunk(c)) FROM show_chunks('explain_test') c;
 count 
-------
     2

EXPLAIN (ANALYZE, COSTS OFF, TIMING OFF, SUMMARY OFF)
INSERT INTO explain_test VALUES ('2024-01-01 00:05:30', 5, 'temp', 100)
ON CONFLICT (device_id, metric, ts) DO NOTHING;
--- QUERY PLAN ---
 Custom Scan (ModifyHypertable) (actual rows=0.00 loops=1)
   Batches pruned by bloom: 2
   Buffers: shared hit=198 read=2 dirtied=5 written=3
   ->  Insert on explain_test (actual rows=0.00 loops=1)
         Conflict Resolution: NOTHING
         Conflict Arbiter Indexes: idx_explain
         Tuples Inserted: 1
         Conflicting Tuples: 0
         Buffers: shared hit=198 read=2 dirtied=5 written=3
         ->  Result (actual rows=1.00 loops=1)
 Planning:
   Buffers: shared hit=9

DROP TABLE IF EXISTS explain_test CASCADE;
