-- This file and its contents are licensed under the Apache License 2.0.
-- Please see the included NOTICE for copyright information and
-- LICENSE-APACHE for a copy of the license.
--
-- Test calendar-based chunking
--
-- Calendar-based chunking aligns chunks with calendar boundaries
-- (e.g., start of day, week, month, year) based on a user-specified origin
-- and the current session timezone.
--
\c :TEST_DBNAME :ROLE_SUPERUSER
CREATE OR REPLACE FUNCTION calc_range(ts TIMESTAMPTZ, chunk_interval INTERVAL, origin TIMESTAMPTZ DEFAULT NULL, force_general BOOL DEFAULT NULL)
RETURNS TABLE(start_ts TIMESTAMPTZ, end_ts TIMESTAMPTZ) AS :MODULE_PATHNAME, 'ts_dimension_calculate_open_range_calendar' LANGUAGE C;
-- C unit tests for chunk_range.c
CREATE OR REPLACE FUNCTION test_chunk_range()
RETURNS VOID AS :MODULE_PATHNAME, 'ts_test_chunk_range' LANGUAGE C;
SET ROLE :ROLE_DEFAULT_PERM_USER;
\set VERBOSITY terse
SET timescaledb.enable_calendar_chunking = true;
---------------------------------------------------------------
-- CALC_RANGE TESTS
-- Test the calc_range() function with various intervals and timestamps
---------------------------------------------------------------
-- Helper function to verify ranges
CREATE OR REPLACE FUNCTION test_ranges(
    timestamps TIMESTAMPTZ[],
    intervals INTERVAL[]
) RETURNS TABLE(ts TIMESTAMPTZ, inv INTERVAL, start_ts TIMESTAMPTZ, end_ts TIMESTAMPTZ, dur INTERVAL, in_range BOOLEAN) AS $$
    SELECT t.ts, i.inv, r.start_ts, r.end_ts, r.end_ts - r.start_ts, t.ts >= r.start_ts AND t.ts < r.end_ts
    FROM unnest(timestamps) AS t(ts)
    CROSS JOIN unnest(intervals) AS i(inv)
    CROSS JOIN LATERAL calc_range(t.ts, i.inv) r
    ORDER BY t.ts, i.inv;
$$ LANGUAGE SQL;
-- Helper function to verify ranges with custom origin
CREATE OR REPLACE FUNCTION test_ranges_with_origin(
    timestamps TIMESTAMPTZ[],
    intervals INTERVAL[],
    origin TIMESTAMPTZ
) RETURNS TABLE(ts TIMESTAMPTZ, inv INTERVAL, start_ts TIMESTAMPTZ, end_ts TIMESTAMPTZ, dur INTERVAL, in_range BOOLEAN) AS $$
    SELECT t.ts, i.inv, r.start_ts, r.end_ts, r.end_ts - r.start_ts, t.ts >= r.start_ts AND t.ts < r.end_ts
    FROM unnest(timestamps) AS t(ts)
    CROSS JOIN unnest(intervals) AS i(inv)
    CROSS JOIN LATERAL calc_range(t.ts, i.inv, origin) r
    ORDER BY t.ts, i.inv;
$$ LANGUAGE SQL;
-- Helper function to show CHECK constraints with chunk size for time-based hypertables
-- Uses CASE to handle infinite timestamps (older PG versions can't subtract them)
CREATE OR REPLACE FUNCTION show_chunk_constraints(ht_name text)
RETURNS TABLE(chunk text, constraint_def text, chunk_size interval) AS $$
    SELECT c.table_name::text,
           pg_get_constraintdef(con.oid),
           CASE WHEN ch.range_start = '-infinity'::timestamptz
                  OR ch.range_end = 'infinity'::timestamptz
                THEN NULL
                ELSE ch.range_end - ch.range_start
           END
    FROM _timescaledb_catalog.chunk c
    JOIN pg_constraint con ON con.conrelid = format('%I.%I', c.schema_name, c.table_name)::regclass
    JOIN timescaledb_information.chunks ch ON ch.chunk_name = c.table_name AND ch.hypertable_name = ht_name
    WHERE c.hypertable_id = (SELECT id FROM _timescaledb_catalog.hypertable WHERE table_name = ht_name)
      AND con.contype = 'c'
    ORDER BY c.table_name;
$$ LANGUAGE SQL;
-- Helper function to show dimension slices with chunk size for integer hypertables
CREATE OR REPLACE FUNCTION show_int_chunk_slices(ht_name text)
RETURNS TABLE(chunk_name text, range_start bigint, range_end bigint, chunk_size bigint) AS $$
    SELECT c.table_name::text, ds.range_start, ds.range_end,
           ds.range_end - ds.range_start
    FROM _timescaledb_catalog.chunk c
    JOIN _timescaledb_catalog.chunk_constraint cc ON c.id = cc.chunk_id
    JOIN _timescaledb_catalog.dimension_slice ds ON cc.dimension_slice_id = ds.id
    WHERE c.hypertable_id = (SELECT id FROM _timescaledb_catalog.hypertable WHERE table_name = ht_name)
    ORDER BY ds.range_start;
$$ LANGUAGE SQL;
-- Helper function to show CHECK constraints only (for integer hypertables)
CREATE OR REPLACE FUNCTION show_check_constraints(ht_name text)
RETURNS TABLE(chunk text, constraint_def text) AS $$
    SELECT c.table_name::text,
           pg_get_constraintdef(con.oid)
    FROM _timescaledb_catalog.chunk c
    JOIN pg_constraint con ON con.conrelid = format('%I.%I', c.schema_name, c.table_name)::regclass
    WHERE c.hypertable_id = (SELECT id FROM _timescaledb_catalog.hypertable WHERE table_name = ht_name)
      AND con.contype = 'c'
    ORDER BY c.table_name;
$$ LANGUAGE SQL;
-- Basic interval tests in UTC
SET timezone = 'UTC';
SELECT * FROM test_ranges(
    ARRAY[
        '2024-01-15 12:30:45 UTC'::timestamptz,
        '2024-06-15 00:00:00 UTC',
        '2024-06-15 23:59:59.999999 UTC'
    ],
    ARRAY[
        '1 minute'::interval, '5 minutes', '15 minutes', '30 minutes',
        '1 hour', '2 hours', '4 hours', '6 hours', '12 hours',
        '1 day', '1 week', '1 month', '3 months', '6 months', '1 year'
    ]
);
                 ts                  |    inv     |           start_ts           |            end_ts            |    dur     | in_range 
-------------------------------------+------------+------------------------------+------------------------------+------------+----------
 Mon Jan 15 12:30:45 2024 UTC        | @ 1 min    | Mon Jan 15 12:30:00 2024 UTC | Mon Jan 15 12:31:00 2024 UTC | @ 1 min    | t
 Mon Jan 15 12:30:45 2024 UTC        | @ 5 mins   | Mon Jan 15 12:30:00 2024 UTC | Mon Jan 15 12:35:00 2024 UTC | @ 5 mins   | t
 Mon Jan 15 12:30:45 2024 UTC        | @ 15 mins  | Mon Jan 15 12:30:00 2024 UTC | Mon Jan 15 12:45:00 2024 UTC | @ 15 mins  | t
 Mon Jan 15 12:30:45 2024 UTC        | @ 30 mins  | Mon Jan 15 12:30:00 2024 UTC | Mon Jan 15 13:00:00 2024 UTC | @ 30 mins  | t
 Mon Jan 15 12:30:45 2024 UTC        | @ 1 hour   | Mon Jan 15 12:00:00 2024 UTC | Mon Jan 15 13:00:00 2024 UTC | @ 1 hour   | t
 Mon Jan 15 12:30:45 2024 UTC        | @ 2 hours  | Mon Jan 15 12:00:00 2024 UTC | Mon Jan 15 14:00:00 2024 UTC | @ 2 hours  | t
 Mon Jan 15 12:30:45 2024 UTC        | @ 4 hours  | Mon Jan 15 12:00:00 2024 UTC | Mon Jan 15 16:00:00 2024 UTC | @ 4 hours  | t
 Mon Jan 15 12:30:45 2024 UTC        | @ 6 hours  | Mon Jan 15 12:00:00 2024 UTC | Mon Jan 15 18:00:00 2024 UTC | @ 6 hours  | t
 Mon Jan 15 12:30:45 2024 UTC        | @ 12 hours | Mon Jan 15 12:00:00 2024 UTC | Tue Jan 16 00:00:00 2024 UTC | @ 12 hours | t
 Mon Jan 15 12:30:45 2024 UTC        | @ 1 day    | Mon Jan 15 00:00:00 2024 UTC | Tue Jan 16 00:00:00 2024 UTC | @ 1 day    | t
 Mon Jan 15 12:30:45 2024 UTC        | @ 7 days   | Mon Jan 15 00:00:00 2024 UTC | Mon Jan 22 00:00:00 2024 UTC | @ 7 days   | t
 Mon Jan 15 12:30:45 2024 UTC        | @ 1 mon    | Mon Jan 01 00:00:00 2024 UTC | Thu Feb 01 00:00:00 2024 UTC | @ 31 days  | t
 Mon Jan 15 12:30:45 2024 UTC        | @ 3 mons   | Mon Jan 01 00:00:00 2024 UTC | Mon Apr 01 00:00:00 2024 UTC | @ 91 days  | t
 Mon Jan 15 12:30:45 2024 UTC        | @ 6 mons   | Mon Jan 01 00:00:00 2024 UTC | Mon Jul 01 00:00:00 2024 UTC | @ 182 days | t
 Mon Jan 15 12:30:45 2024 UTC        | @ 1 year   | Mon Jan 01 00:00:00 2024 UTC | Wed Jan 01 00:00:00 2025 UTC | @ 366 days | t
 Sat Jun 15 00:00:00 2024 UTC        | @ 1 min    | Sat Jun 15 00:00:00 2024 UTC | Sat Jun 15 00:01:00 2024 UTC | @ 1 min    | t
 Sat Jun 15 00:00:00 2024 UTC        | @ 5 mins   | Sat Jun 15 00:00:00 2024 UTC | Sat Jun 15 00:05:00 2024 UTC | @ 5 mins   | t
 Sat Jun 15 00:00:00 2024 UTC        | @ 15 mins  | Sat Jun 15 00:00:00 2024 UTC | Sat Jun 15 00:15:00 2024 UTC | @ 15 mins  | t
 Sat Jun 15 00:00:00 2024 UTC        | @ 30 mins  | Sat Jun 15 00:00:00 2024 UTC | Sat Jun 15 00:30:00 2024 UTC | @ 30 mins  | t
 Sat Jun 15 00:00:00 2024 UTC        | @ 1 hour   | Sat Jun 15 00:00:00 2024 UTC | Sat Jun 15 01:00:00 2024 UTC | @ 1 hour   | t
 Sat Jun 15 00:00:00 2024 UTC        | @ 2 hours  | Sat Jun 15 00:00:00 2024 UTC | Sat Jun 15 02:00:00 2024 UTC | @ 2 hours  | t
 Sat Jun 15 00:00:00 2024 UTC        | @ 4 hours  | Sat Jun 15 00:00:00 2024 UTC | Sat Jun 15 04:00:00 2024 UTC | @ 4 hours  | t
 Sat Jun 15 00:00:00 2024 UTC        | @ 6 hours  | Sat Jun 15 00:00:00 2024 UTC | Sat Jun 15 06:00:00 2024 UTC | @ 6 hours  | t
 Sat Jun 15 00:00:00 2024 UTC        | @ 12 hours | Sat Jun 15 00:00:00 2024 UTC | Sat Jun 15 12:00:00 2024 UTC | @ 12 hours | t
 Sat Jun 15 00:00:00 2024 UTC        | @ 1 day    | Sat Jun 15 00:00:00 2024 UTC | Sun Jun 16 00:00:00 2024 UTC | @ 1 day    | t
 Sat Jun 15 00:00:00 2024 UTC        | @ 7 days   | Mon Jun 10 00:00:00 2024 UTC | Mon Jun 17 00:00:00 2024 UTC | @ 7 days   | t
 Sat Jun 15 00:00:00 2024 UTC        | @ 1 mon    | Sat Jun 01 00:00:00 2024 UTC | Mon Jul 01 00:00:00 2024 UTC | @ 30 days  | t
 Sat Jun 15 00:00:00 2024 UTC        | @ 3 mons   | Mon Apr 01 00:00:00 2024 UTC | Mon Jul 01 00:00:00 2024 UTC | @ 91 days  | t
 Sat Jun 15 00:00:00 2024 UTC        | @ 6 mons   | Mon Jan 01 00:00:00 2024 UTC | Mon Jul 01 00:00:00 2024 UTC | @ 182 days | t
 Sat Jun 15 00:00:00 2024 UTC        | @ 1 year   | Mon Jan 01 00:00:00 2024 UTC | Wed Jan 01 00:00:00 2025 UTC | @ 366 days | t
 Sat Jun 15 23:59:59.999999 2024 UTC | @ 1 min    | Sat Jun 15 23:59:00 2024 UTC | Sun Jun 16 00:00:00 2024 UTC | @ 1 min    | t
 Sat Jun 15 23:59:59.999999 2024 UTC | @ 5 mins   | Sat Jun 15 23:55:00 2024 UTC | Sun Jun 16 00:00:00 2024 UTC | @ 5 mins   | t
 Sat Jun 15 23:59:59.999999 2024 UTC | @ 15 mins  | Sat Jun 15 23:45:00 2024 UTC | Sun Jun 16 00:00:00 2024 UTC | @ 15 mins  | t
 Sat Jun 15 23:59:59.999999 2024 UTC | @ 30 mins  | Sat Jun 15 23:30:00 2024 UTC | Sun Jun 16 00:00:00 2024 UTC | @ 30 mins  | t
 Sat Jun 15 23:59:59.999999 2024 UTC | @ 1 hour   | Sat Jun 15 23:00:00 2024 UTC | Sun Jun 16 00:00:00 2024 UTC | @ 1 hour   | t
 Sat Jun 15 23:59:59.999999 2024 UTC | @ 2 hours  | Sat Jun 15 22:00:00 2024 UTC | Sun Jun 16 00:00:00 2024 UTC | @ 2 hours  | t
 Sat Jun 15 23:59:59.999999 2024 UTC | @ 4 hours  | Sat Jun 15 20:00:00 2024 UTC | Sun Jun 16 00:00:00 2024 UTC | @ 4 hours  | t
 Sat Jun 15 23:59:59.999999 2024 UTC | @ 6 hours  | Sat Jun 15 18:00:00 2024 UTC | Sun Jun 16 00:00:00 2024 UTC | @ 6 hours  | t
 Sat Jun 15 23:59:59.999999 2024 UTC | @ 12 hours | Sat Jun 15 12:00:00 2024 UTC | Sun Jun 16 00:00:00 2024 UTC | @ 12 hours | t
 Sat Jun 15 23:59:59.999999 2024 UTC | @ 1 day    | Sat Jun 15 00:00:00 2024 UTC | Sun Jun 16 00:00:00 2024 UTC | @ 1 day    | t
 Sat Jun 15 23:59:59.999999 2024 UTC | @ 7 days   | Mon Jun 10 00:00:00 2024 UTC | Mon Jun 17 00:00:00 2024 UTC | @ 7 days   | t
 Sat Jun 15 23:59:59.999999 2024 UTC | @ 1 mon    | Sat Jun 01 00:00:00 2024 UTC | Mon Jul 01 00:00:00 2024 UTC | @ 30 days  | t
 Sat Jun 15 23:59:59.999999 2024 UTC | @ 3 mons   | Mon Apr 01 00:00:00 2024 UTC | Mon Jul 01 00:00:00 2024 UTC | @ 91 days  | t
 Sat Jun 15 23:59:59.999999 2024 UTC | @ 6 mons   | Mon Jan 01 00:00:00 2024 UTC | Mon Jul 01 00:00:00 2024 UTC | @ 182 days | t
 Sat Jun 15 23:59:59.999999 2024 UTC | @ 1 year   | Mon Jan 01 00:00:00 2024 UTC | Wed Jan 01 00:00:00 2025 UTC | @ 366 days | t

-- Leap year tests
SELECT * FROM test_ranges(
    ARRAY[
        '2024-02-28 12:00:00 UTC'::timestamptz,  -- leap year
        '2024-02-29 00:00:00 UTC',
        '2024-02-29 23:59:59 UTC',
        '2024-03-01 00:00:00 UTC',
        '2025-02-28 12:00:00 UTC',  -- non-leap year
        '2025-02-28 23:59:59 UTC',
        '2025-03-01 00:00:00 UTC'
    ],
    ARRAY['1 day'::interval, '1 month']
);
              ts              |   inv   |           start_ts           |            end_ts            |    dur    | in_range 
------------------------------+---------+------------------------------+------------------------------+-----------+----------
 Wed Feb 28 12:00:00 2024 UTC | @ 1 day | Wed Feb 28 00:00:00 2024 UTC | Thu Feb 29 00:00:00 2024 UTC | @ 1 day   | t
 Wed Feb 28 12:00:00 2024 UTC | @ 1 mon | Thu Feb 01 00:00:00 2024 UTC | Fri Mar 01 00:00:00 2024 UTC | @ 29 days | t
 Thu Feb 29 00:00:00 2024 UTC | @ 1 day | Thu Feb 29 00:00:00 2024 UTC | Fri Mar 01 00:00:00 2024 UTC | @ 1 day   | t
 Thu Feb 29 00:00:00 2024 UTC | @ 1 mon | Thu Feb 01 00:00:00 2024 UTC | Fri Mar 01 00:00:00 2024 UTC | @ 29 days | t
 Thu Feb 29 23:59:59 2024 UTC | @ 1 day | Thu Feb 29 00:00:00 2024 UTC | Fri Mar 01 00:00:00 2024 UTC | @ 1 day   | t
 Thu Feb 29 23:59:59 2024 UTC | @ 1 mon | Thu Feb 01 00:00:00 2024 UTC | Fri Mar 01 00:00:00 2024 UTC | @ 29 days | t
 Fri Mar 01 00:00:00 2024 UTC | @ 1 day | Fri Mar 01 00:00:00 2024 UTC | Sat Mar 02 00:00:00 2024 UTC | @ 1 day   | t
 Fri Mar 01 00:00:00 2024 UTC | @ 1 mon | Fri Mar 01 00:00:00 2024 UTC | Mon Apr 01 00:00:00 2024 UTC | @ 31 days | t
 Fri Feb 28 12:00:00 2025 UTC | @ 1 day | Fri Feb 28 00:00:00 2025 UTC | Sat Mar 01 00:00:00 2025 UTC | @ 1 day   | t
 Fri Feb 28 12:00:00 2025 UTC | @ 1 mon | Sat Feb 01 00:00:00 2025 UTC | Sat Mar 01 00:00:00 2025 UTC | @ 28 days | t
 Fri Feb 28 23:59:59 2025 UTC | @ 1 day | Fri Feb 28 00:00:00 2025 UTC | Sat Mar 01 00:00:00 2025 UTC | @ 1 day   | t
 Fri Feb 28 23:59:59 2025 UTC | @ 1 mon | Sat Feb 01 00:00:00 2025 UTC | Sat Mar 01 00:00:00 2025 UTC | @ 28 days | t
 Sat Mar 01 00:00:00 2025 UTC | @ 1 day | Sat Mar 01 00:00:00 2025 UTC | Sun Mar 02 00:00:00 2025 UTC | @ 1 day   | t
 Sat Mar 01 00:00:00 2025 UTC | @ 1 mon | Sat Mar 01 00:00:00 2025 UTC | Tue Apr 01 00:00:00 2025 UTC | @ 31 days | t

-- Week alignment (should align to Monday)
SELECT * FROM test_ranges(
    ARRAY[
        '2024-06-10 12:00:00 UTC'::timestamptz,  -- Monday
        '2024-06-11 12:00:00 UTC',  -- Tuesday
        '2024-06-14 12:00:00 UTC',  -- Friday
        '2024-06-16 12:00:00 UTC',  -- Sunday
        '2024-06-17 00:00:00 UTC'   -- Monday (next week)
    ],
    ARRAY['1 week'::interval, '2 weeks']
);
              ts              |    inv    |           start_ts           |            end_ts            |    dur    | in_range 
------------------------------+-----------+------------------------------+------------------------------+-----------+----------
 Mon Jun 10 12:00:00 2024 UTC | @ 7 days  | Mon Jun 10 00:00:00 2024 UTC | Mon Jun 17 00:00:00 2024 UTC | @ 7 days  | t
 Mon Jun 10 12:00:00 2024 UTC | @ 14 days | Mon Jun 03 00:00:00 2024 UTC | Mon Jun 17 00:00:00 2024 UTC | @ 14 days | t
 Tue Jun 11 12:00:00 2024 UTC | @ 7 days  | Mon Jun 10 00:00:00 2024 UTC | Mon Jun 17 00:00:00 2024 UTC | @ 7 days  | t
 Tue Jun 11 12:00:00 2024 UTC | @ 14 days | Mon Jun 03 00:00:00 2024 UTC | Mon Jun 17 00:00:00 2024 UTC | @ 14 days | t
 Fri Jun 14 12:00:00 2024 UTC | @ 7 days  | Mon Jun 10 00:00:00 2024 UTC | Mon Jun 17 00:00:00 2024 UTC | @ 7 days  | t
 Fri Jun 14 12:00:00 2024 UTC | @ 14 days | Mon Jun 03 00:00:00 2024 UTC | Mon Jun 17 00:00:00 2024 UTC | @ 14 days | t
 Sun Jun 16 12:00:00 2024 UTC | @ 7 days  | Mon Jun 10 00:00:00 2024 UTC | Mon Jun 17 00:00:00 2024 UTC | @ 7 days  | t
 Sun Jun 16 12:00:00 2024 UTC | @ 14 days | Mon Jun 03 00:00:00 2024 UTC | Mon Jun 17 00:00:00 2024 UTC | @ 14 days | t
 Mon Jun 17 00:00:00 2024 UTC | @ 7 days  | Mon Jun 17 00:00:00 2024 UTC | Mon Jun 24 00:00:00 2024 UTC | @ 7 days  | t
 Mon Jun 17 00:00:00 2024 UTC | @ 14 days | Mon Jun 17 00:00:00 2024 UTC | Mon Jul 01 00:00:00 2024 UTC | @ 14 days | t

-- Year boundary tests
SELECT * FROM test_ranges(
    ARRAY[
        '2024-12-31 23:59:59 UTC'::timestamptz,
        '2025-01-01 00:00:00 UTC'
    ],
    ARRAY['1 day'::interval, '1 week', '1 month', '1 year']
);
              ts              |   inv    |           start_ts           |            end_ts            |    dur     | in_range 
------------------------------+----------+------------------------------+------------------------------+------------+----------
 Tue Dec 31 23:59:59 2024 UTC | @ 1 day  | Tue Dec 31 00:00:00 2024 UTC | Wed Jan 01 00:00:00 2025 UTC | @ 1 day    | t
 Tue Dec 31 23:59:59 2024 UTC | @ 7 days | Mon Dec 30 00:00:00 2024 UTC | Mon Jan 06 00:00:00 2025 UTC | @ 7 days   | t
 Tue Dec 31 23:59:59 2024 UTC | @ 1 mon  | Sun Dec 01 00:00:00 2024 UTC | Wed Jan 01 00:00:00 2025 UTC | @ 31 days  | t
 Tue Dec 31 23:59:59 2024 UTC | @ 1 year | Mon Jan 01 00:00:00 2024 UTC | Wed Jan 01 00:00:00 2025 UTC | @ 366 days | t
 Wed Jan 01 00:00:00 2025 UTC | @ 1 day  | Wed Jan 01 00:00:00 2025 UTC | Thu Jan 02 00:00:00 2025 UTC | @ 1 day    | t
 Wed Jan 01 00:00:00 2025 UTC | @ 7 days | Mon Dec 30 00:00:00 2024 UTC | Mon Jan 06 00:00:00 2025 UTC | @ 7 days   | t
 Wed Jan 01 00:00:00 2025 UTC | @ 1 mon  | Wed Jan 01 00:00:00 2025 UTC | Sat Feb 01 00:00:00 2025 UTC | @ 31 days  | t
 Wed Jan 01 00:00:00 2025 UTC | @ 1 year | Wed Jan 01 00:00:00 2025 UTC | Thu Jan 01 00:00:00 2026 UTC | @ 365 days | t

-- Custom origin: days starting at noon
SELECT * FROM test_ranges_with_origin(
    ARRAY[
        '2024-06-15 11:59:59 UTC'::timestamptz,
        '2024-06-15 12:00:00 UTC',
        '2024-06-15 23:59:59 UTC',
        '2024-06-16 00:00:00 UTC',
        '2024-06-16 11:59:59 UTC',
        '2024-06-16 12:00:00 UTC'
    ],
    ARRAY['1 day'::interval],
    '2020-01-01 12:00:00 UTC'
);
              ts              |   inv   |           start_ts           |            end_ts            |   dur   | in_range 
------------------------------+---------+------------------------------+------------------------------+---------+----------
 Sat Jun 15 11:59:59 2024 UTC | @ 1 day | Fri Jun 14 12:00:00 2024 UTC | Sat Jun 15 12:00:00 2024 UTC | @ 1 day | t
 Sat Jun 15 12:00:00 2024 UTC | @ 1 day | Sat Jun 15 12:00:00 2024 UTC | Sun Jun 16 12:00:00 2024 UTC | @ 1 day | t
 Sat Jun 15 23:59:59 2024 UTC | @ 1 day | Sat Jun 15 12:00:00 2024 UTC | Sun Jun 16 12:00:00 2024 UTC | @ 1 day | t
 Sun Jun 16 00:00:00 2024 UTC | @ 1 day | Sat Jun 15 12:00:00 2024 UTC | Sun Jun 16 12:00:00 2024 UTC | @ 1 day | t
 Sun Jun 16 11:59:59 2024 UTC | @ 1 day | Sat Jun 15 12:00:00 2024 UTC | Sun Jun 16 12:00:00 2024 UTC | @ 1 day | t
 Sun Jun 16 12:00:00 2024 UTC | @ 1 day | Sun Jun 16 12:00:00 2024 UTC | Mon Jun 17 12:00:00 2024 UTC | @ 1 day | t

-- Custom origin: 15 minutes past midnight
SELECT * FROM test_ranges_with_origin(
    ARRAY[
        '2024-06-15 00:00:00 UTC'::timestamptz,
        '2024-06-15 00:14:59 UTC',
        '2024-06-15 00:15:00 UTC',
        '2024-06-15 12:00:00 UTC',
        '2024-06-16 00:14:59 UTC',
        '2024-06-16 00:15:00 UTC'
    ],
    ARRAY['1 day'::interval],
    '2020-01-01 00:15:00 UTC'
);
              ts              |   inv   |           start_ts           |            end_ts            |   dur   | in_range 
------------------------------+---------+------------------------------+------------------------------+---------+----------
 Sat Jun 15 00:00:00 2024 UTC | @ 1 day | Fri Jun 14 00:15:00 2024 UTC | Sat Jun 15 00:15:00 2024 UTC | @ 1 day | t
 Sat Jun 15 00:14:59 2024 UTC | @ 1 day | Fri Jun 14 00:15:00 2024 UTC | Sat Jun 15 00:15:00 2024 UTC | @ 1 day | t
 Sat Jun 15 00:15:00 2024 UTC | @ 1 day | Sat Jun 15 00:15:00 2024 UTC | Sun Jun 16 00:15:00 2024 UTC | @ 1 day | t
 Sat Jun 15 12:00:00 2024 UTC | @ 1 day | Sat Jun 15 00:15:00 2024 UTC | Sun Jun 16 00:15:00 2024 UTC | @ 1 day | t
 Sun Jun 16 00:14:59 2024 UTC | @ 1 day | Sat Jun 15 00:15:00 2024 UTC | Sun Jun 16 00:15:00 2024 UTC | @ 1 day | t
 Sun Jun 16 00:15:00 2024 UTC | @ 1 day | Sun Jun 16 00:15:00 2024 UTC | Mon Jun 17 00:15:00 2024 UTC | @ 1 day | t

-- Custom origin: hourly chunks starting at 30 minutes
SELECT * FROM test_ranges_with_origin(
    ARRAY[
        '2024-06-15 12:00:00 UTC'::timestamptz,
        '2024-06-15 12:29:59 UTC',
        '2024-06-15 12:30:00 UTC',
        '2024-06-15 13:29:59 UTC',
        '2024-06-15 13:30:00 UTC'
    ],
    ARRAY['1 hour'::interval],
    '2020-01-01 00:30:00 UTC'
);
              ts              |   inv    |           start_ts           |            end_ts            |   dur    | in_range 
------------------------------+----------+------------------------------+------------------------------+----------+----------
 Sat Jun 15 12:00:00 2024 UTC | @ 1 hour | Sat Jun 15 11:30:00 2024 UTC | Sat Jun 15 12:30:00 2024 UTC | @ 1 hour | t
 Sat Jun 15 12:29:59 2024 UTC | @ 1 hour | Sat Jun 15 11:30:00 2024 UTC | Sat Jun 15 12:30:00 2024 UTC | @ 1 hour | t
 Sat Jun 15 12:30:00 2024 UTC | @ 1 hour | Sat Jun 15 12:30:00 2024 UTC | Sat Jun 15 13:30:00 2024 UTC | @ 1 hour | t
 Sat Jun 15 13:29:59 2024 UTC | @ 1 hour | Sat Jun 15 12:30:00 2024 UTC | Sat Jun 15 13:30:00 2024 UTC | @ 1 hour | t
 Sat Jun 15 13:30:00 2024 UTC | @ 1 hour | Sat Jun 15 13:30:00 2024 UTC | Sat Jun 15 14:30:00 2024 UTC | @ 1 hour | t

---------------------------------------------------------------
-- DST TRANSITION TESTS
---------------------------------------------------------------
-- America/Los_Angeles DST spring forward (Mar 10)
SET timezone = 'America/Los_Angeles';
SELECT * FROM test_ranges(
    ARRAY[
        '2024-03-09 23:59:59 America/Los_Angeles'::timestamptz,
        '2024-03-10 00:00:00 America/Los_Angeles',
        '2024-03-10 01:59:59 America/Los_Angeles',
        '2024-03-10 03:00:00 America/Los_Angeles',  -- 2 AM doesn't exist
        '2024-03-11 00:00:00 America/Los_Angeles'
    ],
    ARRAY['1 hour'::interval, '1 day', '1 week']
);
              ts              |   inv    |           start_ts           |            end_ts            |        dur        | in_range 
------------------------------+----------+------------------------------+------------------------------+-------------------+----------
 Sat Mar 09 23:59:59 2024 PST | @ 1 hour | Sat Mar 09 23:00:00 2024 PST | Sun Mar 10 00:00:00 2024 PST | @ 1 hour          | t
 Sat Mar 09 23:59:59 2024 PST | @ 1 day  | Sat Mar 09 00:00:00 2024 PST | Sun Mar 10 00:00:00 2024 PST | @ 1 day           | t
 Sat Mar 09 23:59:59 2024 PST | @ 7 days | Mon Mar 04 00:00:00 2024 PST | Mon Mar 11 00:00:00 2024 PDT | @ 6 days 23 hours | t
 Sun Mar 10 00:00:00 2024 PST | @ 1 hour | Sun Mar 10 00:00:00 2024 PST | Sun Mar 10 01:00:00 2024 PST | @ 1 hour          | t
 Sun Mar 10 00:00:00 2024 PST | @ 1 day  | Sun Mar 10 00:00:00 2024 PST | Mon Mar 11 00:00:00 2024 PDT | @ 23 hours        | t
 Sun Mar 10 00:00:00 2024 PST | @ 7 days | Mon Mar 04 00:00:00 2024 PST | Mon Mar 11 00:00:00 2024 PDT | @ 6 days 23 hours | t
 Sun Mar 10 01:59:59 2024 PST | @ 1 hour | Sun Mar 10 01:00:00 2024 PST | Sun Mar 10 03:00:00 2024 PDT | @ 1 hour          | t
 Sun Mar 10 01:59:59 2024 PST | @ 1 day  | Sun Mar 10 00:00:00 2024 PST | Mon Mar 11 00:00:00 2024 PDT | @ 23 hours        | t
 Sun Mar 10 01:59:59 2024 PST | @ 7 days | Mon Mar 04 00:00:00 2024 PST | Mon Mar 11 00:00:00 2024 PDT | @ 6 days 23 hours | t
 Sun Mar 10 03:00:00 2024 PDT | @ 1 hour | Sun Mar 10 03:00:00 2024 PDT | Sun Mar 10 04:00:00 2024 PDT | @ 1 hour          | t
 Sun Mar 10 03:00:00 2024 PDT | @ 1 day  | Sun Mar 10 00:00:00 2024 PST | Mon Mar 11 00:00:00 2024 PDT | @ 23 hours        | t
 Sun Mar 10 03:00:00 2024 PDT | @ 7 days | Mon Mar 04 00:00:00 2024 PST | Mon Mar 11 00:00:00 2024 PDT | @ 6 days 23 hours | t
 Mon Mar 11 00:00:00 2024 PDT | @ 1 hour | Mon Mar 11 00:00:00 2024 PDT | Mon Mar 11 01:00:00 2024 PDT | @ 1 hour          | t
 Mon Mar 11 00:00:00 2024 PDT | @ 1 day  | Mon Mar 11 00:00:00 2024 PDT | Tue Mar 12 00:00:00 2024 PDT | @ 1 day           | t
 Mon Mar 11 00:00:00 2024 PDT | @ 7 days | Mon Mar 11 00:00:00 2024 PDT | Mon Mar 18 00:00:00 2024 PDT | @ 7 days          | t

-- America/Los_Angeles DST fall back (Nov 3)
SELECT * FROM test_ranges(
    ARRAY[
        '2024-11-02 23:59:59 America/Los_Angeles'::timestamptz,
        '2024-11-03 00:00:00 America/Los_Angeles',
        '2024-11-03 01:30:00 PDT',  -- first 1:30 AM
        '2024-11-03 01:30:00 PST',  -- second 1:30 AM
        '2024-11-03 02:00:00 America/Los_Angeles'
    ],
    ARRAY['1 hour'::interval, '1 day']
);
              ts              |   inv    |           start_ts           |            end_ts            |      dur       | in_range 
------------------------------+----------+------------------------------+------------------------------+----------------+----------
 Sat Nov 02 23:59:59 2024 PDT | @ 1 hour | Sat Nov 02 23:00:00 2024 PDT | Sun Nov 03 00:00:00 2024 PDT | @ 1 hour       | t
 Sat Nov 02 23:59:59 2024 PDT | @ 1 day  | Sat Nov 02 00:00:00 2024 PDT | Sun Nov 03 00:00:00 2024 PDT | @ 1 day        | t
 Sun Nov 03 00:00:00 2024 PDT | @ 1 hour | Sun Nov 03 00:00:00 2024 PDT | Sun Nov 03 01:00:00 2024 PDT | @ 1 hour       | t
 Sun Nov 03 00:00:00 2024 PDT | @ 1 day  | Sun Nov 03 00:00:00 2024 PDT | Mon Nov 04 00:00:00 2024 PST | @ 1 day 1 hour | t
 Sun Nov 03 01:30:00 2024 PDT | @ 1 hour | Sun Nov 03 01:00:00 2024 PDT | Sun Nov 03 01:00:00 2024 PST | @ 1 hour       | t
 Sun Nov 03 01:30:00 2024 PDT | @ 1 day  | Sun Nov 03 00:00:00 2024 PDT | Mon Nov 04 00:00:00 2024 PST | @ 1 day 1 hour | t
 Sun Nov 03 01:30:00 2024 PST | @ 1 hour | Sun Nov 03 01:00:00 2024 PST | Sun Nov 03 02:00:00 2024 PST | @ 1 hour       | t
 Sun Nov 03 01:30:00 2024 PST | @ 1 day  | Sun Nov 03 00:00:00 2024 PDT | Mon Nov 04 00:00:00 2024 PST | @ 1 day 1 hour | t
 Sun Nov 03 02:00:00 2024 PST | @ 1 hour | Sun Nov 03 02:00:00 2024 PST | Sun Nov 03 03:00:00 2024 PST | @ 1 hour       | t
 Sun Nov 03 02:00:00 2024 PST | @ 1 day  | Sun Nov 03 00:00:00 2024 PDT | Mon Nov 04 00:00:00 2024 PST | @ 1 day 1 hour | t

-- Europe/London DST
SET timezone = 'Europe/London';
SELECT * FROM test_ranges(
    ARRAY[
        '2024-03-31 00:59:59 Europe/London'::timestamptz,  -- before spring forward
        '2024-03-31 02:00:00 Europe/London',  -- after spring forward
        '2024-10-27 01:30:00 BST',  -- before fall back
        '2024-10-27 01:30:00 GMT'   -- after fall back
    ],
    ARRAY['1 hour'::interval, '1 day']
);
              ts              |   inv    |           start_ts           |            end_ts            |      dur       | in_range 
------------------------------+----------+------------------------------+------------------------------+----------------+----------
 Sun Mar 31 00:59:59 2024 GMT | @ 1 hour | Sun Mar 31 00:00:00 2024 GMT | Sun Mar 31 02:00:00 2024 BST | @ 1 hour       | t
 Sun Mar 31 00:59:59 2024 GMT | @ 1 day  | Sun Mar 31 00:00:00 2024 GMT | Mon Apr 01 00:00:00 2024 BST | @ 23 hours     | t
 Sun Mar 31 02:00:00 2024 BST | @ 1 hour | Sun Mar 31 02:00:00 2024 BST | Sun Mar 31 03:00:00 2024 BST | @ 1 hour       | t
 Sun Mar 31 02:00:00 2024 BST | @ 1 day  | Sun Mar 31 00:00:00 2024 GMT | Mon Apr 01 00:00:00 2024 BST | @ 23 hours     | t
 Sun Oct 27 01:30:00 2024 BST | @ 1 hour | Sun Oct 27 01:00:00 2024 BST | Sun Oct 27 01:00:00 2024 GMT | @ 1 hour       | t
 Sun Oct 27 01:30:00 2024 BST | @ 1 day  | Sun Oct 27 00:00:00 2024 BST | Mon Oct 28 00:00:00 2024 GMT | @ 1 day 1 hour | t
 Sun Oct 27 01:30:00 2024 GMT | @ 1 hour | Sun Oct 27 01:00:00 2024 GMT | Sun Oct 27 02:00:00 2024 GMT | @ 1 hour       | t
 Sun Oct 27 01:30:00 2024 GMT | @ 1 day  | Sun Oct 27 00:00:00 2024 BST | Mon Oct 28 00:00:00 2024 GMT | @ 1 day 1 hour | t

-- Use a timezone with 45-minute offset for hypertable tests
SET timezone = 'Pacific/Chatham';
---------------------------------------------------------------
-- HYPERTABLE TESTS: UUID v7
---------------------------------------------------------------
CREATE TABLE uuid_events(
    id uuid PRIMARY KEY,
    device_id int,
    temp float
);
SELECT create_hypertable('uuid_events', 'id', chunk_time_interval => interval '1 day');
    create_hypertable     
--------------------------
 (1,public,uuid_events,t)

-- UUIDs for known timestamps:
-- 2025-01-01 02:00 UTC, 2025-01-01 09:00 UTC
-- 2025-01-02 03:00 UTC, 2025-01-02 04:00 UTC
-- 2025-01-03 05:00 UTC, 2025-01-03 12:00 UTC
INSERT INTO uuid_events VALUES
    ('01942117-de80-7000-8121-f12b2b69dd96', 1, 1.0),
    ('0194214e-cd00-7000-a9a7-63f1416dab45', 2, 2.0),
    ('0194263e-3a80-7000-8f40-82c987b1bc1f', 3, 3.0),
    ('01942675-2900-7000-8db1-a98694b18785', 4, 4.0),
    ('01942bd2-7380-7000-9bc4-5f97443907b8', 5, 5.0),
    ('01942d52-f900-7000-866e-07d6404d53c1', 6, 6.0);
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks WHERE hypertable_name = 'uuid_events' ORDER BY range_start;
    chunk_name    |          range_start           |           range_end            
------------------+--------------------------------+--------------------------------
 _hyper_1_1_chunk | Wed Jan 01 00:00:00 2025 +1345 | Thu Jan 02 00:00:00 2025 +1345
 _hyper_1_2_chunk | Thu Jan 02 00:00:00 2025 +1345 | Fri Jan 03 00:00:00 2025 +1345
 _hyper_1_3_chunk | Sat Jan 04 00:00:00 2025 +1345 | Sun Jan 05 00:00:00 2025 +1345

DROP TABLE uuid_events;
---------------------------------------------------------------
-- HYPERTABLE TESTS: TIMESTAMPTZ
---------------------------------------------------------------
-- Daily chunks
CREATE TABLE tz_daily(time timestamptz NOT NULL, value int);
SELECT create_hypertable('tz_daily', 'time', chunk_time_interval => interval '1 day');
   create_hypertable   
-----------------------
 (2,public,tz_daily,t)

INSERT INTO tz_daily VALUES
    ('2025-01-01 00:00:00 UTC', 1),
    ('2025-01-01 23:59:59.999999 UTC', 2),
    ('2025-01-02 00:00:00 UTC', 3);
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks WHERE hypertable_name = 'tz_daily' ORDER BY range_start;
    chunk_name    |          range_start           |           range_end            
------------------+--------------------------------+--------------------------------
 _hyper_2_4_chunk | Wed Jan 01 00:00:00 2025 +1345 | Thu Jan 02 00:00:00 2025 +1345
 _hyper_2_5_chunk | Thu Jan 02 00:00:00 2025 +1345 | Fri Jan 03 00:00:00 2025 +1345

DROP TABLE tz_daily;
-- Weekly chunks
CREATE TABLE tz_weekly(time timestamptz NOT NULL, value int);
SELECT create_hypertable('tz_weekly', 'time', chunk_time_interval => interval '1 week');
   create_hypertable    
------------------------
 (3,public,tz_weekly,t)

INSERT INTO tz_weekly VALUES
    ('2025-01-06 00:00:00 UTC', 1),  -- Monday
    ('2025-01-12 23:59:59 UTC', 2),  -- Sunday
    ('2025-01-13 00:00:00 UTC', 3);  -- Monday (next week)
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks WHERE hypertable_name = 'tz_weekly' ORDER BY range_start;
    chunk_name    |          range_start           |           range_end            
------------------+--------------------------------+--------------------------------
 _hyper_3_6_chunk | Mon Jan 06 00:00:00 2025 +1345 | Mon Jan 13 00:00:00 2025 +1345
 _hyper_3_7_chunk | Mon Jan 13 00:00:00 2025 +1345 | Mon Jan 20 00:00:00 2025 +1345

DROP TABLE tz_weekly;
-- Monthly chunks
CREATE TABLE tz_monthly(time timestamptz NOT NULL, value int);
SELECT create_hypertable('tz_monthly', 'time', chunk_time_interval => interval '1 month');
    create_hypertable    
-------------------------
 (4,public,tz_monthly,t)

INSERT INTO tz_monthly VALUES
    ('2025-01-15 12:00:00 UTC', 1),
    ('2025-02-15 12:00:00 UTC', 2),
    ('2025-03-15 12:00:00 UTC', 3);
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks WHERE hypertable_name = 'tz_monthly' ORDER BY range_start;
    chunk_name     |          range_start           |           range_end            
-------------------+--------------------------------+--------------------------------
 _hyper_4_8_chunk  | Wed Jan 01 00:00:00 2025 +1345 | Sat Feb 01 00:00:00 2025 +1345
 _hyper_4_9_chunk  | Sat Feb 01 00:00:00 2025 +1345 | Sat Mar 01 00:00:00 2025 +1345
 _hyper_4_10_chunk | Sat Mar 01 00:00:00 2025 +1345 | Tue Apr 01 00:00:00 2025 +1345

DROP TABLE tz_monthly;
-- Yearly chunks
CREATE TABLE tz_yearly(time timestamptz NOT NULL, value int);
SELECT create_hypertable('tz_yearly', 'time', chunk_time_interval => interval '1 year');
   create_hypertable    
------------------------
 (5,public,tz_yearly,t)

INSERT INTO tz_yearly VALUES
    ('2024-06-15 12:00:00 UTC', 1),
    ('2025-06-15 12:00:00 UTC', 2);
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks WHERE hypertable_name = 'tz_yearly' ORDER BY range_start;
    chunk_name     |          range_start           |           range_end            
-------------------+--------------------------------+--------------------------------
 _hyper_5_11_chunk | Mon Jan 01 00:00:00 2024 +1345 | Wed Jan 01 00:00:00 2025 +1345
 _hyper_5_12_chunk | Wed Jan 01 00:00:00 2025 +1345 | Thu Jan 01 00:00:00 2026 +1345

DROP TABLE tz_yearly;
-- DST spring forward test: 23-hour chunk
-- America/New_York DST 2025: Mar 9 at 2:00 AM clocks spring forward to 3:00 AM
SET timezone = 'America/New_York';
CREATE TABLE tz_dst_spring(time timestamptz NOT NULL, value int);
SELECT create_hypertable('tz_dst_spring', 'time', chunk_time_interval => interval '1 day');
     create_hypertable      
----------------------------
 (6,public,tz_dst_spring,t)

INSERT INTO tz_dst_spring VALUES
    ('2025-03-08 12:00:00', 1),  -- day before DST (24 hours)
    ('2025-03-09 12:00:00', 2),  -- DST day (23 hours - spring forward)
    ('2025-03-10 12:00:00', 3);  -- day after DST (24 hours)
SELECT chunk_name, range_start, range_end,
       round(extract(epoch FROM (range_end - range_start)) / 3600, 1) AS hours
FROM timescaledb_information.chunks WHERE hypertable_name = 'tz_dst_spring' ORDER BY range_start;
    chunk_name     |         range_start          |          range_end           | hours 
-------------------+------------------------------+------------------------------+-------
 _hyper_6_13_chunk | Sat Mar 08 00:00:00 2025 EST | Sun Mar 09 00:00:00 2025 EST |  24.0
 _hyper_6_14_chunk | Sun Mar 09 00:00:00 2025 EST | Mon Mar 10 00:00:00 2025 EDT |  23.0
 _hyper_6_15_chunk | Mon Mar 10 00:00:00 2025 EDT | Tue Mar 11 00:00:00 2025 EDT |  24.0

DROP TABLE tz_dst_spring;
-- DST fall back test: 25-hour chunk
-- America/New_York 2024: Nov 3 at 2:00 AM clocks fall back to 1:00 AM
CREATE TABLE tz_dst_fall(time timestamptz NOT NULL, value int);
SELECT create_hypertable('tz_dst_fall', 'time', chunk_time_interval => interval '1 day');
    create_hypertable     
--------------------------
 (7,public,tz_dst_fall,t)

INSERT INTO tz_dst_fall VALUES
    ('2024-11-02 12:00:00', 1),  -- day before DST (24 hours)
    ('2024-11-03 12:00:00', 2),  -- DST day (25 hours - fall back)
    ('2024-11-04 12:00:00', 3);  -- day after DST (24 hours)
SELECT chunk_name, range_start, range_end,
       round(extract(epoch FROM (range_end - range_start)) / 3600, 1) AS hours
FROM timescaledb_information.chunks WHERE hypertable_name = 'tz_dst_fall' ORDER BY range_start;
    chunk_name     |         range_start          |          range_end           | hours 
-------------------+------------------------------+------------------------------+-------
 _hyper_7_16_chunk | Sat Nov 02 00:00:00 2024 EDT | Sun Nov 03 00:00:00 2024 EDT |  24.0
 _hyper_7_17_chunk | Sun Nov 03 00:00:00 2024 EDT | Mon Nov 04 00:00:00 2024 EST |  25.0
 _hyper_7_18_chunk | Mon Nov 04 00:00:00 2024 EST | Tue Nov 05 00:00:00 2024 EST |  24.0

DROP TABLE tz_dst_fall;
-- Same test in UTC - all chunks should be exactly 24 hours
SET timezone = 'UTC';
CREATE TABLE tz_utc(time timestamptz NOT NULL, value int);
SELECT create_hypertable('tz_utc', 'time', chunk_time_interval => interval '1 day');
  create_hypertable  
---------------------
 (8,public,tz_utc,t)

INSERT INTO tz_utc VALUES
    ('2025-03-08 12:00:00', 1),
    ('2025-03-09 12:00:00', 2),
    ('2025-03-10 12:00:00', 3);
-- All chunks are 24 hours in UTC (no DST)
SELECT chunk_name, range_start, range_end,
       round(extract(epoch FROM (range_end - range_start)) / 3600, 1) AS hours
FROM timescaledb_information.chunks WHERE hypertable_name = 'tz_utc' ORDER BY range_start;
    chunk_name     |         range_start          |          range_end           | hours 
-------------------+------------------------------+------------------------------+-------
 _hyper_8_19_chunk | Sat Mar 08 00:00:00 2025 UTC | Sun Mar 09 00:00:00 2025 UTC |  24.0
 _hyper_8_20_chunk | Sun Mar 09 00:00:00 2025 UTC | Mon Mar 10 00:00:00 2025 UTC |  24.0
 _hyper_8_21_chunk | Mon Mar 10 00:00:00 2025 UTC | Tue Mar 11 00:00:00 2025 UTC |  24.0

DROP TABLE tz_utc;
-- Create in UTC, then switch to DST timezone
-- Origin is UTC midnight, but chunk duration depends on session timezone when chunk is created
SET timezone = 'UTC';
CREATE TABLE tz_utc_then_dst(time timestamptz NOT NULL, value int);
SELECT create_hypertable('tz_utc_then_dst', 'time', chunk_time_interval => interval '1 day');
      create_hypertable       
------------------------------
 (9,public,tz_utc_then_dst,t)

-- Now switch to NY and insert around DST transition
SET timezone = 'America/New_York';
INSERT INTO tz_utc_then_dst VALUES
    ('2025-03-08 12:00:00', 1),
    ('2025-03-09 12:00:00', 2),
    ('2025-03-10 12:00:00', 3);
-- Chunks are 23 hours around DST because interval addition uses session timezone
SELECT chunk_name, range_start, range_end,
       round(extract(epoch FROM (range_end - range_start)) / 3600, 1) AS hours
FROM timescaledb_information.chunks WHERE hypertable_name = 'tz_utc_then_dst' ORDER BY range_start;
    chunk_name     |         range_start          |          range_end           | hours 
-------------------+------------------------------+------------------------------+-------
 _hyper_9_22_chunk | Fri Mar 07 19:00:00 2025 EST | Sat Mar 08 19:00:00 2025 EST |  24.0
 _hyper_9_23_chunk | Sat Mar 08 19:00:00 2025 EST | Sun Mar 09 19:00:00 2025 EDT |  23.0
 _hyper_9_24_chunk | Sun Mar 09 19:00:00 2025 EDT | Mon Mar 10 19:00:00 2025 EDT |  24.0

-- Now change origin to local timezone (NY) midnight
-- This means new chunks will align to NY midnight instead of UTC midnight
SELECT set_chunk_time_interval('tz_utc_then_dst', interval '1 day',
    chunk_time_origin => '2001-01-01 00:00:00 America/New_York'::timestamptz);
 set_chunk_time_interval 
-------------------------
 

-- Insert data that creates chunks aligned to NY midnight (not UTC midnight)
-- These chunks should align to local midnight
INSERT INTO tz_utc_then_dst VALUES
    ('2025-03-15 12:00:00', 4),  -- New chunk aligned to NY midnight
    ('2025-03-16 12:00:00', 5);  -- Another new chunk
-- Show all chunks - old ones aligned to UTC, new ones aligned to NY
SELECT chunk_name, range_start, range_end,
       round(extract(epoch FROM (range_end - range_start)) / 3600, 1) AS hours
FROM timescaledb_information.chunks WHERE hypertable_name = 'tz_utc_then_dst' ORDER BY range_start;
    chunk_name     |         range_start          |          range_end           | hours 
-------------------+------------------------------+------------------------------+-------
 _hyper_9_22_chunk | Fri Mar 07 19:00:00 2025 EST | Sat Mar 08 19:00:00 2025 EST |  24.0
 _hyper_9_23_chunk | Sat Mar 08 19:00:00 2025 EST | Sun Mar 09 19:00:00 2025 EDT |  23.0
 _hyper_9_24_chunk | Sun Mar 09 19:00:00 2025 EDT | Mon Mar 10 19:00:00 2025 EDT |  24.0
 _hyper_9_25_chunk | Sat Mar 15 00:00:00 2025 EDT | Sun Mar 16 00:00:00 2025 EDT |  24.0
 _hyper_9_26_chunk | Sun Mar 16 00:00:00 2025 EDT | Mon Mar 17 00:00:00 2025 EDT |  24.0

-- Now insert data that falls into the gap between old UTC-aligned and new NY-aligned chunks
-- This chunk will be "cut" to fit between existing chunks
INSERT INTO tz_utc_then_dst VALUES ('2025-03-10 23:00:00', 6);  -- Between existing chunks
-- Show all chunks with range size - the transition chunk should be smaller
SELECT chunk_name, range_start, range_end,
       round(extract(epoch FROM (range_end - range_start)) / 3600, 1) AS hours
FROM timescaledb_information.chunks WHERE hypertable_name = 'tz_utc_then_dst' ORDER BY range_start;
    chunk_name     |         range_start          |          range_end           | hours 
-------------------+------------------------------+------------------------------+-------
 _hyper_9_22_chunk | Fri Mar 07 19:00:00 2025 EST | Sat Mar 08 19:00:00 2025 EST |  24.0
 _hyper_9_23_chunk | Sat Mar 08 19:00:00 2025 EST | Sun Mar 09 19:00:00 2025 EDT |  23.0
 _hyper_9_24_chunk | Sun Mar 09 19:00:00 2025 EDT | Mon Mar 10 19:00:00 2025 EDT |  24.0
 _hyper_9_27_chunk | Mon Mar 10 19:00:00 2025 EDT | Tue Mar 11 00:00:00 2025 EDT |   5.0
 _hyper_9_25_chunk | Sat Mar 15 00:00:00 2025 EDT | Sun Mar 16 00:00:00 2025 EDT |  24.0
 _hyper_9_26_chunk | Sun Mar 16 00:00:00 2025 EDT | Mon Mar 17 00:00:00 2025 EDT |  24.0

DROP TABLE tz_utc_then_dst;
-- Reset to Chatham for remaining tests
SET timezone = 'Pacific/Chatham';
---------------------------------------------------------------
-- HYPERTABLE TESTS: TIMESTAMP (without timezone)
---------------------------------------------------------------
CREATE TABLE ts_monthly(time timestamp NOT NULL, value int);
SELECT create_hypertable('ts_monthly', 'time', chunk_time_interval => interval '1 month');
WARNING:  column type "timestamp without time zone" used for "time" does not follow best practices
    create_hypertable     
--------------------------
 (10,public,ts_monthly,t)

INSERT INTO ts_monthly VALUES
    ('2025-01-15 12:00:00', 1),
    ('2025-02-15 12:00:00', 2),
    ('2025-03-15 12:00:00', 3);
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks WHERE hypertable_name = 'ts_monthly' ORDER BY range_start;
     chunk_name     |          range_start           |           range_end            
--------------------+--------------------------------+--------------------------------
 _hyper_10_28_chunk | Wed Jan 01 13:45:00 2025 +1345 | Sat Feb 01 13:45:00 2025 +1345
 _hyper_10_29_chunk | Sat Feb 01 13:45:00 2025 +1345 | Sat Mar 01 13:45:00 2025 +1345
 _hyper_10_30_chunk | Sat Mar 01 13:45:00 2025 +1345 | Tue Apr 01 13:45:00 2025 +1345

DROP TABLE ts_monthly;
---------------------------------------------------------------
-- HYPERTABLE TESTS: DATE
---------------------------------------------------------------
CREATE TABLE date_monthly(day date NOT NULL, value int);
SELECT create_hypertable('date_monthly', 'day', chunk_time_interval => interval '1 month');
     create_hypertable      
----------------------------
 (11,public,date_monthly,t)

INSERT INTO date_monthly VALUES
    ('2025-01-15', 1),
    ('2025-02-15', 2),
    ('2025-03-15', 3);
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks WHERE hypertable_name = 'date_monthly' ORDER BY range_start;
     chunk_name     |          range_start           |           range_end            
--------------------+--------------------------------+--------------------------------
 _hyper_11_31_chunk | Wed Jan 01 13:45:00 2025 +1345 | Sat Feb 01 13:45:00 2025 +1345
 _hyper_11_32_chunk | Sat Feb 01 13:45:00 2025 +1345 | Sat Mar 01 13:45:00 2025 +1345
 _hyper_11_33_chunk | Sat Mar 01 13:45:00 2025 +1345 | Tue Apr 01 13:45:00 2025 +1345

DROP TABLE date_monthly;
---------------------------------------------------------------
-- CUSTOM ORIGIN TESTS
---------------------------------------------------------------
-- Fiscal year starting July 1
CREATE TABLE fiscal_year(time timestamptz NOT NULL, value int);
SELECT create_hypertable('fiscal_year',
    by_range('time', interval '1 year', partition_origin => '2020-07-01 00:00:00 UTC'::timestamptz));
 create_hypertable 
-------------------
 (12,t)

INSERT INTO fiscal_year VALUES
    ('2024-06-30 23:59:59 UTC', 1),  -- FY2024
    ('2024-07-01 00:00:00 UTC', 2),  -- FY2025
    ('2025-06-30 23:59:59 UTC', 3);  -- FY2025
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks WHERE hypertable_name = 'fiscal_year' ORDER BY range_start;
     chunk_name     |          range_start           |           range_end            
--------------------+--------------------------------+--------------------------------
 _hyper_12_34_chunk | Sat Jul 01 12:45:00 2023 +1245 | Mon Jul 01 12:45:00 2024 +1245
 _hyper_12_35_chunk | Mon Jul 01 12:45:00 2024 +1245 | Tue Jul 01 12:45:00 2025 +1245

DROP TABLE fiscal_year;
-- Quarters starting April 1
CREATE TABLE fiscal_quarter(time timestamptz NOT NULL, value int);
SELECT create_hypertable('fiscal_quarter',
    by_range('time', interval '3 months', partition_origin => '2024-04-01 00:00:00 UTC'::timestamptz));
 create_hypertable 
-------------------
 (13,t)

INSERT INTO fiscal_quarter VALUES
    ('2024-03-31 23:59:59 UTC', 1),  -- Q4 FY2024
    ('2024-04-01 00:00:00 UTC', 2),  -- Q1 FY2025
    ('2024-07-01 00:00:00 UTC', 3),  -- Q2 FY2025
    ('2024-10-01 00:00:00 UTC', 4);  -- Q3 FY2025
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks WHERE hypertable_name = 'fiscal_quarter' ORDER BY range_start;
     chunk_name     |          range_start           |           range_end            
--------------------+--------------------------------+--------------------------------
 _hyper_13_36_chunk | Mon Jan 01 13:45:00 2024 +1345 | Mon Apr 01 13:45:00 2024 +1345
 _hyper_13_37_chunk | Mon Apr 01 13:45:00 2024 +1345 | Mon Jul 01 13:45:00 2024 +1245
 _hyper_13_38_chunk | Tue Oct 01 13:45:00 2024 +1345 | Wed Jan 01 13:45:00 2025 +1345

DROP TABLE fiscal_quarter;
-- Days starting at noon
CREATE TABLE noon_days(time timestamptz NOT NULL, value int);
SELECT create_hypertable('noon_days', 'time',
    chunk_time_interval => interval '1 day',
    chunk_time_origin => '2024-06-01 12:00:00 UTC'::timestamptz);
    create_hypertable    
-------------------------
 (14,public,noon_days,t)

INSERT INTO noon_days VALUES
    ('2024-06-01 00:00:00 UTC', 1),
    ('2024-06-01 11:59:59 UTC', 2),
    ('2024-06-01 12:00:00 UTC', 3),
    ('2024-06-02 11:59:59 UTC', 4);
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks WHERE hypertable_name = 'noon_days' ORDER BY range_start;
     chunk_name     |          range_start           |           range_end            
--------------------+--------------------------------+--------------------------------
 _hyper_14_39_chunk | Sat Jun 01 00:45:00 2024 +1245 | Sun Jun 02 00:45:00 2024 +1245
 _hyper_14_40_chunk | Sun Jun 02 00:45:00 2024 +1245 | Mon Jun 03 00:45:00 2024 +1245

DROP TABLE noon_days;
-- Partitioning function with interval and origin (int epoch seconds to timestamptz)
CREATE OR REPLACE FUNCTION epoch_sec_to_timestamptz(epoch_sec int)
RETURNS timestamptz LANGUAGE SQL IMMUTABLE AS $$
    SELECT to_timestamp(epoch_sec);
$$;
CREATE TABLE events_epoch(epoch_sec int NOT NULL, value int);
SELECT create_hypertable('events_epoch',
    by_range('epoch_sec', interval '1 month',
             partition_func => 'epoch_sec_to_timestamptz',
             partition_origin => '2024-07-01 00:00:00 UTC'::timestamptz));
 create_hypertable 
-------------------
 (15,t)

-- Epoch values in seconds:
-- 2024-06-30 23:59:59 UTC = 1719791999
-- 2024-07-01 00:00:00 UTC = 1719792000
-- 2024-07-15 12:00:00 UTC = 1721044800
-- 2024-08-01 00:00:00 UTC = 1722470400
INSERT INTO events_epoch VALUES
    (1719791999, 1),
    (1719792000, 2),
    (1721044800, 3),
    (1722470400, 4);
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks WHERE hypertable_name = 'events_epoch' ORDER BY range_start;
     chunk_name     | range_start | range_end 
--------------------+-------------+-----------
 _hyper_15_41_chunk |             | 
 _hyper_15_42_chunk |             | 
 _hyper_15_43_chunk |             | 

DROP TABLE events_epoch;
DROP FUNCTION epoch_sec_to_timestamptz(int);
---------------------------------------------------------------
-- ADD_DIMENSION TESTS
---------------------------------------------------------------
-- Test add_dimension() with origin parameter (deprecated API)
-- Add a time dimension to a table with integer primary dimension
CREATE TABLE add_dim_old_api(id int NOT NULL, time timestamptz NOT NULL, value int);
SELECT create_hypertable('add_dim_old_api', 'id', chunk_time_interval => 100);
       create_hypertable       
-------------------------------
 (16,public,add_dim_old_api,t)

SELECT add_dimension('add_dim_old_api', 'time',
    chunk_time_interval => interval '1 month',
    chunk_time_origin => '2024-04-01 00:00:00 UTC'::timestamptz);
           add_dimension            
------------------------------------
 (17,public,add_dim_old_api,time,t)

INSERT INTO add_dim_old_api VALUES
    (1, '2024-03-31 23:59:59 UTC', 1),  -- March (before origin month)
    (1, '2024-04-15 12:00:00 UTC', 2),  -- April
    (1, '2024-05-15 12:00:00 UTC', 3);  -- May
-- Verify the origin was stored correctly in the dimension
SELECT d.column_name,
       _timescaledb_functions.to_timestamp(d.interval_origin) AS origin
FROM _timescaledb_catalog.dimension d
JOIN _timescaledb_catalog.hypertable h ON d.hypertable_id = h.id
WHERE h.table_name = 'add_dim_old_api' AND d.column_name = 'time';
 column_name |             origin             
-------------+--------------------------------
 time        | Mon Apr 01 13:45:00 2024 +1345

DROP TABLE add_dim_old_api;
-- Test add_dimension() with by_range and partition_origin (new API)
CREATE TABLE add_dim_new_api(id int NOT NULL, time timestamptz NOT NULL, value int);
SELECT create_hypertable('add_dim_new_api', 'id', chunk_time_interval => 100);
       create_hypertable       
-------------------------------
 (17,public,add_dim_new_api,t)

SELECT add_dimension('add_dim_new_api',
    by_range('time', interval '3 months', partition_origin => '2024-07-01 00:00:00 UTC'::timestamptz));
 add_dimension 
---------------
 (19,t)

INSERT INTO add_dim_new_api VALUES
    (1, '2024-06-30 23:59:59 UTC', 1),  -- Q2 (before origin)
    (1, '2024-07-01 00:00:00 UTC', 2),  -- Q3 (at origin)
    (1, '2024-10-01 00:00:00 UTC', 3);  -- Q4
-- Verify the origin was stored correctly
SELECT d.column_name,
       _timescaledb_functions.to_timestamp(d.interval_origin) AS origin
FROM _timescaledb_catalog.dimension d
JOIN _timescaledb_catalog.hypertable h ON d.hypertable_id = h.id
WHERE h.table_name = 'add_dim_new_api' AND d.column_name = 'time';
 column_name |             origin             
-------------+--------------------------------
 time        | Mon Jul 01 12:45:00 2024 +1245

DROP TABLE add_dim_new_api;
---------------------------------------------------------------
-- SET_CHUNK_TIME_INTERVAL TESTS
---------------------------------------------------------------
-- Test set_chunk_time_interval() with origin parameter
SET timezone = 'UTC';
CREATE TABLE set_interval_test(time timestamptz NOT NULL, value int);
SELECT create_hypertable('set_interval_test', 'time', chunk_time_interval => interval '1 day');
        create_hypertable        
---------------------------------
 (18,public,set_interval_test,t)

-- Insert to create initial chunk aligned to default origin (midnight)
INSERT INTO set_interval_test VALUES ('2024-06-15 12:00:00 UTC', 1);
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks WHERE hypertable_name = 'set_interval_test' ORDER BY range_start;
     chunk_name     |         range_start          |          range_end           
--------------------+------------------------------+------------------------------
 _hyper_18_50_chunk | Sat Jun 15 00:00:00 2024 UTC | Sun Jun 16 00:00:00 2024 UTC

-- Verify current origin (default: 2001-01-01 midnight)
SELECT d.column_name,
       _timescaledb_functions.to_timestamp(d.interval_origin) AS origin
FROM _timescaledb_catalog.dimension d
JOIN _timescaledb_catalog.hypertable h ON d.hypertable_id = h.id
WHERE h.table_name = 'set_interval_test';
 column_name |            origin            
-------------+------------------------------
 time        | Mon Jan 01 00:00:00 2001 UTC

-- Verify calendar chunking is still enabled
SHOW timescaledb.enable_calendar_chunking;
 timescaledb.enable_calendar_chunking 
--------------------------------------
 on

-- Change interval and origin to noon
SELECT set_chunk_time_interval('set_interval_test', interval '1 day', chunk_time_origin => '2024-01-01 12:00:00 UTC'::timestamptz);
 set_chunk_time_interval 
-------------------------
 

-- Verify the origin was updated to noon
SELECT d.column_name,
       _timescaledb_functions.to_timestamp(d.interval_origin) AS origin
FROM _timescaledb_catalog.dimension d
JOIN _timescaledb_catalog.hypertable h ON d.hypertable_id = h.id
WHERE h.table_name = 'set_interval_test';
 column_name |            origin            
-------------+------------------------------
 time        | Mon Jan 01 12:00:00 2024 UTC

-- Insert to create transition chunk from midnight to noon
-- This data falls after the existing chunk's end (June 16 00:00) but before
-- the next noon boundary (June 16 12:00), creating a 12-hour transition chunk
INSERT INTO set_interval_test VALUES ('2024-06-16 06:00:00 UTC', 2);
-- Insert to create new chunk aligned to noon origin
INSERT INTO set_interval_test VALUES ('2024-07-15 18:00:00 UTC', 3);
-- Old chunk starts at midnight, transition chunk is 12 hours, new chunk starts at noon
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks WHERE hypertable_name = 'set_interval_test' ORDER BY range_start;
     chunk_name     |         range_start          |          range_end           
--------------------+------------------------------+------------------------------
 _hyper_18_50_chunk | Sat Jun 15 00:00:00 2024 UTC | Sun Jun 16 00:00:00 2024 UTC
 _hyper_18_51_chunk | Sun Jun 16 00:00:00 2024 UTC | Sun Jun 16 12:00:00 2024 UTC
 _hyper_18_52_chunk | Mon Jul 15 12:00:00 2024 UTC | Tue Jul 16 12:00:00 2024 UTC

DROP TABLE set_interval_test;
-- Test set_chunk_time_interval() changing from days to months with fiscal origin
CREATE TABLE set_interval_fiscal(time timestamptz NOT NULL, value int);
SELECT create_hypertable('set_interval_fiscal', 'time', chunk_time_interval => interval '1 day');
         create_hypertable         
-----------------------------------
 (19,public,set_interval_fiscal,t)

-- Insert initial data
INSERT INTO set_interval_fiscal VALUES ('2024-06-15 12:00:00 UTC', 1);
-- Change to monthly interval with fiscal year origin (July 1)
SELECT set_chunk_time_interval('set_interval_fiscal', interval '1 month', chunk_time_origin => '2024-07-01 00:00:00 UTC'::timestamptz);
 set_chunk_time_interval 
-------------------------
 

-- Verify the origin was updated
SELECT d.column_name,
       _timescaledb_functions.to_timestamp(d.interval_origin) AS origin
FROM _timescaledb_catalog.dimension d
JOIN _timescaledb_catalog.hypertable h ON d.hypertable_id = h.id
WHERE h.table_name = 'set_interval_fiscal';
 column_name |            origin            
-------------+------------------------------
 time        | Mon Jul 01 00:00:00 2024 UTC

-- Insert more data to create monthly chunks aligned to fiscal year
INSERT INTO set_interval_fiscal VALUES
    ('2024-07-15 12:00:00 UTC', 2),
    ('2024-08-15 12:00:00 UTC', 3);
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks WHERE hypertable_name = 'set_interval_fiscal' ORDER BY range_start;
     chunk_name     |         range_start          |          range_end           
--------------------+------------------------------+------------------------------
 _hyper_19_53_chunk | Sat Jun 15 00:00:00 2024 UTC | Sun Jun 16 00:00:00 2024 UTC
 _hyper_19_54_chunk | Mon Jul 01 00:00:00 2024 UTC | Thu Aug 01 00:00:00 2024 UTC
 _hyper_19_55_chunk | Thu Aug 01 00:00:00 2024 UTC | Sun Sep 01 00:00:00 2024 UTC

DROP TABLE set_interval_fiscal;
-- Reset timezone
SET timezone = 'Pacific/Chatham';
---------------------------------------------------------------
-- COMPARISON: CALENDAR VS NON-CALENDAR CHUNKING
---------------------------------------------------------------
-- Show what the UTC values look like in Chatham time zone
-- Chatham is UTC+13:45 in January (daylight saving), so noon UTC is 01:45 next day
SELECT '2025-01-01 12:00:00 UTC'::timestamptz AS "UTC noon Jan 1",
       '2025-01-02 12:00:00 UTC'::timestamptz AS "UTC noon Jan 2";
         UTC noon Jan 1         |         UTC noon Jan 2         
--------------------------------+--------------------------------
 Thu Jan 02 01:45:00 2025 +1345 | Fri Jan 03 01:45:00 2025 +1345

-- Non-calendar chunking
SET timescaledb.enable_calendar_chunking = false;
CREATE TABLE non_calendar(time timestamptz NOT NULL, value int);
SELECT create_hypertable('non_calendar', 'time', chunk_time_interval => interval '1 day');
     create_hypertable      
----------------------------
 (20,public,non_calendar,t)

INSERT INTO non_calendar VALUES
    ('2025-01-01 12:00:00 UTC', 1),
    ('2025-01-02 12:00:00 UTC', 2);
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks WHERE hypertable_name = 'non_calendar' ORDER BY range_start;
     chunk_name     |          range_start           |           range_end            
--------------------+--------------------------------+--------------------------------
 _hyper_20_56_chunk | Wed Jan 01 13:45:00 2025 +1345 | Thu Jan 02 13:45:00 2025 +1345
 _hyper_20_57_chunk | Thu Jan 02 13:45:00 2025 +1345 | Fri Jan 03 13:45:00 2025 +1345

DROP TABLE non_calendar;
-- Calendar chunking
SET timescaledb.enable_calendar_chunking = true;
CREATE TABLE calendar(time timestamptz NOT NULL, value int);
SELECT create_hypertable('calendar', 'time', chunk_time_interval => interval '1 day');
   create_hypertable    
------------------------
 (21,public,calendar,t)

INSERT INTO calendar VALUES
    ('2025-01-01 12:00:00 UTC', 1),
    ('2025-01-02 12:00:00 UTC', 2);
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks WHERE hypertable_name = 'calendar' ORDER BY range_start;
     chunk_name     |          range_start           |           range_end            
--------------------+--------------------------------+--------------------------------
 _hyper_21_58_chunk | Thu Jan 02 00:00:00 2025 +1345 | Fri Jan 03 00:00:00 2025 +1345
 _hyper_21_59_chunk | Fri Jan 03 00:00:00 2025 +1345 | Sat Jan 04 00:00:00 2025 +1345

DROP TABLE calendar;
---------------------------------------------------------------
-- SET_CHUNK_TIME_INTERVAL WITH NON-INTERVAL TYPE
---------------------------------------------------------------
-- Test that passing integer (microseconds) instead of Interval
-- to set_chunk_time_interval() on a calendar-based hypertable errors.
SET timezone = 'UTC';
SET timescaledb.enable_calendar_chunking = true;
CREATE TABLE calendar_no_integer(time timestamptz NOT NULL, value int);
SELECT create_hypertable('calendar_no_integer', 'time', chunk_time_interval => interval '1 day');
         create_hypertable         
-----------------------------------
 (22,public,calendar_no_integer,t)

-- Verify calendar chunking is active
SELECT d.column_name,
       d.interval IS NOT NULL AS has_interval
FROM _timescaledb_catalog.dimension d
JOIN _timescaledb_catalog.hypertable h ON d.hypertable_id = h.id
WHERE h.table_name = 'calendar_no_integer';
 column_name | has_interval 
-------------+--------------
 time        | t

-- Try to change to integer interval - this should error
\set ON_ERROR_STOP 0
SELECT set_chunk_time_interval('calendar_no_integer', 86400000000::bigint);
ERROR:  cannot use integer interval on calendar-based hypertable
\set ON_ERROR_STOP 1
-- Verify calendar chunking is still active (unchanged)
SELECT d.column_name,
       d.interval IS NOT NULL AS has_interval
FROM _timescaledb_catalog.dimension d
JOIN _timescaledb_catalog.hypertable h ON d.hypertable_id = h.id
WHERE h.table_name = 'calendar_no_integer';
 column_name | has_interval 
-------------+--------------
 time        | t

-- But changing to another Interval value should work
SELECT set_chunk_time_interval('calendar_no_integer', interval '1 week');
 set_chunk_time_interval 
-------------------------
 

SELECT d.column_name,
       d.interval
FROM _timescaledb_catalog.dimension d
JOIN _timescaledb_catalog.hypertable h ON d.hypertable_id = h.id
WHERE h.table_name = 'calendar_no_integer';
 column_name | interval 
-------------+----------
 time        | @ 7 days

DROP TABLE calendar_no_integer;
---------------------------------------------------------------
-- GUC CHANGE AFTER HYPERTABLE CREATION
-- Test that chunking mode is sticky (doesn't change with GUC)
-- Test all combinations of:
--   - Hypertable type: calendar vs non-calendar
--   - GUC state: ON vs OFF
--   - Interval input: INTERVAL vs integer
---------------------------------------------------------------
SET timezone = 'UTC';
---------------------------------------------------------------
-- NON-CALENDAR HYPERTABLE TESTS
-- Created with calendar_chunking = OFF
-- Should stay non-calendar regardless of GUC or input type
---------------------------------------------------------------
SET timescaledb.enable_calendar_chunking = false;
CREATE TABLE non_calendar_ht(time timestamptz NOT NULL, value int);
SELECT create_hypertable('non_calendar_ht', 'time', chunk_time_interval => interval '1 day');
       create_hypertable       
-------------------------------
 (23,public,non_calendar_ht,t)

-- Verify initial state: non-calendar mode (interval_length > 0, interval IS NULL)
SELECT d.column_name,
       d.interval_length,
       d.interval IS NULL AS interval_is_null
FROM _timescaledb_catalog.dimension d
JOIN _timescaledb_catalog.hypertable h ON d.hypertable_id = h.id
WHERE h.table_name = 'non_calendar_ht';
 column_name | interval_length | interval_is_null 
-------------+-----------------+------------------
 time        |     86400000000 | t

-- GUC OFF + integer input  stays non-calendar
SET timescaledb.enable_calendar_chunking = false;
SELECT set_chunk_time_interval('non_calendar_ht', 172800000000::bigint);  -- 2 days in microseconds
 set_chunk_time_interval 
-------------------------
 

SELECT d.interval_length,
       d.interval IS NULL AS interval_is_null
FROM _timescaledb_catalog.dimension d
JOIN _timescaledb_catalog.hypertable h ON d.hypertable_id = h.id
WHERE h.table_name = 'non_calendar_ht';
 interval_length | interval_is_null 
-----------------+------------------
    172800000000 | t

-- GUC OFF + INTERVAL input  stays non-calendar (converted to microseconds)
SET timescaledb.enable_calendar_chunking = false;
SELECT set_chunk_time_interval('non_calendar_ht', interval '3 days');
 set_chunk_time_interval 
-------------------------
 

SELECT d.interval_length,
       d.interval IS NULL AS interval_is_null
FROM _timescaledb_catalog.dimension d
JOIN _timescaledb_catalog.hypertable h ON d.hypertable_id = h.id
WHERE h.table_name = 'non_calendar_ht';
 interval_length | interval_is_null 
-----------------+------------------
    259200000000 | t

-- GUC ON + integer input  stays non-calendar
SET timescaledb.enable_calendar_chunking = true;
SELECT set_chunk_time_interval('non_calendar_ht', 345600000000::bigint);  -- 4 days in microseconds
 set_chunk_time_interval 
-------------------------
 

SELECT d.interval_length,
       d.interval IS NULL AS interval_is_null
FROM _timescaledb_catalog.dimension d
JOIN _timescaledb_catalog.hypertable h ON d.hypertable_id = h.id
WHERE h.table_name = 'non_calendar_ht';
 interval_length | interval_is_null 
-----------------+------------------
    345600000000 | t

-- GUC ON + INTERVAL input  stays non-calendar (converted to microseconds)
SET timescaledb.enable_calendar_chunking = true;
SELECT set_chunk_time_interval('non_calendar_ht', interval '5 days');
 set_chunk_time_interval 
-------------------------
 

SELECT d.interval_length,
       d.interval IS NULL AS interval_is_null
FROM _timescaledb_catalog.dimension d
JOIN _timescaledb_catalog.hypertable h ON d.hypertable_id = h.id
WHERE h.table_name = 'non_calendar_ht';
 interval_length | interval_is_null 
-----------------+------------------
    432000000000 | t

DROP TABLE non_calendar_ht;
---------------------------------------------------------------
-- CALENDAR HYPERTABLE TESTS
-- Created with calendar_chunking = ON
-- Should stay calendar regardless of GUC
-- Integer input should always error
---------------------------------------------------------------
SET timescaledb.enable_calendar_chunking = true;
CREATE TABLE calendar_ht(time timestamptz NOT NULL, value int);
SELECT create_hypertable('calendar_ht', 'time', chunk_time_interval => interval '1 day');
     create_hypertable     
---------------------------
 (24,public,calendar_ht,t)

-- Verify initial state: calendar mode (interval_length = 0, interval IS NOT NULL)
SELECT d.column_name,
       d.interval_length = 0 AS interval_length_is_zero,
       d.interval IS NOT NULL AS has_interval,
       d.interval
FROM _timescaledb_catalog.dimension d
JOIN _timescaledb_catalog.hypertable h ON d.hypertable_id = h.id
WHERE h.table_name = 'calendar_ht';
 column_name | interval_length_is_zero | has_interval | interval 
-------------+-------------------------+--------------+----------
 time        |                         | t            | @ 1 day

-- GUC ON + INTERVAL input  stays calendar
SET timescaledb.enable_calendar_chunking = true;
SELECT set_chunk_time_interval('calendar_ht', interval '2 days');
 set_chunk_time_interval 
-------------------------
 

SELECT d.interval_length = 0 AS interval_length_is_zero,
       d.interval IS NOT NULL AS has_interval,
       d.interval
FROM _timescaledb_catalog.dimension d
JOIN _timescaledb_catalog.hypertable h ON d.hypertable_id = h.id
WHERE h.table_name = 'calendar_ht';
 interval_length_is_zero | has_interval | interval 
-------------------------+--------------+----------
                         | t            | @ 2 days

-- GUC OFF + INTERVAL input  stays calendar
SET timescaledb.enable_calendar_chunking = false;
SELECT set_chunk_time_interval('calendar_ht', interval '3 days');
 set_chunk_time_interval 
-------------------------
 

SELECT d.interval_length = 0 AS interval_length_is_zero,
       d.interval IS NOT NULL AS has_interval,
       d.interval
FROM _timescaledb_catalog.dimension d
JOIN _timescaledb_catalog.hypertable h ON d.hypertable_id = h.id
WHERE h.table_name = 'calendar_ht';
 interval_length_is_zero | has_interval | interval 
-------------------------+--------------+----------
                         | t            | @ 3 days

-- GUC ON + integer input  ERROR (cannot use integer on calendar hypertable)
SET timescaledb.enable_calendar_chunking = true;
\set ON_ERROR_STOP 0
SELECT set_chunk_time_interval('calendar_ht', 86400000000::bigint);
ERROR:  cannot use integer interval on calendar-based hypertable
\set ON_ERROR_STOP 1
-- Verify unchanged after error
SELECT d.interval_length = 0 AS interval_length_is_zero,
       d.interval IS NOT NULL AS has_interval,
       d.interval
FROM _timescaledb_catalog.dimension d
JOIN _timescaledb_catalog.hypertable h ON d.hypertable_id = h.id
WHERE h.table_name = 'calendar_ht';
 interval_length_is_zero | has_interval | interval 
-------------------------+--------------+----------
                         | t            | @ 3 days

-- GUC OFF + integer input  ERROR (cannot use integer on calendar hypertable)
SET timescaledb.enable_calendar_chunking = false;
\set ON_ERROR_STOP 0
SELECT set_chunk_time_interval('calendar_ht', 172800000000::bigint);
ERROR:  cannot use integer interval on calendar-based hypertable
\set ON_ERROR_STOP 1
-- Verify unchanged after error
SELECT d.interval_length = 0 AS interval_length_is_zero,
       d.interval IS NOT NULL AS has_interval,
       d.interval
FROM _timescaledb_catalog.dimension d
JOIN _timescaledb_catalog.hypertable h ON d.hypertable_id = h.id
WHERE h.table_name = 'calendar_ht';
 interval_length_is_zero | has_interval | interval 
-------------------------+--------------+----------
                         | t            | @ 3 days

DROP TABLE calendar_ht;
RESET timescaledb.enable_calendar_chunking;
---------------------------------------------------------------
-- CHUNK POSITION RELATIVE TO ORIGIN
-- Test chunks before, enclosing, and after the origin
---------------------------------------------------------------
SET timezone = 'UTC';
SET timescaledb.enable_calendar_chunking = true;
-- Test with origin in the middle of the data range
-- Origin: 2020-01-15 (middle of January)
CREATE TABLE origin_position(time timestamptz NOT NULL, value int);
SELECT create_hypertable('origin_position',
    by_range('time', interval '1 month', partition_origin => '2020-01-15 00:00:00 UTC'::timestamptz));
 create_hypertable 
-------------------
 (25,t)

-- Insert data: before origin, enclosing origin, after origin
INSERT INTO origin_position VALUES
    -- Chunks BEFORE origin (historical data)
    ('2019-11-20 12:00:00 UTC', 1),  -- Nov 15 - Dec 15, 2019
    ('2019-12-20 12:00:00 UTC', 2),  -- Dec 15 - Jan 15, 2020
    -- Chunk ENCLOSING origin (origin is at chunk boundary)
    ('2020-01-15 00:00:00 UTC', 3),  -- Exactly at origin
    ('2020-01-20 12:00:00 UTC', 4),  -- Jan 15 - Feb 15, 2020
    -- Chunks AFTER origin
    ('2020-02-20 12:00:00 UTC', 5),  -- Feb 15 - Mar 15, 2020
    ('2020-03-20 12:00:00 UTC', 6);  -- Mar 15 - Apr 15, 2020
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks
WHERE hypertable_name = 'origin_position'
ORDER BY range_start;
     chunk_name     |         range_start          |          range_end           
--------------------+------------------------------+------------------------------
 _hyper_25_60_chunk | Fri Nov 15 00:00:00 2019 UTC | Sun Dec 15 00:00:00 2019 UTC
 _hyper_25_61_chunk | Sun Dec 15 00:00:00 2019 UTC | Wed Jan 15 00:00:00 2020 UTC
 _hyper_25_62_chunk | Wed Jan 15 00:00:00 2020 UTC | Sat Feb 15 00:00:00 2020 UTC
 _hyper_25_63_chunk | Sat Feb 15 00:00:00 2020 UTC | Sun Mar 15 00:00:00 2020 UTC
 _hyper_25_64_chunk | Sun Mar 15 00:00:00 2020 UTC | Wed Apr 15 00:00:00 2020 UTC

-- Verify data is in correct chunks
SELECT tableoid::regclass as chunk, time, value
FROM origin_position ORDER BY time;
                  chunk                   |             time             | value 
------------------------------------------+------------------------------+-------
 _timescaledb_internal._hyper_25_60_chunk | Wed Nov 20 12:00:00 2019 UTC |     1
 _timescaledb_internal._hyper_25_61_chunk | Fri Dec 20 12:00:00 2019 UTC |     2
 _timescaledb_internal._hyper_25_62_chunk | Wed Jan 15 00:00:00 2020 UTC |     3
 _timescaledb_internal._hyper_25_62_chunk | Mon Jan 20 12:00:00 2020 UTC |     4
 _timescaledb_internal._hyper_25_63_chunk | Thu Feb 20 12:00:00 2020 UTC |     5
 _timescaledb_internal._hyper_25_64_chunk | Fri Mar 20 12:00:00 2020 UTC |     6

DROP TABLE origin_position;
-- Test with daily chunks and origin at noon
-- This tests chunks before/after the origin time-of-day boundary
CREATE TABLE origin_daily(time timestamptz NOT NULL, value int);
SELECT create_hypertable('origin_daily',
    by_range('time', interval '1 day', partition_origin => '2020-06-15 12:00:00 UTC'::timestamptz));
 create_hypertable 
-------------------
 (26,t)

INSERT INTO origin_daily VALUES
    -- Before origin date (chunks before origin)
    ('2020-06-13 18:00:00 UTC', 1),  -- Jun 13 noon - Jun 14 noon
    ('2020-06-14 18:00:00 UTC', 2),  -- Jun 14 noon - Jun 15 noon
    -- At and after origin
    ('2020-06-15 12:00:00 UTC', 3),  -- Exactly at origin
    ('2020-06-15 18:00:00 UTC', 4),  -- Jun 15 noon - Jun 16 noon
    ('2020-06-16 06:00:00 UTC', 5),  -- Same chunk (before noon)
    ('2020-06-16 18:00:00 UTC', 6);  -- Jun 16 noon - Jun 17 noon
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks
WHERE hypertable_name = 'origin_daily'
ORDER BY range_start;
     chunk_name     |         range_start          |          range_end           
--------------------+------------------------------+------------------------------
 _hyper_26_65_chunk | Sat Jun 13 12:00:00 2020 UTC | Sun Jun 14 12:00:00 2020 UTC
 _hyper_26_66_chunk | Sun Jun 14 12:00:00 2020 UTC | Mon Jun 15 12:00:00 2020 UTC
 _hyper_26_67_chunk | Mon Jun 15 12:00:00 2020 UTC | Tue Jun 16 12:00:00 2020 UTC
 _hyper_26_68_chunk | Tue Jun 16 12:00:00 2020 UTC | Wed Jun 17 12:00:00 2020 UTC

DROP TABLE origin_daily;
---------------------------------------------------------------
-- EXTREME VALUES AND OVERFLOW CLAMPING TESTS
-- Test timestamps near the boundaries of the valid range
---------------------------------------------------------------
-- Test calc_range with ancient timestamps
-- PostgreSQL timestamp range: 4713 BC to 294276 AD
-- Ancient timestamp tests
SELECT *, end_ts - start_ts AS range_size FROM calc_range('4700-01-15 00:00:00 BC'::timestamptz, '1 year'::interval);
            start_ts             |             end_ts              | range_size 
---------------------------------+---------------------------------+------------
 Sat Jan 01 00:00:00 4700 UTC BC | Sun Jan 01 00:00:00 4699 UTC BC | @ 365 days

SELECT *, end_ts - start_ts AS range_size FROM calc_range('4700-01-15 00:00:00 BC'::timestamptz, '1 month'::interval);
            start_ts             |             end_ts              | range_size 
---------------------------------+---------------------------------+------------
 Sat Jan 01 00:00:00 4700 UTC BC | Tue Feb 01 00:00:00 4700 UTC BC | @ 31 days

SELECT *, end_ts - start_ts AS range_size FROM calc_range('4700-01-15 00:00:00 BC'::timestamptz, '1 day'::interval);
            start_ts             |             end_ts              | range_size 
---------------------------------+---------------------------------+------------
 Sat Jan 15 00:00:00 4700 UTC BC | Sun Jan 16 00:00:00 4700 UTC BC | @ 1 day

-- Far future timestamp tests (but within valid range)
SELECT *, end_ts - start_ts AS range_size FROM calc_range('100000-01-15 00:00:00'::timestamptz, '1 year'::interval);
            start_ts            |             end_ts             | range_size 
--------------------------------+--------------------------------+------------
 Sat Jan 01 00:00:00 100000 UTC | Mon Jan 01 00:00:00 100001 UTC | @ 366 days

SELECT *, end_ts - start_ts AS range_size FROM calc_range('100000-01-15 00:00:00'::timestamptz, '1 month'::interval);
            start_ts            |             end_ts             | range_size 
--------------------------------+--------------------------------+------------
 Sat Jan 01 00:00:00 100000 UTC | Tue Feb 01 00:00:00 100000 UTC | @ 31 days

SELECT *, end_ts - start_ts AS range_size FROM calc_range('100000-01-15 00:00:00'::timestamptz, '1 day'::interval);
            start_ts            |             end_ts             | range_size 
--------------------------------+--------------------------------+------------
 Sat Jan 15 00:00:00 100000 UTC | Sun Jan 16 00:00:00 100000 UTC | @ 1 day

-- Test hypertable with data spanning ancient times
CREATE TABLE extreme_ancient(time timestamptz NOT NULL, value int);
SELECT create_hypertable('extreme_ancient', 'time', chunk_time_interval => interval '100 years');
       create_hypertable       
-------------------------------
 (27,public,extreme_ancient,t)

INSERT INTO extreme_ancient VALUES
    ('4700-06-15 00:00:00 BC', 1),
    ('4600-06-15 00:00:00 BC', 2);
-- Verify chunks are created for ancient dates
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks
WHERE hypertable_name = 'extreme_ancient'
ORDER BY range_start;
     chunk_name     |           range_start           |            range_end            
--------------------+---------------------------------+---------------------------------
 _hyper_27_69_chunk | Sat Jan 01 00:00:00 4700 UTC BC | Thu Jan 01 00:00:00 4600 UTC BC
 _hyper_27_70_chunk | Thu Jan 01 00:00:00 4600 UTC BC | Tue Jan 01 00:00:00 4500 UTC BC

-- Show CHECK constraints on chunks with chunk size
-- Chunk size should be close to 100 years when not clamped
SELECT * FROM show_chunk_constraints('extreme_ancient');
       chunk        |                                                                        constraint_def                                                                        |  chunk_size  
--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------
 _hyper_27_69_chunk | CHECK ((("time" >= 'Sat Jan 01 00:00:00 4700 UTC BC'::timestamp with time zone) AND ("time" < 'Thu Jan 01 00:00:00 4600 UTC BC'::timestamp with time zone))) | @ 36524 days
 _hyper_27_70_chunk | CHECK ((("time" >= 'Thu Jan 01 00:00:00 4600 UTC BC'::timestamp with time zone) AND ("time" < 'Tue Jan 01 00:00:00 4500 UTC BC'::timestamp with time zone))) | @ 36524 days

DROP TABLE extreme_ancient;
-- Test hypertable with data in far future
CREATE TABLE extreme_future(time timestamptz NOT NULL, value int);
SELECT create_hypertable('extreme_future', 'time', chunk_time_interval => interval '100 years');
      create_hypertable       
------------------------------
 (28,public,extreme_future,t)

INSERT INTO extreme_future VALUES
    ('100000-06-15 00:00:00', 1),
    ('100100-06-15 00:00:00', 2);
-- Verify chunks are created for far future dates
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks
WHERE hypertable_name = 'extreme_future'
ORDER BY range_start;
     chunk_name     |          range_start           |           range_end            
--------------------+--------------------------------+--------------------------------
 _hyper_28_71_chunk | Tue Jan 01 00:00:00 99901 UTC  | Mon Jan 01 00:00:00 100001 UTC
 _hyper_28_72_chunk | Mon Jan 01 00:00:00 100001 UTC | Sat Jan 01 00:00:00 100101 UTC

-- Show CHECK constraints on chunks with chunk size
-- Chunk size should be close to 100 years when not clamped
SELECT * FROM show_chunk_constraints('extreme_future');
       chunk        |                                                                       constraint_def                                                                       |  chunk_size  
--------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------
 _hyper_28_71_chunk | CHECK ((("time" >= 'Tue Jan 01 00:00:00 99901 UTC'::timestamp with time zone) AND ("time" < 'Mon Jan 01 00:00:00 100001 UTC'::timestamp with time zone)))  | @ 36525 days
 _hyper_28_72_chunk | CHECK ((("time" >= 'Mon Jan 01 00:00:00 100001 UTC'::timestamp with time zone) AND ("time" < 'Sat Jan 01 00:00:00 100101 UTC'::timestamp with time zone))) | @ 36524 days

DROP TABLE extreme_future;
-- Test chunks with open-ended constraints (clamped to MIN/MAX)
-- Use large intervals that cause boundaries to overflow
CREATE TABLE open_ended_chunks(time timestamptz NOT NULL, value int);
SELECT create_hypertable('open_ended_chunks', 'time', chunk_time_interval => interval '10000 years');
        create_hypertable        
---------------------------------
 (29,public,open_ended_chunks,t)

-- Insert at boundaries - should create open-ended constraints
INSERT INTO open_ended_chunks VALUES
    ('4700-06-15 00:00:00 BC', 1),  -- Near min boundary, chunk start overflows
    ('294000-06-15 00:00:00', 2);   -- Near max boundary, chunk end overflows
-- Show CHECK constraints - should see open-ended constraints
-- Chunk size should be smaller than 10000 years when clamped
SELECT * FROM show_chunk_constraints('open_ended_chunks');
       chunk        |                                 constraint_def                                 | chunk_size 
--------------------+--------------------------------------------------------------------------------+------------
 _hyper_29_73_chunk | CHECK (("time" < 'Mon Jan 01 00:00:00 2001 UTC'::timestamp with time zone))    | 
 _hyper_29_74_chunk | CHECK (("time" >= 'Mon Jan 01 00:00:00 292001 UTC'::timestamp with time zone)) | 

DROP TABLE open_ended_chunks;
-- Test with origin far in the past - chunks before and after
CREATE TABLE origin_ancient(time timestamptz NOT NULL, value int);
SELECT create_hypertable('origin_ancient',
    by_range('time', interval '1000 years', partition_origin => '2000-01-01 00:00:00 BC'::timestamptz));
 create_hypertable 
-------------------
 (30,t)

INSERT INTO origin_ancient VALUES
    ('4000-06-15 00:00:00 BC', 1),  -- Before origin
    ('1500-06-15 00:00:00 BC', 2),  -- After origin (closer to present)
    ('500-06-15 00:00:00', 3),      -- After origin (AD)
    ('2020-06-15 00:00:00', 4);     -- Modern times
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks
WHERE hypertable_name = 'origin_ancient'
ORDER BY range_start;
     chunk_name     |           range_start           |            range_end            
--------------------+---------------------------------+---------------------------------
 _hyper_30_75_chunk | Mon Jan 01 00:00:00 4000 UTC BC | Thu Jan 01 00:00:00 3000 UTC BC
 _hyper_30_76_chunk | Mon Jan 01 00:00:00 2000 UTC BC | Thu Jan 01 00:00:00 1000 UTC BC
 _hyper_30_77_chunk | Mon Jan 01 00:00:00 0001 UTC    | Thu Jan 01 00:00:00 1001 UTC
 _hyper_30_78_chunk | Mon Jan 01 00:00:00 2001 UTC    | Thu Jan 01 00:00:00 3001 UTC

DROP TABLE origin_ancient;
-- Test with origin far in the future - all data before origin
CREATE TABLE origin_future(time timestamptz NOT NULL, value int);
SELECT create_hypertable('origin_future',
    by_range('time', interval '100 years', partition_origin => '50000-01-01 00:00:00'::timestamptz));
 create_hypertable 
-------------------
 (31,t)

INSERT INTO origin_future VALUES
    ('2020-06-15 00:00:00', 1),
    ('2120-06-15 00:00:00', 2),
    ('2220-06-15 00:00:00', 3);
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks
WHERE hypertable_name = 'origin_future'
ORDER BY range_start;
     chunk_name     |         range_start          |          range_end           
--------------------+------------------------------+------------------------------
 _hyper_31_79_chunk | Sat Jan 01 00:00:00 2000 UTC | Fri Jan 01 00:00:00 2100 UTC
 _hyper_31_80_chunk | Fri Jan 01 00:00:00 2100 UTC | Wed Jan 01 00:00:00 2200 UTC
 _hyper_31_81_chunk | Wed Jan 01 00:00:00 2200 UTC | Mon Jan 01 00:00:00 2300 UTC

DROP TABLE origin_future;
---------------------------------------------------------------
-- MIXED INTERVAL TESTS WITH EXTREME VALUES
-- Test intervals with month+day+time components near boundaries
---------------------------------------------------------------
-- Mixed interval (month + day) with values spanning origin
SELECT * FROM calc_range('2020-01-15 00:00:00 UTC'::timestamptz, '1 month 15 days'::interval,
                         '2020-02-01 00:00:00 UTC'::timestamptz);
           start_ts           |            end_ts            
------------------------------+------------------------------
 Tue Dec 17 00:00:00 2019 UTC | Sat Feb 01 00:00:00 2020 UTC

SELECT * FROM calc_range('2020-02-01 00:00:00 UTC'::timestamptz, '1 month 15 days'::interval,
                         '2020-02-01 00:00:00 UTC'::timestamptz);
           start_ts           |            end_ts            
------------------------------+------------------------------
 Sat Feb 01 00:00:00 2020 UTC | Mon Mar 16 00:00:00 2020 UTC

SELECT * FROM calc_range('2020-03-01 00:00:00 UTC'::timestamptz, '1 month 15 days'::interval,
                         '2020-02-01 00:00:00 UTC'::timestamptz);
           start_ts           |            end_ts            
------------------------------+------------------------------
 Sat Feb 01 00:00:00 2020 UTC | Mon Mar 16 00:00:00 2020 UTC

-- Mixed interval with ancient dates
SELECT *, end_ts - start_ts AS range_size FROM calc_range('4700-01-15 00:00:00 BC'::timestamptz, '1 month 15 days'::interval);
            start_ts             |             end_ts              | range_size 
---------------------------------+---------------------------------+------------
 Sun Dec 19 00:00:00 4701 UTC BC | Thu Feb 03 00:00:00 4700 UTC BC | @ 46 days

SELECT *, end_ts - start_ts AS range_size FROM calc_range('50000-01-15 00:00:00'::timestamptz, '1 month 15 days'::interval);
           start_ts            |            end_ts             | range_size 
-------------------------------+-------------------------------+------------
 Sat Jan 01 00:00:00 50000 UTC | Wed Feb 16 00:00:00 50000 UTC | @ 46 days

-- Create hypertable with mixed interval
CREATE TABLE mixed_interval(time timestamptz NOT NULL, value int);
SELECT create_hypertable('mixed_interval',
    by_range('time', interval '1 month 15 days', partition_origin => '2020-01-01 00:00:00 UTC'::timestamptz));
 create_hypertable 
-------------------
 (32,t)

INSERT INTO mixed_interval VALUES
    ('2019-12-01 00:00:00 UTC', 1),  -- Before origin
    ('2020-01-01 00:00:00 UTC', 2),  -- At origin
    ('2020-01-20 00:00:00 UTC', 3),  -- Same chunk as origin
    ('2020-02-20 00:00:00 UTC', 4),  -- Next chunk
    ('2020-04-01 00:00:00 UTC', 5);  -- Two chunks after
SELECT chunk_name, range_start, range_end
FROM timescaledb_information.chunks
WHERE hypertable_name = 'mixed_interval'
ORDER BY range_start;
     chunk_name     |         range_start          |          range_end           
--------------------+------------------------------+------------------------------
 _hyper_32_82_chunk | Sat Nov 16 00:00:00 2019 UTC | Wed Jan 01 00:00:00 2020 UTC
 _hyper_32_83_chunk | Wed Jan 01 00:00:00 2020 UTC | Sun Feb 16 00:00:00 2020 UTC
 _hyper_32_84_chunk | Sun Feb 16 00:00:00 2020 UTC | Tue Mar 31 00:00:00 2020 UTC
 _hyper_32_85_chunk | Tue Mar 31 00:00:00 2020 UTC | Fri May 15 00:00:00 2020 UTC

DROP TABLE mixed_interval;
---------------------------------------------------------------
-- INTEGER DIMENSION OVERFLOW TESTS
-- Test integer dimensions with values near INT64 boundaries
---------------------------------------------------------------
-- Test bigint with large positive values
CREATE TABLE int_extreme_max(time bigint NOT NULL, value int);
SELECT create_hypertable('int_extreme_max', by_range('time', 1000000000000, partition_origin => 0));
 create_hypertable 
-------------------
 (33,t)

INSERT INTO int_extreme_max VALUES
    (9223372036854775000, 1),  -- Near INT64_MAX
    (9223372036854774000, 2);
SELECT * FROM show_int_chunk_slices('int_extreme_max');
     chunk_name     |     range_start     |      range_end      | chunk_size  
--------------------+---------------------+---------------------+-------------
 _hyper_33_86_chunk | 9223372000000000000 | 9223372036854775807 | 36854775807

-- Show CHECK constraints - should see open-ended constraint (no upper bound)
SELECT * FROM show_check_constraints('int_extreme_max');
       chunk        |                  constraint_def                   
--------------------+---------------------------------------------------
 _hyper_33_86_chunk | CHECK (("time" >= '9223372000000000000'::bigint))

DROP TABLE int_extreme_max;
-- Test bigint with large negative values
CREATE TABLE int_extreme_min(time bigint NOT NULL, value int);
SELECT create_hypertable('int_extreme_min', by_range('time', 1000000000000, partition_origin => 0));
 create_hypertable 
-------------------
 (34,t)

INSERT INTO int_extreme_min VALUES
    (-9223372036854775000, 1),  -- Near INT64_MIN
    (-9223372036854774000, 2);
SELECT * FROM show_int_chunk_slices('int_extreme_min');
     chunk_name     |     range_start      |      range_end       | chunk_size  
--------------------+----------------------+----------------------+-------------
 _hyper_34_87_chunk | -9223372036854775808 | -9223372000000000000 | 36854775808

-- Show CHECK constraints - should see open-ended constraint (no lower bound)
SELECT * FROM show_check_constraints('int_extreme_min');
       chunk        |                  constraint_def                   
--------------------+---------------------------------------------------
 _hyper_34_87_chunk | CHECK (("time" < '-9223372000000000000'::bigint))

DROP TABLE int_extreme_min;
-- Test integer origin with values on both sides
CREATE TABLE int_origin_sides(time bigint NOT NULL, value int);
SELECT create_hypertable('int_origin_sides', by_range('time', 100, partition_origin => 1000));
 create_hypertable 
-------------------
 (35,t)

INSERT INTO int_origin_sides VALUES
    (850, 1),   -- Chunk [800, 900)
    (950, 2),   -- Chunk [900, 1000)
    (1000, 3),  -- At origin, chunk [1000, 1100)
    (1050, 4),  -- Same chunk as origin
    (1100, 5),  -- Chunk [1100, 1200)
    (1150, 6);  -- Same chunk
SELECT * FROM show_int_chunk_slices('int_origin_sides');
     chunk_name     | range_start | range_end | chunk_size 
--------------------+-------------+-----------+------------
 _hyper_35_88_chunk |         800 |       900 |        100
 _hyper_35_89_chunk |         900 |      1000 |        100
 _hyper_35_90_chunk |        1000 |      1100 |        100
 _hyper_35_91_chunk |        1100 |      1200 |        100

-- Verify data placement
SELECT tableoid::regclass as chunk, time, value
FROM int_origin_sides ORDER BY time;
                  chunk                   | time | value 
------------------------------------------+------+-------
 _timescaledb_internal._hyper_35_88_chunk |  850 |     1
 _timescaledb_internal._hyper_35_89_chunk |  950 |     2
 _timescaledb_internal._hyper_35_90_chunk | 1000 |     3
 _timescaledb_internal._hyper_35_90_chunk | 1050 |     4
 _timescaledb_internal._hyper_35_91_chunk | 1100 |     5
 _timescaledb_internal._hyper_35_91_chunk | 1150 |     6

DROP TABLE int_origin_sides;
RESET timezone;
RESET timescaledb.enable_calendar_chunking;
---------------------------------------------------------------
-- TIMESTAMP WITHOUT TIMEZONE AND GENERAL ALGORITHM TESTS
---------------------------------------------------------------
-- Test ts_chunk_range_calculate_general() with timestamp (without timezone)
-- and boundary/overflow values for improved test coverage
\c :TEST_DBNAME :ROLE_SUPERUSER
-- Create wrapper function for timestamp without timezone
CREATE OR REPLACE FUNCTION calc_range_ts(ts TIMESTAMP, chunk_interval INTERVAL, origin TIMESTAMP DEFAULT NULL, force_general BOOL DEFAULT NULL)
RETURNS TABLE(start_ts TIMESTAMP, end_ts TIMESTAMP) AS :MODULE_PATHNAME, 'ts_dimension_calculate_open_range_calendar' LANGUAGE C;
SET ROLE :ROLE_DEFAULT_PERM_USER;
SET timescaledb.enable_calendar_chunking = true;
-- Test timestamp without timezone using general algorithm (force_general=true)
-- Covers various intervals and boundary values in a single query
SELECT t.ts, i.inv, r.start_ts, r.end_ts, r.end_ts - r.start_ts AS range_size
FROM unnest(ARRAY[
    '2025-03-15 12:00:00'::timestamp,
    '4700-01-15 00:00:00 BC'::timestamp,
    '100000-01-15 00:00:00'::timestamp
]) AS t(ts)
CROSS JOIN unnest(ARRAY[
    '1 day'::interval,
    '1 month'::interval,
    '1 year'::interval,
    '100 years'::interval,
    '1 month 15 days'::interval
]) AS i(inv)
CROSS JOIN LATERAL calc_range_ts(t.ts, i.inv, NULL, true) r
ORDER BY t.ts, i.inv;
             ts              |       inv       |          start_ts           |           end_ts            |  range_size  
-----------------------------+-----------------+-----------------------------+-----------------------------+--------------
 Sat Jan 15 00:00:00 4700 BC | @ 1 day         | Sat Jan 15 00:00:00 4700 BC | Sun Jan 16 00:00:00 4700 BC | @ 1 day
 Sat Jan 15 00:00:00 4700 BC | @ 1 mon         | Sat Jan 01 00:00:00 4700 BC | Tue Feb 01 00:00:00 4700 BC | @ 31 days
 Sat Jan 15 00:00:00 4700 BC | @ 1 mon 15 days | Sun Dec 19 00:00:00 4701 BC | Thu Feb 03 00:00:00 4700 BC | @ 46 days
 Sat Jan 15 00:00:00 4700 BC | @ 1 year        | Sat Jan 01 00:00:00 4700 BC | Sun Jan 01 00:00:00 4699 BC | @ 365 days
 Sat Jan 15 00:00:00 4700 BC | @ 100 years     | Sat Jan 01 00:00:00 4700 BC | Thu Jan 01 00:00:00 4600 BC | @ 36524 days
 Sat Mar 15 12:00:00 2025    | @ 1 day         | Sat Mar 15 00:00:00 2025    | Sun Mar 16 00:00:00 2025    | @ 1 day
 Sat Mar 15 12:00:00 2025    | @ 1 mon         | Sat Mar 01 00:00:00 2025    | Tue Apr 01 00:00:00 2025    | @ 31 days
 Sat Mar 15 12:00:00 2025    | @ 1 mon 15 days | Mon Feb 17 00:00:00 2025    | Tue Apr 01 00:00:00 2025    | @ 43 days
 Sat Mar 15 12:00:00 2025    | @ 1 year        | Wed Jan 01 00:00:00 2025    | Thu Jan 01 00:00:00 2026    | @ 365 days
 Sat Mar 15 12:00:00 2025    | @ 100 years     | Mon Jan 01 00:00:00 2001    | Sat Jan 01 00:00:00 2101    | @ 36524 days
 Sat Jan 15 00:00:00 100000  | @ 1 day         | Sat Jan 15 00:00:00 100000  | Sun Jan 16 00:00:00 100000  | @ 1 day
 Sat Jan 15 00:00:00 100000  | @ 1 mon         | Sat Jan 01 00:00:00 100000  | Tue Feb 01 00:00:00 100000  | @ 31 days
 Sat Jan 15 00:00:00 100000  | @ 1 mon 15 days | Fri Dec 31 00:00:00 99999   | Tue Feb 15 00:00:00 100000  | @ 46 days
 Sat Jan 15 00:00:00 100000  | @ 1 year        | Sat Jan 01 00:00:00 100000  | Mon Jan 01 00:00:00 100001  | @ 366 days
 Sat Jan 15 00:00:00 100000  | @ 100 years     | Tue Jan 01 00:00:00 99901   | Mon Jan 01 00:00:00 100001  | @ 36525 days

-- Test timestamptz with general algorithm for comparison
SELECT t.ts, i.inv, r.start_ts, r.end_ts, r.end_ts - r.start_ts AS range_size
FROM unnest(ARRAY[
    '2025-03-15 12:00:00 UTC'::timestamptz,
    '4700-01-15 00:00:00 BC'::timestamptz,
    '100000-01-15 00:00:00'::timestamptz
]) AS t(ts)
CROSS JOIN unnest(ARRAY[
    '1 day'::interval,
    '1 month'::interval,
    '1 year'::interval,
    '100 years'::interval,
    '1 month 15 days'::interval
]) AS i(inv)
CROSS JOIN LATERAL calc_range(t.ts, i.inv, NULL, true) r
ORDER BY t.ts, i.inv;
               ts                |       inv       |            start_ts             |             end_ts              |     range_size     
---------------------------------+-----------------+---------------------------------+---------------------------------+--------------------
 Sat Jan 15 00:00:00 4700 LMT BC | @ 1 day         | Sat Jan 15 00:00:00 4700 LMT BC | Sun Jan 16 00:00:00 4700 LMT BC | @ 1 day
 Sat Jan 15 00:00:00 4700 LMT BC | @ 1 mon         | Sat Jan 01 00:00:00 4700 LMT BC | Tue Feb 01 00:00:00 4700 LMT BC | @ 31 days
 Sat Jan 15 00:00:00 4700 LMT BC | @ 1 mon 15 days | Sun Dec 19 00:00:00 4701 LMT BC | Thu Feb 03 00:00:00 4700 LMT BC | @ 46 days
 Sat Jan 15 00:00:00 4700 LMT BC | @ 1 year        | Sat Jan 01 00:00:00 4700 LMT BC | Sun Jan 01 00:00:00 4699 LMT BC | @ 365 days
 Sat Jan 15 00:00:00 4700 LMT BC | @ 100 years     | Sat Jan 01 00:00:00 4700 LMT BC | Thu Jan 01 00:00:00 4600 LMT BC | @ 36524 days
 Sat Mar 15 05:00:00 2025 PDT    | @ 1 day         | Sat Mar 15 00:00:00 2025 PDT    | Sun Mar 16 00:00:00 2025 PDT    | @ 1 day
 Sat Mar 15 05:00:00 2025 PDT    | @ 1 mon         | Sat Mar 01 00:00:00 2025 PST    | Tue Apr 01 00:00:00 2025 PDT    | @ 30 days 23 hours
 Sat Mar 15 05:00:00 2025 PDT    | @ 1 mon 15 days | Mon Feb 17 00:00:00 2025 PST    | Tue Apr 01 00:00:00 2025 PDT    | @ 42 days 23 hours
 Sat Mar 15 05:00:00 2025 PDT    | @ 1 year        | Wed Jan 01 00:00:00 2025 PST    | Thu Jan 01 00:00:00 2026 PST    | @ 365 days
 Sat Mar 15 05:00:00 2025 PDT    | @ 100 years     | Mon Jan 01 00:00:00 2001 PST    | Sat Jan 01 00:00:00 2101 PST    | @ 36524 days
 Sat Jan 15 00:00:00 100000 PST  | @ 1 day         | Sat Jan 15 00:00:00 100000 PST  | Sun Jan 16 00:00:00 100000 PST  | @ 1 day
 Sat Jan 15 00:00:00 100000 PST  | @ 1 mon         | Sat Jan 01 00:00:00 100000 PST  | Tue Feb 01 00:00:00 100000 PST  | @ 31 days
 Sat Jan 15 00:00:00 100000 PST  | @ 1 mon 15 days | Fri Dec 31 00:00:00 99999 PST   | Tue Feb 15 00:00:00 100000 PST  | @ 46 days
 Sat Jan 15 00:00:00 100000 PST  | @ 1 year        | Sat Jan 01 00:00:00 100000 PST  | Mon Jan 01 00:00:00 100001 PST  | @ 366 days
 Sat Jan 15 00:00:00 100000 PST  | @ 100 years     | Tue Jan 01 00:00:00 99901 PST   | Mon Jan 01 00:00:00 100001 PST  | @ 36525 days

-- Large interval test (1000 years) - separate due to potential overflow
SELECT *, end_ts - start_ts AS range_size FROM calc_range_ts('2025-03-15 12:00:00'::timestamp, '1000 years'::interval, NULL, true);
         start_ts         |          end_ts          |  range_size   
--------------------------+--------------------------+---------------
 Mon Jan 01 00:00:00 2001 | Thu Jan 01 00:00:00 3001 | @ 365242 days

SELECT *, end_ts - start_ts AS range_size FROM calc_range('2025-03-15 00:00:00 UTC'::timestamptz, '1000 years'::interval, NULL, true);
           start_ts           |            end_ts            |  range_size   
------------------------------+------------------------------+---------------
 Mon Jan 01 00:00:00 2001 PST | Thu Jan 01 00:00:00 3001 PST | @ 365242 days

-- Cleanup
\c :TEST_DBNAME :ROLE_SUPERUSER
DROP FUNCTION calc_range_ts(TIMESTAMP, INTERVAL, TIMESTAMP, BOOL);
SET ROLE :ROLE_DEFAULT_PERM_USER;
RESET timescaledb.enable_calendar_chunking;
---------------------------------------------------------------
-- ERROR PATH TESTS
-- Test error handling for invalid timestamp values
-- These test the timestamp_datum_to_tm error paths in calc_month_chunk_range
-- and calc_day_chunk_range which trigger "timestamp out of range" errors.
---------------------------------------------------------------
-- Test month interval with infinity timestamp (triggers timestamp out of range)
\set ON_ERROR_STOP 0
SELECT * FROM calc_range('infinity'::timestamptz, '1 month'::interval);
ERROR:  timestamp out of range
SELECT * FROM calc_range('-infinity'::timestamptz, '1 month'::interval);
ERROR:  timestamp out of range
-- Test month interval with infinity origin (triggers origin timestamp out of range)
SELECT * FROM calc_range('2025-01-15'::timestamptz, '1 month'::interval, 'infinity'::timestamptz);
ERROR:  origin timestamp out of range
SELECT * FROM calc_range('2025-01-15'::timestamptz, '1 month'::interval, '-infinity'::timestamptz);
ERROR:  origin timestamp out of range
-- Test day interval with infinity timestamp
SELECT * FROM calc_range('infinity'::timestamptz, '1 day'::interval);
ERROR:  timestamp out of range
SELECT * FROM calc_range('-infinity'::timestamptz, '1 day'::interval);
ERROR:  timestamp out of range
-- Test day interval with infinity origin
SELECT * FROM calc_range('2025-01-15'::timestamptz, '1 day'::interval, 'infinity'::timestamptz);
ERROR:  origin timestamp out of range
SELECT * FROM calc_range('2025-01-15'::timestamptz, '1 day'::interval, '-infinity'::timestamptz);
ERROR:  origin timestamp out of range
-- Test sub-day interval with infinity values (these go through calc_sub_day_chunk_range)
SELECT * FROM calc_range('infinity'::timestamptz, '1 hour'::interval);
ERROR:  timestamp out of range
SELECT * FROM calc_range('-infinity'::timestamptz, '1 hour'::interval);
ERROR:  timestamp out of range
SELECT * FROM calc_range('2025-01-15'::timestamptz, '1 hour'::interval, 'infinity'::timestamptz);
ERROR:  origin timestamp out of range
SELECT * FROM calc_range('2025-01-15'::timestamptz, '1 hour'::interval, '-infinity'::timestamptz);
ERROR:  origin timestamp out of range
\set ON_ERROR_STOP 1
-- Test large intervals that produce chunk boundaries outside PostgreSQL's timestamp range
-- These verify that tm2timestamp failures are handled by clamping to -infinity/+infinity
-- Large month interval: 2 billion months (~166 million years) - chunk end exceeds max timestamp
SELECT * FROM calc_range('2025-01-15'::timestamptz, '2000000000 months'::interval);
           start_ts           |  end_ts  
------------------------------+----------
 Mon Jan 01 00:00:00 2001 PST | infinity

-- Large day interval: 2 billion days (~5.4 million years) - chunk end exceeds max timestamp
SELECT * FROM calc_range('2025-01-15'::timestamptz, '2000000000 days'::interval);
           start_ts           |  end_ts  
------------------------------+----------
 Mon Jan 01 00:00:00 2001 PST | infinity

-- Large month interval with ancient origin - chunk end exceeds max timestamp
SELECT * FROM calc_range('290000-01-15'::timestamptz, '200000000 months'::interval, '4000-01-01 BC'::timestamptz);
            start_ts             |  end_ts  
---------------------------------+----------
 Mon Jan 01 00:00:00 4000 LMT BC | infinity

-- Large day interval with future origin - chunk start precedes min timestamp
SELECT * FROM calc_range('4000-01-15 BC'::timestamptz, '100000000 days'::interval, '290000-01-01'::timestamptz);
 start_ts  |            end_ts             
-----------+-------------------------------
 -infinity | Thu Apr 20 00:00:00 16209 PDT

-- Test INT32 overflow in end_julian calculation: start_julian (~108M) + interval->day (~2.1B) > INT32_MAX
-- This triggers pg_add_s32_overflow in calc_day_chunk_range for end_julian
SELECT * FROM calc_range('290000-01-15'::timestamptz, '2100000000 days'::interval, '290000-01-01'::timestamptz);
            start_ts            |  end_ts  
--------------------------------+----------
 Sat Jan 01 00:00:00 290000 PST | infinity

-- Test INT32 overflow in end_total_months_from_jan: total_months_from_jan + interval->month > INT32_MAX
-- This triggers pg_add_s32_overflow in calc_month_chunk_range for end_total_months_from_jan
-- Use origin in December so total_months_from_jan starts at 11, making 11 + 2147483647 overflow
SELECT * FROM calc_range('2025-01-15'::timestamptz, '2147483647 months'::interval, '2001-12-01'::timestamptz);
           start_ts           |  end_ts  
------------------------------+----------
 Sat Dec 01 00:00:00 2001 PST | infinity

-- Test sub-day interval overflow: ts_val - origin_val can overflow INT64 when timestamps are at opposite extremes
-- This triggers pg_sub_s64_overflow in calc_sub_day_chunk_range
\set ON_ERROR_STOP 0
SELECT * FROM calc_range('4700-01-15 BC'::timestamptz, '1 hour'::interval, '294000-01-01'::timestamptz);
ERROR:  interval out of range
\set ON_ERROR_STOP 1
---------------------------------------------------------------
-- C UNIT TESTS
-- Test saturating arithmetic and chunk range calculation
---------------------------------------------------------------
\c :TEST_DBNAME :ROLE_SUPERUSER
SELECT test_chunk_range();
 test_chunk_range 
------------------
 

SET ROLE :ROLE_DEFAULT_PERM_USER;
---------------------------------------------------------------
-- CLEANUP
---------------------------------------------------------------
DROP FUNCTION test_ranges(TIMESTAMPTZ[], INTERVAL[]);
DROP FUNCTION test_ranges_with_origin(TIMESTAMPTZ[], INTERVAL[], TIMESTAMPTZ);
DROP FUNCTION show_chunk_constraints(text);
DROP FUNCTION show_int_chunk_slices(text);
DROP FUNCTION show_check_constraints(text);
RESET timezone;
RESET timescaledb.enable_calendar_chunking;
\set VERBOSITY default
